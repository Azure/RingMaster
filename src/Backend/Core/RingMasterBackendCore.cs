// ***********************************************************************
// Assembly         : RingMaster
// <copyright file="RingMasterBackendCore.cs" company="Microsoft">
//     Copyright ©  2015
// </copyright>
// <summary></summary>
// ***********************************************************************

namespace Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;

    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend.AsyncCallback;
    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend.Data;
    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend.HelperTypes;
    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend.Persistence;
    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Data;

    using Code = Microsoft.Azure.Networking.Infrastructure.RingMaster.Data.RingMasterException.Code;
    using Perm = Microsoft.Azure.Networking.Infrastructure.RingMaster.Data.Acl.Perm;
    using RequestDefinitions = Microsoft.Azure.Networking.Infrastructure.RingMaster.Requests;
    using RequestResponse = Microsoft.Azure.Networking.Infrastructure.RingMaster.Requests.RequestResponse;
    using RingMasterRequestType = Microsoft.Azure.Networking.Infrastructure.RingMaster.Requests.RingMasterRequestType;

    /// <summary>
    /// Class RingMasterBackendCore.
    /// This implements the actual business logics on the server.
    /// </summary>
    public class RingMasterBackendCore : IPersistedDataFactoryClient, IRingMasterRequestExecutor, IUnsafeTreeAccess, IDisposable
    {
        /// <summary>
        /// The root digest
        /// </summary>
        public const string RootDigest = "digest:root";

        /// <summary>
        /// Gets or sets a value indicating if writes are allowed
        /// </summary>
        internal bool WritesAllowed
        {
            get; private set;
        }

        /// <summary>
        /// Gets or sets a value indicating if this replica is in full lockdown right now
        /// </summary>
        internal bool IsInFullLockDown
        {
            get ; private set;
        }

        /// <summary>
        /// Gets or sets a value indicating if this instance can take a measurement right now
        /// </summary>
        private bool CanMeasure
        {
            get; set;
        }

        /// <summary>
        /// Unique Id of the execution queue where all requests from the transaction manager will be queued.
        /// </summary>
        private static readonly Guid TransactionManagerExecutionQueueId = new Guid(0xa49152f7, 0x8f9c, 0x4606, 0x97, 0x6d, 0x74, 0xd7, 0xe9, 0xa6, 0xd8, 0x3c);

        /// <summary>
        /// Interface to an object that can consume audit events generated by this class.
        /// </summary>
        private readonly IRingMasterAudit auditConsumer;

        /// <summary>
        /// Cached Information about time stream progress
        /// </summary>
        private Dictionary<ulong, TimeStreamInfo> timeStreamInfo = new Dictionary<ulong, TimeStreamInfo>();

        /// <summary>
        /// if true, we will foce the creation of a WB trace
        /// </summary>
        private const bool forceWB = false;

        /// <summary>
        /// The last time CanBecomePrimary was invoked
        /// </summary>
        private DateTime lastCanBP = DateTime.MinValue;

        /// <summary>
        /// The max time in seconds a primary promotion may take
        /// </summary>
        private const int maxSecondsForPrimaryPromotion = 60;

        /// <summary>
        /// Maximum number of samples in node.Data used to compute a PersistentData hash value.
        /// </summary>
        private static int MaxSamplesForDataHashSet = 8;

        /// <summary>
        /// The maximum time in millis to complete the measurement
        /// </summary>
        private static int MaxTimeForMeasurementInMillis = (int)TimeSpan.FromMinutes(2).TotalMilliseconds;

        /// <summary>
        /// When measuring, we will trace a info line every TraceMeasuredNodesInMultiplesOf nodes measured.
        /// </summary>
        private static int TraceMeasuredNodesInMultiplesOf = 500000;

        /// <summary>
        /// The measure session identifier. Every time we are doing a measurement, this id is incremented.
        /// That is also used to cancel the ongoing measurements.
        /// </summary>
        private long measureSessionId = 0;

        /// <summary>
        /// The processor of actions on replicas as secondaries
        /// </summary>
        private SecondaryPreprocessor secondarypreprocessor;

        /// <summary>
        /// If true, it will start main endpoint on secondary nodes
        /// </summary>
        private bool startMainEndpointOnSecondary;

        /// <summary>
        /// If true, it will start the extra endpoints on secondary nodes
        /// </summary>
        private bool startExtraEndpointOnSecondary;

        /// <summary>
        /// The SSL wrapping for server to connect to itself
        /// </summary>
        private SslWrapping sslWrappingForRMLoopbackConnect { get; set; }

        /// <summary>
        /// Limits for RingMaster
        /// </summary>
        private readonly RingMasterLimits limits;

        /// <summary>
        /// The list of paths to be locked down
        /// </summary>
        private readonly LockDownSet lockDownPaths = new LockDownSet();

        // the lock to protect two concurrent changes on the lockdownpath
        private object lockDownPathsChangeLock = new object();

        /// <summary>
        /// The list of paths that if an operation on any of them fail, we need global lockdown
        /// </summary>
        public HashSet<string> blacklist;

        /// <summary>
        /// The list of paths that are safe to not lock down
        /// </summary>
        public HashSet<string> ignoreList;

        /// <summary>
        /// Sets the pseudo nodes data.
        /// </summary>
        /// <param name="port">The port to the primary.</param>
        /// <param name="ssl">The SSL to use.</param>
        public void SetPseudoNodesData(int port, SslWrapping ssl)
        {
            this.OnStart = () =>
            {
                this.StartPseudoNodes(port, ssl);
            };

            this.OnStop = () =>
            {
                this.StopPseudoNodes();
            };
        }

        /// <summary>
        /// Sets the pseudo nodes data.
        /// </summary>
        public void SetPseudoNodesDataAsLoopback()
        {
            this.OnStart = () =>
            {
                this.StartPseudoNodes(() =>
                {
                    return new LoopbackRingMaster(this);
                });
            };

            this.OnStop = () =>
            {
                this.StopPseudoNodes();
            };
        }

        /// <summary>
        /// sets up wirebackup on the given configuration
        /// </summary>
        /// <param name="wireBackupPath">path to drop the wirebackup files</param>
        /// <param name="maxEvents">max number of events per file</param>
        /// <param name="maxTimeInMillis">max time in millis per file</param>
        /// <param name="maxEventsBetweenSnapshots">max eents between snapshots</param>
        /// <param name="maxTimeBetweenSnapshotsMillis">max time between snapshots im millis</param>
        /// <param name="keepBackupForSec">Keep backup for seconds and delete it</param>
        public void SetupWireBackup(string wireBackupPath, int maxEvents, int maxTimeInMillis, int maxEventsBetweenSnapshots, int maxTimeBetweenSnapshotsMillis, int keepBackupForSec)
        {
            DisableWireBackup();

            WireBackup wirebackup = new WireBackup(wireBackupPath, TakeWBSnapshot, maxEvents, maxTimeInMillis, maxEventsBetweenSnapshots, maxTimeBetweenSnapshotsMillis, keepBackupForSec);
            this.secondarypreprocessor.SetWireBackup(wirebackup, true);
        }

        /// <summary>
        /// Records this replica may become primary in the following few seconds
        /// </summary>
        private void RecordPromotionQuery()
        {
            this.lastCanBP = DateTime.UtcNow;

            this.secondarypreprocessor.CancelAnyOngoingActivity();
        }

        /// <summary>
        /// Indicates if is is posible for this replica to become primary in the following few seconds
        /// </summary>
        /// <returns><c>true</c> if we are or we may be primary in the next few seconds, <c>false</c> otherwise.</returns>
        private bool IsOrMayBecomePrimary()
        {
            if (this.IsPrimary())
            {
                return true;
            }

            return DateTime.UtcNow - this.lastCanBP < TimeSpan.FromSeconds(maxSecondsForPrimaryPromotion);
        }

        /// <summary>
        /// Takes the wirebackup snapshot.
        /// </summary>
        /// <returns><c>true</c> if the wirebackup snapshot was taken, <c>false</c> otherwise.</returns>
        public bool TakeWBSnapshot()
        {
            if (Root == null)
            {
                return false;
            }

            // exit if we are not in position to take a snapshot now
            // this can be because we are a primary, or because we may become a primary in the following few seconds

            if (this.IsOrMayBecomePrimary())
            {
                return false;
            }

            // if not, take the root's lock. That will also idicate the CanBecomePrimary we are not eligible right now to become a primary
            ((IUnsafeTreeAccess)this).LockRootNoSync();

            bool result;

            try
            {
                // record a new snapshot is being taken
                int newId = this.secondarypreprocessor.GenerateNewWBackupId();
                result = TakeWBSnapshot(newId, Root.Persisted);
            }
            finally
            {
                ((IUnsafeTreeAccess)this).ReleaseRoot();
            }

            return true;
        }

        /// <summary>
        /// Takes the wb snapshot. as long as the wirebackup id is the one we got from the stack
        /// </summary>
        /// <param name="wbId">The wb identifier.</param>
        /// <param name="nd">The node to start from.</param>
        /// <returns><c>true</c> if we took the whole snapshot, <c>false</c> otherwise.</returns>
        private bool TakeWBSnapshot(int wbId, IPersistedData nd)
        {
            // check that the WB was not aborted
            if (wbId != secondarypreprocessor.WbackupId)
            {
                return false;
            }

            secondarypreprocessor.AppendCreate(nd, nd.Stat.Ctime, nd.Stat.Czxid);

            foreach (IPersistedData d in nd.Node.ChildrenMapping.Values)
            {
                secondarypreprocessor.AppendAddChild(nd.Id, d.Id, nd.Stat.Ctime, nd.Stat.Czxid);
            }

            foreach (IPersistedData d in nd.Node.ChildrenMapping.Values)
            {
                if (!TakeWBSnapshot(wbId, d))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// disables the wire backup
        /// </summary>
        public void DisableWireBackup()
        {
            this.secondarypreprocessor.StopWireBackup();
        }

        /// <summary>
        /// The _has root
        /// </summary>
        private ManualResetEvent _hasRoot = new ManualResetEvent(false);

        /// <summary>
        /// the instance to manage cluster psudo-nodes.
        /// </summary>
        private readonly PseudoNodes pseudoNodes;

        internal event Action OnAfterBecomePrimary = null;
        internal event Action OnAfterPrimaryStatusLost = null;

        /// <summary>
        /// waits until invoking stop is safe for the cluster, or up to the given maxTime.
        /// </summary>
        /// <param name="maxTime">the expiration time for the validation</param>
        /// <returns>true if it is safe to stop the instance</returns>
        public bool WaitUntilStopIsSafe(DateTime maxTime, out ClusterState lastHealth)
        {
            while (true)
            {
                bool failoverWillHappen;

                if (!this.Factory.UnsafeToStopInstance(this.Factory.Name, out failoverWillHappen))
                {
                    lastHealth = new ClusterState(this.Factory);
                    return true;
                }

                Trace.TraceInformation("WaitUntilStopIsSafe: not safe yet");

                if (DateTime.UtcNow > maxTime)
                {
                    lastHealth = new ClusterState(this.Factory);
                    return false;
                }

                Thread.Sleep(15000);
            }
        }

        public bool IsPrimary()
        {
            return this.WritesAllowed;
        }

        public Action<bool, bool> StartService;

        private Action OnStart = null;
        private Action OnStop = null;

        /// <summary>
        /// Called when [become primary].
        /// </summary>
        public void OnBecomePrimary()
        {
            long lastTx = this.Factory.GetLastXId();

            Trace.TraceInformation(" I am primary (PID={0}) LastTx={1}", Process.GetCurrentProcess().Id, lastTx);
            LockListForRW.XidProvider = new UIdProvider(lastTx);

            RingMasterThreadPool.Instance.QueueUserWorkItem(ign =>
            {
                this._hasRoot.WaitOne();

                this.WritesAllowed = true;

                this.secondarypreprocessor.CancelAnyOngoingActivity();

                try
                {
                    this.secondarypreprocessor.SetupCommodityTree();
                    this.pseudoNodes.SetupTreeStructure();

                    if (!s_dontStartPseudoNodes)
                    {
                        this.secondarypreprocessor.SetupCommandTree();
                    }
                }
                catch (Exception e)
                {
                    RingMasterServerInstrumentation.Instance.OnUnexpectedException("RingMasterBackendCore.SetupCommandTree", e);
                    Trace.TraceWarning("RingMasterBackendCore: Command Tree initialization failed. This instance will continue without it. Exception was: {0}", e);
                }

                this.OnAfterBecomePrimary?.Invoke();

                this.StartService?.Invoke(true, true);
            });
        }

        public void SetRuntimeMembersetFunction(Func<ClusterMember[]> getRuntimeMembersetFunction)
        {
            this.pseudoNodes.SetRuntimeMembersetFunction(getRuntimeMembersetFunction);
        }

        private Timer timerTermination = null;

        /// <summary>
        /// Called when [primary status lost].
        /// </summary>
        public void OnPrimaryStatusLost()
        {
            Trace.TraceInformation("Primary status lost. ProcessId={0}", Process.GetCurrentProcess().Id);
            this.WritesAllowed = false;

            // schedule an abrupt death within the following 30 seconds.
            timerTermination = new Timer((o) =>
            {
                Trace.TraceInformation("Primary Status lost and no termination happened on time. Killing the process.");
                timerTermination = null;
                Process.GetCurrentProcess().Kill();
                Environment.Exit(0);
            }, null, 30000, Timeout.Infinite);

            // The Stop needs to be done asynchronously so the State Machine can be deactivated (we are in a thread from the SM)
            ThreadPool.QueueUserWorkItem(_ =>
            {
                OnAfterPrimaryStatusLost?.Invoke();

                Trace.TraceInformation("Primary Status lost. Restarting the backend.");
                this.Stop();
                Thread.Sleep(5000);
                this.Start();

                Timer t = this.timerTermination;

                if (t != null)
                {
                    this.timerTermination = null;
                    t.Change(Timeout.Infinite, Timeout.Infinite);
                }
            });
        }

        /// <summary>
        /// Indicates if none of the given path is in the blackList
        /// </summary>
        /// <param name="paths">The paths.</param>
        /// <returns><c>true</c> if none of the paths is blacklisted, <c>false</c> otherwise.</returns>
        private bool NoneInBlackList(IEnumerable<string> paths)
        {
            if (paths == null || blacklist == null)
            {
                return false;
            }

            foreach (string path in paths)
            {
                bool wasExact;
                bool contains = ContainsSubPath(path, blacklist, out wasExact);
                Trace.TraceInformation("- is {0} in {1}? --> {2}", path, "blackList", contains);

                if (contains)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Determines whether this path lockdown can be ignored
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns><c>true</c> if this path lockdown can be ignored; otherwise, <c>false</c>.</returns>
        private bool CanLockDownPathBeIgnored(string path)
        {
            bool ignore = false;
            bool wasExact;
            if (ignoreList != null && ContainsSubPath(path, ignoreList, out wasExact))
            {
                ignore = true;
            }
            Trace.TraceInformation("- is {0} in {1}? --> {2}", path, "ignore list", ignore);
            return ignore;
        }

        /// <summary>
        /// indicates if the given path is locked down
        /// </summary>
        /// <param name="path">path that might be locked down</param>
        /// <returns>true if the path is locked down</returns>
        public bool IsPathLockedDown(string path)
        {
            if (this.lockDownPaths.IsEmpty())
            {
                return false;
            }

            while (!String.IsNullOrEmpty(path))
            {
                if (this.lockDownPaths.Contains(path))
                {
                    RingMasterEventSource.Log.PathIsLockedDown(path);
                    return true;
                }

                int i = path.LastIndexOf('/');

                if (i < 0)
                {
                    break;
                }

                if (i == 0 && path.Length > 1)
                {
                    path = "/";
                    continue;
                }

                path = path.Substring(0, i);
            }

            return false;
        }

        /// <summary>
        /// Called when the replication layer decides it is unsafe to allow any change on the given paths
        /// This method takes the list of paths the replication layer found part of the faulty transaction, and also the list of paths that actually failed in the operation (those may be left in a random state)
        /// It also indicates if the replication layer things the replication of commands need to be frozen, so no futher replications can be done or executed.
        /// This method takes that data, and decides if, even though replication layer doesn't demand to be frozen, any of the failed paths is critical, and therefore, the freeze is needed.
        /// The second thing this method does is to see what paths from the affected paths need to be locked down (so no API can access those).. plus, emits events for that.
        /// Thirdly, if the situation grants it, this method will open the RO ports, so we are at least open for RO operations if there is a replication freeze.
        /// </summary>
        /// <param name="pathsToLockDown">The paths to lock down.</param>
        /// <param name="pathsFailed">The paths failed. A null here means all paths to lock down failed</param>
        /// <param name="poisonPillPrevented">if true, the lower layer is indicating the poison pill was fully prevented</param>
        /// <param name="replicationIsInReadOnly">if true, this means the replication layer is not in ReadOnly</param>
        public void OnPathsLockdownRequested(IEnumerable<string> pathsToLockDown, IEnumerable<string> pathsFailed, bool poisonPillPrevented, ref bool replicationIsInReadOnly)
        {
            RingMasterEventSource.Log.OnPathsLockdownRequested(poisonPillPrevented, replicationIsInReadOnly);
            lock (lockDownPathsChangeLock)
            {
                if (!replicationIsInReadOnly)
                {
                    HashSet<string> newSet = new HashSet<string>();

                    // add all previously known locked paths, if we have any
                    foreach (string p in this.lockDownPaths.GetPaths())
                    {
                        newSet.Add(p);
                    }

                    if (pathsToLockDown != null)
                    {
                        foreach (string s in pathsToLockDown)
                        {
                            // skip the paths that are ignorable
                            if (pathsFailed == null || !CanLockDownPathBeIgnored(s))
                            {
                                newSet.Add(s);
                            }
                        }
                    }

                    if (pathsFailed != null)
                    {
                        foreach (string s in pathsFailed)
                        {
                            if (!CanLockDownPathBeIgnored(s))
                            {
                                newSet.Add(s);
                            }
                        }
                    }

                    RemoveRedundantPaths(newSet);

                    // update the known lock down paths
                    // here, not we cannot replace lockDownPaths, since that collection is already
                    // in use for the currently opened sessions. We instead want to MODIFY that collection
                    this.lockDownPaths.ReplacePaths(newSet);

                    foreach (string path in newSet)
                    {
                        RingMasterEventSource.Log.OnPathsLockdownRequested_FinalSet(path);
                    }

                    if (!NoneInBlackList(newSet))
                    {
                        replicationIsInReadOnly = true;
                    }
                }

                RingMasterServerInstrumentation.Instance.OnLockDownFound(this.lockDownPaths.GetPaths(), replicationIsInReadOnly);

                if (replicationIsInReadOnly)
                {
                    RingMasterEventSource.Log.OnPathsLockdownRequested_FullLockdown();

                    // disable write ability for sure
                    this.WritesAllowed = false;
                    this.IsInFullLockDown = true;

                    this.startMainEndpointOnSecondary = true;
                    this.startExtraEndpointOnSecondary = true;

                    if (this.Root != null)
                    {
                        // if this is a secondary already loaded, just open the endpoints now
                        OpenEndpointsOnSecondaryIfNeeded();
                    }
                    this.lockDownPaths.IgnoreAllpaths = this.lockDownPaths.IgnoreAllpaths | poisonPillPrevented;
                }
                else
                {
                    this.IsInFullLockDown = false;
                    foreach (string s in this.lockDownPaths.GetPaths())
                    {
                        RingMasterEventSource.Log.OnPathsLockdownRequested_PartialLockdown(s);
                    }
                    this.lockDownPaths.IgnoreAllpaths = false;
                }
            }
        }

        /// <summary>
        /// Determines whether the path has a prefix in the given hash (and ,if orExactMatch is true, has an exact match)
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="paths">The paths.</param>
        /// <param name="wasExact">if set to <c>true</c> the match was an exact match, otherwise, path is a longer path than one in the paths hash</param>
        /// <returns><c>true</c> if the path has a prefix in the given hash (and ,if orExactMatch is true, has an exact match); otherwise, <c>false</c>.</returns>
        private static bool ContainsSubPath(string path, HashSet<string> paths, out bool wasExactMatch)
        {
            wasExactMatch = false;
            foreach (string p in paths)
            {
                string other = p;

                if ((other == path))
                {
                    wasExactMatch = true;
                    return true;
                }

                if (!other.EndsWith("/"))
                {
                    other = other + "/";
                }

                if (!path.EndsWith("/"))
                {
                    path = path + "/";
                }

                if (path.StartsWith(other))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Removes the redundant paths from the hashset. RemoveRedundantPaths({'/foo/bar/toe','/foo/bar'}) = { '/foo/bar' }
        /// </summary>
        /// <param name="paths">The paths, potentially with redundant deeper paths on it</param>
        private static void RemoveRedundantPaths(HashSet<string> paths)
        {
            List<string> redundant = new List<string>();

            foreach (string path in paths)
            {
                bool wasExact;

                if (ContainsSubPath(path, paths, out wasExact) && !wasExact)
                {
                    redundant.Add(path);
                }
            }

            foreach (string path in redundant)
            {
                paths.Remove(path);
            }
        }

        /// <summary>
        /// Determines whether this instance [can become primary].
        /// </summary>
        /// <returns><c>true</c> if this instance can become primary; otherwise, <c>false</c>.</returns>
        public bool CanBecomePrimary()
        {
            RecordPromotionQuery();

            return true;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RingMasterBackendCore"/> class.
        /// </summary>
        /// <param name="factory">The factory.</param>
        /// <param name="auditConsumer">Interface to an object that can consume audit events generated by this class</param>
        /// <param name="sslWrappingForRMLoopbackConnect">SSL wrapper to connect to RM service</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
        public RingMasterBackendCore(IPersistedDataFactory<Node> factory, IRingMasterAudit auditConsumer = null, SslWrapping sslWrappingForRMLoopbackConnect = null)
        {
            ThreadPool.SetMinThreads(512, 512);

            this.auditConsumer = auditConsumer;
            this.rmCommands = InstanitateRMCommands();


            this.Factory = factory;
            this.EphemeralFactory = new EphemeralFactory();
            this.pseudoNodes = new PseudoNodes(this, GetSetting);

            this.startMainEndpointOnSecondary = GetSetting("RingMaster.StartMainEndpointOnSecondary", bool.TryParse, false);
            this.startExtraEndpointOnSecondary = GetSetting("RingMaster.StartExtraEndpointsOnSecondary", bool.TryParse, false);

            this.blacklist = GetSetting("RingMaster.Paths.NotAllowedToFail", TryParseStringIntoHash, new HashSet<string>());
            this.ignoreList = GetSetting("RingMaster.Paths.IgnoreForLockDown", TryParseStringIntoHash, new HashSet<string>());

            this.limits = new RingMasterLimits
            {
                MaxNodeNameLength = GetSetting<uint>("RingMasterLimits.MaxNodeNameLength", uint.TryParse, 0),
                MaxNodePathLength = GetSetting<uint>("RingMasterLimits.MaxNodePathLength", uint.TryParse, 0),
                MaxNodeDataSize = GetSetting<uint>("RingMasterLimits.MaxNodeDataSize", uint.TryParse, 0),
                MaxAclsPerNode = GetSetting<uint>("RingMasterLimits.MaxAclsPerNode", uint.TryParse, 0),
                MaxAclIdentiferLength = GetSetting<uint>("RingMasterLimits.MaxAclIdentiferLength", uint.TryParse, 0),
                MaxGetChildrenEnumerationCount = GetSetting<int>("RingMasterLimits.MaxGetChildrenEnumerationCount", int.TryParse, 10000),
                MinSortedDictionaryThreshold = GetSetting<int>("RingMasterLimits.MinSortedDictionaryThreshold", int.TryParse, 40000),
                MaxSortedDictionaryThreshold = GetSetting<int>("RingMasterLimits.MaxSortedDictionaryThreshold", int.TryParse, 50000),
            };

            Node.MinSortedDictionaryThreshold = this.limits.MinSortedDictionaryThreshold;
            Node.MaxSortedDictionaryThreshold = this.limits.MaxSortedDictionaryThreshold;

            RingMasterEventSource.Log.RingMasterNodeChildrenLimits(this.limits.MaxGetChildrenEnumerationCount, Node.MinSortedDictionaryThreshold, Node.MaxSortedDictionaryThreshold);

            int multiples = GetSetting("RingMaster.SecondaryPreprocessor.RunOnMultiplesOf", int.TryParse, 0);

            this.secondarypreprocessor = new SecondaryPreprocessor(this, multiples, MeasureTree);
            this.sslWrappingForRMLoopbackConnect = sslWrappingForRMLoopbackConnect;
        }

        /// <summary>
        /// Tries to parse a string into a hash of strings.
        /// </summary>
        /// <param name="setting">The input string with a comma or semicomma separated list of strings.</param>
        /// <param name="value">The hash of strings.</param>
        /// <returns><c>true</c> if the parsing was successful, <c>false</c> otherwise.</returns>
        private static bool TryParseStringIntoHash(string setting, out HashSet<string> value)
        {
            try
            {
                value = new HashSet<string>();

                if (!String.IsNullOrWhiteSpace(setting))
                {
                    string[] values = setting.Split(new char[] { ';', ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);

                    foreach (string v in values)
                    {
                        value.Add(v);
                    }
                }

                return true;
            }
            catch (Exception)
            {
                value = null;
                return false;
            }
        }

        /// <summary>
        /// Measures the full tree.
        /// </summary>
        /// <param name="txTime">The tx time that triggered this.</param>
        /// <param name="txId">The tx identifier that triggered this.</param>
        protected void MeasureTree(long txTime, long txId)
        {
            // see if this replica is the secondary with smaller Id in the clusterset.
            try
            {
                Trace.TraceInformation("MeasureTree invoked at txtime={0} txid={1}?", MutableStat.ConvertTime(txTime).ToString("o"), txId);

                List<string> members = new List<string>();

                if (this.IsPrimary())
                {
                    return;
                }

                Dictionary<string, HealthDefinition> dict = this.Factory.GetHealth();

                foreach (KeyValuePair<string, HealthDefinition> elem in dict)
                {
                    if (!elem.Value.IsPrimary)
                    {
                        members.Add(elem.Key);
                    }
                }

                if (members.Count == 0)
                {
                    return;
                }

                members.Sort();

                Trace.TraceInformation("Factory.Name={0} members=[{1}]", this.Factory.Name, string.Join(",", members));

                if (!String.Equals(this.Factory.Name, members[0]))
                {
                    Trace.TraceInformation("skipping measurement because we are not the right instance to measure");

                    return;
                }

                Trace.TraceInformation("proceeding to measuring now!");

                // now, we know we are THE replica that needs to measure the tree... do it now.

                Stopwatch sw = Stopwatch.StartNew();

                Dictionary<string, object> results = MeasureFullTree(PlatformHelper.ProcessorCount, MaxTimeForMeasurementInMillis);

                sw.Stop();

                foreach (KeyValuePair<string, object> line in results)
                {
                    string text;
                    Exception e = line.Value as Exception;
                    if (e != null)
                    {
                        text = e.ToString();
                        RingMasterServerInstrumentation.Instance.OnMeasurement(-1, line.Key, txId);
                    }
                    else
                    {
                        ulong metrics = (ulong)line.Value;
                        text = string.Format("{0:X}", metrics);
                        RingMasterServerInstrumentation.Instance.OnMeasurement((long)metrics, line.Key, txId);
                    }

                    Trace.TraceInformation("Metrics for {0} is {1} ({2} ms)", line.Key, text, sw.ElapsedMilliseconds);
                }

                RingMasterServerInstrumentation.Instance.OnMeasurementCompleted(sw.ElapsedMilliseconds, txId);
            }
            catch (Exception ex)
            {
                Trace.TraceWarning("tree measurement failed: {0}", ex);
            }
        }

        /// <summary>
        /// measures the whole tree and returns a dictionary of childOfRootName->measurement.
        /// measurement may be a ulong, or an Exception
        /// </summary>
        /// <param name="nthreads">the number of threads to use for the measurement</param>
        /// <param name="maxMeasurementTimeInMillis">max time to complete the measurement</param>
        /// <returns>the dictionary of measurements, where the key is the name of a node child of root, and the value is a measurement (ulong) or an exception</returns>
        internal Dictionary<string, object> MeasureFullTree(int nthreads, int maxMeasurementTimeInMillis)
        {
            ExecutionQueue q = new ExecutionQueue(nthreads);
            Dictionary<string, object> results = new Dictionary<string, object>();

            IEnumerable<string> children = this.Root.RetrieveChildren();

            long sessionId = Interlocked.Increment(ref measureSessionId);

            HelperTypes.CountdownEvent ev = new HelperTypes.CountdownEvent(1);

            foreach (string child in children)
            {
                string child_i = child;
                Trace.TraceInformation("Metrics for child: {0} scheduled", child_i);
                ev.Add(1);

                q.Enqueue(_ =>
                {
                    object line;
                    int numnodes = 0;
                    try
                    {
                        ulong metrics = this.Measure(ref numnodes, sessionId, this.Root.TryGetChild(child_i, false));
                        line = metrics;
                    }
                    catch (Exception e)
                    {
                        line = e;
                    }

                    lock (results)
                    {
                        results.Add(child_i, line);
                    }
                    ev.DecrementAndSetIfZero();
                }, child);
            }

            ev.DecrementAndSetIfZero();

            if (!ev.WaitOne(maxMeasurementTimeInMillis))
            {
                measureSessionId++;
            }

            q.Drain(ExecutionQueue.DrainMode.DisallowAllFurtherEnqueues);

            return results;
        }

        /// <summary>
        /// measures the node in depth, computing a HashCode of the whole subtree
        /// </summary>
        /// <param name="node">the node to measure</param>
        /// <param name="numnodes"> the total number of nodes explored so far</param>
        /// <param name="measureSessionId">the sessionId which started this measurement</param>
        /// <returns>the resulting measurement to xor with</returns>
        private ulong Measure(ref int numnodes, long measureSessionId, Node node)
        {
            numnodes++;

            if (numnodes % TraceMeasuredNodesInMultiplesOf == 1)
            {
                Trace.TraceInformation("Metrics from thread {0} -> {1} nodes done ({2})", Thread.CurrentThread.ManagedThreadId, numnodes, Node.BuildPath(node.Persisted));
            }

            if (this.WritesAllowed && !this.CanMeasure)
            {
                // cancel, as we just became primary and we are not forced on the measurement
                throw new InvalidOperationException("became primary");
            }

            if (this.measureSessionId != measureSessionId)
            {
                // cancel, as we just found out our sessionId is not the last one
                throw new InvalidOperationException("measureSessionId chancged");
            }

            if (node == null || node.Persisted.IsEphemeral)
            {
                return 0;
            }

            ulong measurement = Measure(node.Persisted);

            if (node.ChildrenMapping != null)
            {
                ulong childrenM = 0;
                IEnumerable<string> children = node.RetrieveChildren();

                foreach (string child in children)
                {
                    Node childNode = node.TryGetChild(child, false);
                    childrenM ^= (ulong)childNode.Persisted.Id.GetHashCode();
                    measurement ^= Measure(ref numnodes, measureSessionId, childNode);
                }

                measurement ^= childrenM;
            }

            return measurement;
        }

        /// <summary>
        /// measures a single node
        /// </summary>
        /// <param name="pd">the node to measure</param>
        /// <returns>the hashcode for the node, and all its members</returns>
        private ulong Measure(IPersistedData pd)
        {
            ulong metric = 0;

            metric ^= (ulong)pd.Id.GetHashCode();

            metric ^= (ulong)pd.Name.GetHashCode();

            metric ^= (ulong)pd.Stat.GetHashCode();

            if (pd.Data != null)
            {
                ulong hc = (ulong)EqualityHelper.MeasureByteArrayWithSampling(pd.Data, MaxSamplesForDataHashSet);

                metric ^= (ulong)hc;
            }

            if (pd.Acl != null)
            {
                foreach (Acl acl in pd.Acl)
                {
                    metric ^= (ulong)acl.GetHashCode();
                }
            }

            return metric;
        }

        /// <summary>
        /// instantiates a new RMCommand object for this backend
        /// </summary>
        /// <returns></returns>
        protected virtual RMCommands InstanitateRMCommands()
        {
            return new RMCommands(this);
        }

        /// <summary>
        /// Starts this instance.
        /// </summary>
        public void Start()
        {
            if (this.Factory == null)
            {
                Trace.TraceError("RingMasterBackendCore.Start: Factory cannot be null");
                throw new InvalidOperationException("Factory cannot be null when calling Start()");
            }

            Trace.TraceInformation("Start() was called");

            long lastXId;
            this.Factory.Activate(this, this);
            Trace.TraceInformation("Start() will call LoadTree");
            this.Root = this.Factory.LoadTree(out lastXId);
            Trace.TraceInformation("Start() should have a root: {0}", (this.Root != null));

            Trace.TraceInformation("RingMasterBackendCore.Start: Last TransactionId={0}", lastXId);

            ManualResetEventPool.InstancePool.Set(this._hasRoot);

            OpenEndpointsOnSecondaryIfNeeded();

            if (OnStart != null)
            {
                OnStart();
            }
        }

        internal void StartPseudoNodes(Func<AbstractRingMaster> getRingMaster)
        {
            if (!s_dontStartPseudoNodes)
            {
                Trace.TraceInformation("RingMasterBackendCore.Start: Starting pseudonodes");
                pseudoNodes.SetupPseudoNodes(getRingMaster, this.rmCommands.syncObject);
            }
        }

        internal void StartPseudoNodes(int port, SslWrapping ssl)
        {
            if (!s_dontStartPseudoNodes)
            {
                Trace.TraceInformation("RingMasterBackendCore.Start: Starting pseudonodes");
                pseudoNodes.SetupPseudoNodes(port, this.sslWrappingForRMLoopbackConnect != null ? this.sslWrappingForRMLoopbackConnect : ssl, this.rmCommands.syncObject);
            }
        }

        internal void StopPseudoNodes()
        {
            if (!s_dontStartPseudoNodes)
            {
                Trace.TraceInformation("RingMasterBackendCore.Stop: Stopping pseudonodes");
                pseudoNodes.Stop();
            }
        }

        /// <summary>
        /// Open the endpoints on the secondary, if such thing is needed
        /// </summary>
        internal void OpenEndpointsOnSecondaryIfNeeded()
        {
            // initialize the txId to whatever we have right now.
            if (LockListForRW.XidProvider == null)
            {
                LockListForRW.XidProvider = new FixedUIdProvider(1);
            }

            if (this.startMainEndpointOnSecondary || this.startExtraEndpointOnSecondary)
            {
                this.pseudoNodes.CreateLockDownNodeIfNeeded();

                StartService(this.startMainEndpointOnSecondary, this.startExtraEndpointOnSecondary);
            }
        }

        public Action StopService;

        /// <summary>
        /// Stops this instance.
        /// </summary>
        public void Stop()
        {
            if (OnStop != null)
            {
                OnStop();
            }

            if (StopService != null)
            {
                StopService();
            }
            if (this.Factory != null)
            {
                this.Factory.Deactivate();
            }
        }

        /// <summary>
        /// The root
        /// </summary>
        protected Node Root;

        /// <summary>
        /// Gets or sets the factory
        /// </summary>
        internal IPersistedDataFactory<Node> Factory { get; set; }

        /// <summary>
        /// Gets or sets the ephemeral factory
        /// </summary>
        internal IPersistedDataFactory<Node> EphemeralFactory;

        /// <summary>
        /// Gets or sets the ephemeral mount point factory.
        /// </summary>
        /// <value>The ephemeral mount point factory.</value>
        public Func<string, IPersistedDataFactory<Node>> EphemeralMountPointFactory
        {
            get;set;
        }

        /// <summary>
        /// Processes the session initialization.
        /// </summary>
        /// <param name="call">The call.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse.</returns>
        /// <exception cref="System.Exception">
        /// We shouldnt know about this uninitialized session yet.
        /// or
        /// First request from an unitialized session should be RequestInit.
        /// </exception>
        public RequestResponse ProcessSessionInitialization(RequestCall call, ClientSession session)
        {
            if (call == null)
            {
                throw new ArgumentNullException("call");
            }

            if (session == null)
            {
                throw new ArgumentNullException("session");
            }

            ulong callId = call.CallId;

            RequestInit initR = call.Request as RequestInit;
            if (initR != null)
            {
                return ProcessSessionInitialization(session, initR, callId);
            }

            Trace.TraceWarning(
                "[SessionId={0}] First request should be RequestInit it was {1}",
                session.SessionId,
                call.Request);

            throw new InvalidOperationException("First request from an unitialized session should be RequestInit.");
        }

        /// <summary>
        /// processes a message configuring the session
        /// </summary>
        /// <param name="session"></param>
        /// <param name="initRequest"></param>
        /// <param name="callId"></param>
        /// <returns></returns>
        private RequestResponse ProcessSessionInitialization(ClientSession session, RequestInit initRequest, ulong callId)
        {
            string passwd;

            RmAssert.IsTrue(session != null, "session cannot be null");

            if (!String.IsNullOrEmpty(initRequest.SessionPwd))
            {
                passwd = initRequest.SessionPwd;
            }
            else
            {
                passwd = Guid.NewGuid().ToString();
            }

            session.Redirection = initRequest.Redirection;

            if (initRequest.Auth != null && initRequest.Auth.IsSuperSession)
            {
                session.ROInterfaceRequiresLocks = true;
            }
            else
            {
                session.ROInterfaceRequiresLocks = initRequest.RoInterfaceRequiresLocks;
            }

            RingMasterEventSource.Log.InitializeSession(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity);
            this.auditConsumer?.OnInitializeSession(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity);

            session.SetClientDigest(String.Empty);
            session.State = ClientSession.SessionState.Initialized;
            return new RequestResponse()
            {
                CallId = callId,
                ResultCode = (int)Code.Ok,
                Stat = null,
                Content = new string[] { "" + session.SessionId, passwd }
            };
        }

        /// <summary>
        /// Processes the message.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="onCompletion">completion routine</param>
        /// <exception cref="System.InvalidOperationException">RequestInit can be issued only once in a session lifetime</exception>
        public void ProcessMessage(IRingMasterBackendRequest req, ClientSession session, Action<RequestResponse> onCompletion)
        {
            //session.RenewTimer();
            Task taskReplication;
            RequestResponse resp = ProcessMessage(req, session, out taskReplication);

            var duration = Stopwatch.StartNew();

            if (taskReplication != null)
            {
                taskReplication.ContinueWith(
                    task =>
                    {
                        if (!task.IsFaulted && !task.IsCanceled)
                        {
                            RingMasterServerInstrumentation.Instance.OnResponseWaitForReplication(duration.Elapsed);
                            onCompletion?.Invoke(resp);
                        }
                        else
                        {
                            Trace.TraceError("ProcessMessage Failed: " + task.Exception);
                        }
                    });
            }
        }

        private RequestResponse ProcessMessage(IRingMasterBackendRequest request, ClientSession session)
        {
            Task taskReplication;
            return ProcessMessage(request, session, out taskReplication);
        }

        /// <summary>
        /// Processes a request from a session.
        /// </summary>
        /// <param name="request">The request.</param>
        /// <param name="session">The session this request comes from.</param>
        /// <param name="taskReplication">async task to indicate the replication completion on output</param>
        /// <returns>RequestResponse.</returns>
        /// <exception cref="System.TimeoutException">retriable exception exceeded maximum time alloted</exception>
        /// <exception cref="System.InvalidOperationException">Session  + session.SessionId +  is in a state calls are not allowed anymore:  + session.State</exception>
        private RequestResponse ProcessMessage(IRingMasterBackendRequest request, ClientSession session, out Task taskReplication)
        {
            RequestResponse response;

            taskReplication = null;

            if (!this.Factory.IsActive)
            {
                // If the factory is not active, we need to cancel the request now.
                RingMasterEventSource.Log.ProcessMessage_PersistedDataFactoryNotActive(session.SessionId, request.Uid);
                return OperationCancelled(request, session);
            }

            response = this.ValidateRequest(request, session);

            if (response != null)
            {
                RingMasterEventSource.Log.ProcessMessage_RequestValidationFailed(session.SessionId, request.Uid);
                return response;
            }

            SemaphoreRepository.ILockToken releaseToken = null;

            session.BeginInvocation();

            CancellationTokenSource cancelRequest = null;

            Stopwatch timer = Stopwatch.StartNew();
            try
            {
                cancelRequest = new CancellationTokenSource();
                var cancelRequestToken = cancelRequest.Token;

                // If no one cancel this task, it will crash the current primary replica. This is to detect any
                // request may get stuck as a temporary fix for the server timeout bug. Before returning the response
                // the task must be cancelled.
                Task.Run(
                    async () =>
                    {
                        try
                        {
                            await Task.Delay(30 * 1000, cancelRequestToken);

                            cancelRequestToken.ThrowIfCancellationRequested();

                            var req = request.WrappedRequest;
                            Trace.TraceError($"Overdue request: type={req.RequestType} timestream={req.TimeStreamId} path={req.Path}");

                            Environment.FailFast("Request process duration is greater than 30 seconds");
                        }
                        catch (TaskCanceledException)
                        {
                        }
                    },
                    cancelRequestToken);

                if (request.ExecutionQueueId != Guid.Empty)
                {
                    if (!SemaphoreRepository.Instance.FindAndTryAcquire(request.ExecutionQueueId, request.ExecutionQueueTimeoutMillis, out releaseToken))
                    {
                        RingMasterEventSource.Log.ProcessMessage_FailedToAcquireExecutionQueue(session.SessionId, request.Uid, request.ExecutionQueueId.ToString());

                        cancelRequest.Cancel();
                        return new RequestResponse() { ResponsePath = request.Path, Content = null, Stat = null, ResultCode = (int)Code.Waitqueuetimeoutonserver };
                    }
                }

                int retryCount = 0;

                do
                {
                    switch (session.State)
                    {
                        case ClientSession.SessionState.Terminating:
                            // If the session is terminating, we can just let the operation
                            // go for as long as it needs to, as we really need to execute this.
                            break;
                        case ClientSession.SessionState.Initialized:
                            // Under no circumstances we can take longer than MaxRetryOperation time
                            // for a regular invocation.
                            if (timer.ElapsedMilliseconds > s_maxRetryOperationMillis)
                            {
                                RingMasterEventSource.Log.ProcessMessage_Timeout(session.SessionId, request.Uid, timer.ElapsedMilliseconds);

                                cancelRequest.Cancel();
                                Trace.TraceError($"ServerOperationTimeout Thread-{Thread.CurrentThread.ManagedThreadId}");
                                return new RequestResponse() { ResponsePath = request.Path, ResultCode = (int)Code.ServerOperationTimeout };
                            }

                            break;
                        default:
                            throw new InvalidOperationException("Session " + session.SessionId + " is in a state calls are not allowed anymore: " + session.State);
                    }

                    response = this.BareProcessMessage(request, session, ref timer, ref retryCount, out taskReplication);
                } while (response == null);

                cancelRequest.Cancel();
                return response;
            }
            finally
            {
                cancelRequest?.Dispose();

                if (releaseToken != null)
                {
                    SemaphoreRepository.Instance.Release(releaseToken);
                }

                session.EndInvocation();
            }
        }

        private RequestResponse BareProcessMessage(IRingMasterBackendRequest request, ClientSession session, ref Stopwatch timer, ref int retryCount, out Task taskReplication)
        {
            RequestResponse response = null;

            ILockListTransaction lockList = session.GetOrCreateLockList(request, lockDownPaths);

            // otherwise, go for it.
            try
            {
                taskReplication = null;
                response = this.DispatchRequest(request, session, lockList);

                Debug.Assert(response != null, $"{nameof(DispatchRequest)} should not return null, or the request will run forever");
                timer.Stop();

                // If writes are allowed for this session, then log information about each completed message.
                // the information is only logged to EventSource so it will not affect performance.
                if (session.writesAllowed)
                {
                    RingMasterEventSource.Log.ProcessMessageSucceeded(session.SessionId, request.Uid, lockList.TxId, (int)request.RequestType, request.Path, timer.ElapsedMilliseconds);
                }
            }
            catch (InvalidAclException ex)
            {
                RingMasterServerInstrumentation.Instance.OnAuthFailed(ex);
                lockList.MarkForAbort();
                response = new RequestResponse() { ResultCode = (int)Code.Authfailed, Stat = null, Content = null };
            }
            catch (RetriableOperationException rex)
            {
                RingMasterEventSource.Log.ProcessMessageFailed(session.SessionId, request.Uid, lockList.TxId, retryCount, timer.ElapsedMilliseconds, rex.ToString());
                lockList.MarkForAbort();
                retryCount++;
            }
            catch (Exception ex)
            {
                RingMasterEventSource.Log.ProcessMessageFailed(session.SessionId, request.Uid, lockList.TxId, retryCount, timer.ElapsedMilliseconds, ex.ToString());
                lockList.MarkForAbort();

                RingMasterServerInstrumentation.Instance.OnUnexpectedException("RingMasterBackend.ProcessMessage", ex);

                Debug.Assert(false, string.Format("Unexpected exception {0}", ex));

                // no need to trace here. caller will.
                return new RequestResponse() { ResponsePath = request.Path, Content = null, Stat = null, ResultCode = (int)Code.Systemerror };
            }
            finally
            {
                session.IfNeededUnlockAllAndCloseChanges(lockList, out taskReplication);
            }

            return response;
        }

        /// <summary>
        /// Validates the request for the session and returns a response if the request is not valid.
        /// </summary>
        /// <param name="req"></param>
        /// <param name="session"></param>
        /// <returns></returns>
        private RequestResponse ValidateRequest(IRingMasterBackendRequest req, ClientSession session)
        {
            if (req == null)
            {
                return this.BadApi(req, session);
            }

            if (req.RequestType == RingMasterRequestType.Init)
            {
                throw new InvalidOperationException("RequestInit can be issued only once in a session lifetime");
            }

            // shortcut this method if we know we are good
            if (this.WritesAllowed && session.writesAllowed && session.ROInterfaceRequiresLocks)
            {
                return null;
            }

            bool isReadonly = false;
            bool isMulti = false;
            bool hasWatcher = false;

            bool considerCreateEphemeralAsReadOnly = (this.IsInFullLockDown && session.Auth.IsSuperSession);

            // Only if we are in lockdown we may need to go in depth.
            bool allowDeepAnalysis = !this.WritesAllowed;

            isReadonly = IsReadOnlyRequest(req, considerCreateEphemeralAsReadOnly, allowDeepAnalysis, out isMulti, out hasWatcher);

            // root can go through and try commands even during lockdown
            if (!isReadonly && (!this.WritesAllowed || !session.writesAllowed))
            {
                // if this is a single command, even if we are not supposed to do writes, let it through as a read-only operation
                if (rmCommands.IsCommand(req))
                {
                    isReadonly = true;
                }
                else
                {
                    return InLockDown(req, session);
                }
            }

            // for RW operations, we may want to disallow them
            if (!isReadonly)
            {
                if (!this.WritesAllowed)
                {
                    return BadApi(req, session);
                }

                if (!session.writesAllowed)
                {
                    return BadAuth(req, session);
                }
            }

            // if the operation has a watcher and the session is lock-free, we don't want to allow it either.
            if (isReadonly && hasWatcher && !session.ROInterfaceRequiresLocks)
            {
                return BadApi(req, session);
            }

            return null;
        }

        private RequestResponse DispatchRequest(IRingMasterBackendRequest req, ClientSession session, ILockListTransaction lockList)
        {
            switch (req.RequestType)
            {
                case RingMasterRequestType.SetAuth:
                    return this.SetAuth((RequestSetAuth)req, session);

                case RingMasterRequestType.Create:
                    return this.Create((RequestCreate)req, session, lockList);

                case RingMasterRequestType.Multi:
                    return this.Multi((RequestMulti)req, session, lockList);

                case RingMasterRequestType.Batch:
                    return this.Batch((RequestBatch)req, session);

                case RingMasterRequestType.Delete:
                    return this.Delete((RequestDelete)req, session, lockList);

                case RingMasterRequestType.Move:
                    return this.Move((RequestMove)req, session, lockList);

                case RingMasterRequestType.Check:
                    return this.Check((RequestCheck)req, lockList);

                case RingMasterRequestType.SetAcl:
                    return this.SetAcl((RequestSetAcl)req, session, lockList);

                case RingMasterRequestType.SetData:
                    return this.SetData((RequestSetData)req, session, lockList);

                case RingMasterRequestType.Exists:
                    return this.Exists((RequestExists)req, session, lockList);

                case RingMasterRequestType.GetAcl:
                    return this.GetAcl((RequestGetAcl)req, lockList);

                case RingMasterRequestType.GetChildren:
                    return this.GetChildren((RequestGetChildren)req, session, lockList);

                case RingMasterRequestType.GetData:
                    return this.GetData((RequestGetData)req, session, lockList);

                case RingMasterRequestType.Sync:
                    return this.Sync((RequestSync)req, lockList);

                case RingMasterRequestType.InternalRun:
                    return this.InternalRun((RequestInternalRun)req, lockList);

                default:
                    break;
            }

            Trace.TraceWarning("Bad RequestType found: {0}", req.RequestType);
            return new RequestResponse() { ResultCode = (int)Code.Apierror, Stat = null, Content = null };
        }

        /// <summary>
        /// Executes within a transaction an internal action.
        /// </summary>
        /// <param name="req">The request modeling the internal action.</param>
        /// <param name="lockList">The lock list to use.</param>
        /// <returns>RequestResponse of the action.</returns>
        private RequestResponse InternalRun(RequestInternalRun req, ILockListTransaction lockList)
        {
            bool abort = true;

            try
            {
                RequestResponse resp = req.ActionToRun(req, lockList);
                abort = false;
                return resp;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Returns true if the request is read only for the tree. It also indicates some metadata.
        /// NOTE: Multi is considered read-write due to its potential.
        /// </summary>
        /// <param name="req">the request</param>
        /// <param name="isMulti">indicates if the request is multi</param>
        /// <param name="hasWatcher">indicates if the request has watchers</param>
        /// <returns>true if the request is read-only</returns>
        private bool IsReadOnlyRequest(IRingMasterBackendRequest req, out bool isMulti, out bool hasWatcher)
        {
            return IsReadOnlyRequest(req, false, false, out isMulti, out hasWatcher);
        }

        /// <summary>
        /// Returns true if the request is read only for the tree. It also indicates some metadata.
        /// Multi and Batch are explored in depth if goInDepth is true.
        /// </summary>
        /// <param name="req">the request</param>
        /// <param name="considerCreateEphemeralAsReadOnly">if true, create for ephemerals will be treated as readonly</param>
        /// <param name="goInDepth">if true, batch and multi are explored in depth</param>
        /// <param name="isMulti">indicates if the request is multi</param>
        /// <param name="hasWatcher">indicates if the request has watchers</param>
        /// <returns>true if the request is read-only</returns>
        private bool IsReadOnlyRequest(IRingMasterBackendRequest req, bool considerCreateEphemeralAsReadOnly, bool goInDepth, out bool isMulti, out bool hasWatcher)
        {
            hasWatcher = false;
            isMulti = false;

            switch (req.RequestType)
            {
                case RingMasterRequestType.Multi:
                case RingMasterRequestType.Batch:
                    {
                        isMulti = true;
                        bool result = true;

                        if (goInDepth)
                        {
                            IRingMasterBackendCompondRequest mreq = (IRingMasterBackendCompondRequest)req;

                            // go in depth
                            if (mreq.Requests != null)
                            {
                                foreach (IRingMasterBackendRequest r in mreq.Requests)
                                {
                                    bool auxMulti;
                                    bool auxWatcher;
                                    bool isro = IsReadOnlyRequest(r, considerCreateEphemeralAsReadOnly, goInDepth, out auxMulti, out auxWatcher);
                                    if (auxWatcher)
                                    {
                                        hasWatcher = true;
                                    }

                                    if (!isro)
                                    {
                                        result = false;
                                    }
                                }
                            }
                        }

                        return result;
                    }
                case RingMasterRequestType.Create:
                    if (considerCreateEphemeralAsReadOnly)
                    {
                        RequestCreate crreq = (RequestCreate)req;

                        if (crreq.CreateMode == CreateMode.Ephemeral || crreq.CreateMode == CreateMode.EphemeralSequential)
                        {
                            return true;
                        }
                    }

                    return false;
                case RingMasterRequestType.Delete:
                case RingMasterRequestType.SetAcl:
                case RingMasterRequestType.SetData:
                    return false;
                case RingMasterRequestType.Exists:
                    hasWatcher = (((RequestExists)req).Watcher != null);
                    return true;
                case RingMasterRequestType.GetData:
                    hasWatcher = (((RequestGetData)req).Watcher != null);
                    return true;
                case RingMasterRequestType.GetChildren:
                    hasWatcher = (((RequestGetChildren)req).Watcher != null);
                    return true;
                case RingMasterRequestType.SetAuth:
                // set auth is readonly for the tree
                case RingMasterRequestType.Check:
                // check is read only for the tree
                case RingMasterRequestType.GetAcl:
                // getacl is read only for the tree
                case RingMasterRequestType.Sync:
                // sync is read only for the tree
                case RingMasterRequestType.None:
                    // none is read only for the tree
                    return true;
            }
            return true;
        }

        /// <summary>
        /// sets the session identity to be the given one.
        /// </summary>
        /// <param name="req"></param>
        /// <param name="session"></param>
        /// <returns>the response to the query</returns>
        private RequestResponse SetAuth(RequestSetAuth req, ClientSession session)
        {
            session.SetClientDigest(req.ClientId);

            RingMasterEventSource.Log.SetAuth(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, session.Auth.ClientDigest);
            this.auditConsumer?.OnSetAuth(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, session.Auth.ClientDigest, session.Auth.IsSuperSession);

            return new RequestResponse()
            {
                ResultCode = (int) Code.Ok,
                Stat = null,
                Content = null
            };
        }

        /// <summary>
        /// returns a bad api result.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse BadApi(IRingMasterBackendRequest req, ClientSession session)
        {
            Trace.TraceInformation("BadApi is returned for request {0} on session {1}", req == null ? "null" : req.RequestType.ToString(), session == null ? "null" : session.FriendlyName);
            return new RequestResponse() { ResultCode = (int)Code.Apierror, Stat = null, Content = null };
        }

        /// <summary>
        /// returns a InLockDown result.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse InLockDown(IRingMasterBackendRequest req, ClientSession session)
        {
            Trace.TraceInformation("InLockDown is returned for request {0} on session {1}", req == null ? "null" : req.RequestType.ToString(), session == null ? "null" : session.FriendlyName);
            return new RequestResponse() { ResultCode = (int)Code.InLockDown, Stat = null, Content = null };
        }

        /// <summary>
        /// Returns a response indicating that the operation was cancelled.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse built as operation cancelled</returns>
        private RequestResponse OperationCancelled(IRingMasterBackendRequest req, ClientSession session)
        {
            Trace.TraceInformation("OperationCancelled is returned for request {0} on session {1}", req == null ? "null" : req.RequestType.ToString(), session == null ? "null" : session.FriendlyName);
            return new RequestResponse() { ResultCode = (int)Code.OperationCancelled, Stat = null, Content = null };
        }

        /// <summary>
        /// returns a bad auth result.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse BadAuth(IRingMasterBackendRequest req, ClientSession session)
        {
            Trace.TraceInformation("BadAuth is returned for request {0} on session {1}", req == null ? "null" : req.RequestType.ToString(), session == null ? "null" : session.FriendlyName);
            return new RequestResponse() { ResultCode = (int)Code.Authfailed, Stat = null, Content = null };
        }

        /// <summary>
        /// Creates the data.
        /// </summary>
        /// <param name="factory">The factory.</param>
        /// <param name="lockList">the transaction context.</param>
        /// <param name="name">The name.</param>
        /// <param name="acl">The acl.</param>
        /// <param name="data">The data.</param>
        /// <returns>IPersistedData.</returns>
        private IPersistedData CreateData(IPersistedDataFactory<Node> factory, ILockListTransaction lockList, string name, IReadOnlyList<Acl> acl, byte[] data, bool isMountPoint)
        {
            long zxid = lockList.TxId;
            long now = lockList.TxTime;

            if (acl != null && acl.Count == 0)
            {
                acl = null;
            }

            IPersistedData persisted;

            persisted = factory.CreateNew();

            lockList.RunOnAbort(() =>
            {
                factory.Delete(persisted);
            });

            persisted.Name = name;

            if (!isMountPoint)
            {
                persisted.Data = data;

                persisted.Acl = acl;

                if (persisted.IsEphemeral)
                {
                    persisted.Stat = new MutableStat(zxid, zxid, now, now, 1, 1, 1, (data == null ? 0 : data.Length), 0, zxid);
                }
                else
                {
                    persisted.Stat = new FirstStat(zxid, now, (data == null ? 0 : data.Length));
                }
            }

            factory.RecordDataDelta(persisted.Stat.DataLength);

            return persisted;
        }

        protected virtual void SetupVerbosityLevel(int level)
        {
        }

        protected virtual string GetVerbosityLevel()
        {
            return "1";
        }

        /// <summary>
        /// Class SecondaryPreprocessor abstracts what a secondary does additionally when processing commands.
        /// </summary>
        protected class SecondaryPreprocessor
        {
            /// <summary>
            /// the wire backup object
            /// </summary>
            private WireBackup wirebackup = null;

            /// <summary>
            /// this number is used to synchronize on the transaction Id.
            /// When the txId % runOnTxIdMultiplesOf == 0, we will run the runOnTxIdMultiples action
            /// </summary>
            private int runOnTxIdMultiplesOf;

            /// <summary>
            /// The last txId used to run the runOnTxIdMultiples action
            /// </summary>
            private long lastTxRun;

            /// <summary>
            /// Delegate RunOnTxIdMultiplesFunction. The function to run on TxIds multiples of a given number
            /// </summary>
            /// <param name="txtime">The tx time.</param>
            /// <param name="xid">The tx id.</param>
            public delegate void RunOnTxIdMultiplesFunction(long txtime, long xid);

            /// <summary>
            /// The action to run on every X transactions, based on the txId
            /// </summary>
            private RunOnTxIdMultiplesFunction runOnTxIdMultiples;

            /// <summary>
            /// The current wire backup snapshot identifier
            /// </summary>
            private int wbackupId = 0;

            /// <summary>
            /// the backend this processor works for
            /// </summary>
            private RingMasterBackendCore backend;

            /// <summary>
            /// the cached replica name for this process
            /// </summary>
            private string thisReplicaName = null;

            /// <summary>
            /// the cached path to place commands
            /// </summary>
            private string thisCommandPath = null;

            /// <summary>
            /// the path for a command for all replicas
            /// </summary>
            private readonly string thisCommandPathAllReplicas;

            /// <summary>
            /// the path for a command for the primary
            /// </summary>
            private readonly string thisCommandPathPrimary;

            /// <summary>
            /// the path for a command for all secondaries
            /// </summary>
            private readonly string thisCommandPathAllSecondaries;

            /// <summary>
            /// the path for a command for just one secondary (the healthy secondary with smaller id)
            /// </summary>
            private readonly string thisCommandPathOneSecondary;

            /// <summary>
            /// Gets the current wire backup snapshot identifier.
            /// </summary>
            /// <value>The current wire backup identifier.</value>
            public int WbackupId { get { return this.wbackupId; } }

            /// <summary>
            /// Gets the lazily cached replica name for this process
            /// </summary>
            public string ThisReplicaName
            {
                get
                {
                    if (thisReplicaName == null)
                    {
                        thisReplicaName = this.backend.Factory.Name;
                        thisCommandPath = this.backend.ReplicaCommandPathPrefix + "/$$" + thisReplicaName;
                    }
                    return thisReplicaName;
                }
            }

            /// <summary>
            /// Cancels any ongoing wb snapshot.
            /// </summary>
            public void CancelAnyOngoingActivity()
            {
                // this will cancel any ongoing WB snapshots
                int newId = GenerateNewWBackupId();
                Debug.Assert(newId >= 0);
            }

            /// <summary>
            /// Initializes a new instance of the <see cref="SecondaryPreprocessor"/> class.
            /// </summary>
            /// <param name="runOnTxIdMultiplesOf">The action will be run whenever txId % runOnTxIdMultiplesOf == 0.</param>
            /// <param name="runOnTxIdMultiples">The action to run whenever txId % runOnTxIdMultiplesOf == 0.</param>
            public SecondaryPreprocessor(RingMasterBackendCore backend, int runOnTxIdMultiplesOf, RunOnTxIdMultiplesFunction runOnTxIdMultiples)
            {
                if (backend == null)
                {
                    throw new ArgumentNullException("backend");
                }

                this.backend = backend;

                if (runOnTxIdMultiplesOf < 0)
                {
                    throw new ArgumentException("runOnTxIdMultiplesOf cannot be < 0");
                }

                this.runOnTxIdMultiplesOf = runOnTxIdMultiplesOf;
                this.lastTxRun = 0;

                this.runOnTxIdMultiples = runOnTxIdMultiples;
                this.thisCommandPathAllReplicas = this.backend.ReplicaCommandPathPrefix + "/$$<all>";
                this.thisCommandPathAllSecondaries = this.backend.ReplicaCommandPathPrefix + "/$$<sec>";
                this.thisCommandPathOneSecondary = this.backend.ReplicaCommandPathPrefix + "/$$<onesec>";
                this.thisCommandPathPrimary = this.backend.ReplicaCommandPathPrefix + "/$$<prim>";

                Trace.TraceInformation("this.runOnTxIdMultiples={0}", this.runOnTxIdMultiplesOf);
            }

            /// <summary>
            /// performs the actions on apply, and maybe run the scheduled action
            /// </summary>
            /// <param name="txtime">the time the transaction has</param>
            /// <param name="xid">the id for the transaction</param>
            /// <param name="func">the function to run</param>
            /// <param name="onMultiples">if true, this is only a run in multiples of</param>
            private void DoActionsOnApply(long txtime, long xid, RunOnTxIdMultiplesFunction func, bool onMultiples = true)
            {
                // if we already saw this txid (multiple calls to DoActionsOnApply per txid are possible), exit now
                if (xid == this.lastTxRun)
                {
                    return;
                }

                // if we are still loading, exit now
                if (this.ThisReplicaName == null)
                {
                    return;
                }

                // first produce an instrumentation signal indicating we are applying this transaction
                RingMasterServerInstrumentation.Instance.OnApply(txtime, xid);

                // if we don't have a function, exit now
                if (func == null)
                {
                    return;
                }

                // we only run the periodic action if we have a proper configuration, and it is time to run it based on such config
                if (onMultiples && (runOnTxIdMultiplesOf == 0 || (xid % runOnTxIdMultiplesOf) != 0))
                {
                    return;
                }

                // if the time is too off, exit
                if (Math.Abs((DateTime.UtcNow - MutableStat.ConvertTime(txtime)).TotalSeconds) > 60)
                {
                    Trace.TraceInformation("skipping action because it likely comes from the past");
                    return;
                }

                // set the last txid seen
                this.lastTxRun = xid;

                // do the action
                func(txtime, xid);
            }

            /// <summary>
            /// Generates the new wire backup identifier, this will cancal any ongoing wbsnapshot.
            /// </summary>
            /// <returns>the new wire backup identifier</returns>
            internal int GenerateNewWBackupId()
            {
                return Interlocked.Increment(ref wbackupId);
            }

            /// <summary>
            /// Sets the wire backup for the preprocessor, and optionally starts it.
            /// </summary>
            /// <param name="wirebackup">The wirebackup.</param>
            /// <param name="start">if set to <c>true</c> start the wirebackup.</param>
            internal void SetWireBackup(WireBackup wirebackup, bool start)
            {
                this.wirebackup = wirebackup;

                if (start && wirebackup != null)
                {
                    this.wirebackup.Start();
                }
            }

            /// <summary>
            /// Stops the wire backup for this preprocessor.
            /// </summary>
            internal void StopWireBackup()
            {
                if (this.wirebackup != null)
                {
                    this.wirebackup.Stop();
                    this.wirebackup = null;
                }
            }

            /// <summary>
            /// Appends the Create operation to the secondary preprocessor
            /// </summary>
            /// <param name="nodeId">The node identifier.</param>
            /// <param name="txtime">The transaction time.</param>
            /// <param name="xid">The tranaction id.</param>
            internal void AppendCreate(IPersistedData node, long txtime, long xid)
            {
                if (this.wirebackup != null)
                {
                    this.wirebackup.AppendCreate(node, txtime, xid);
                }

                this.DoActionsOnApply(txtime, xid, this.runOnTxIdMultiples);
            }

            /// <summary>
            /// Appends the AddChild operation to the secondary preprocessor
            /// </summary>
            /// <param name="parentId">The parent identifier.</param>
            /// <param name="childId">The child identifier.</param>
            /// <param name="txtime">The transaction time.</param>
            /// <param name="xid">The tranaction id.</param>
            internal void AppendAddChild(ulong parentId, ulong childId, long txtime, long xid)
            {
                if (this.wirebackup != null)
                {
                    this.wirebackup.AppendAddChild(parentId, childId, txtime, xid);
                }

                this.DoActionsOnApply(txtime, xid, this.runOnTxIdMultiples);
            }

            /// <summary>
            /// Appends the RemoveChild operation to the secondary preprocessor
            /// </summary>
            /// <param name="parentId">The parent identifier.</param>
            /// <param name="childId">The child identifier.</param>
            /// <param name="txtime">The transaction time.</param>
            /// <param name="xid">The tranaction id.</param>
            internal void AppendDelete(ulong parentId, ulong childId, long txtime, long xid)
            {
                if (this.wirebackup != null)
                {
                    this.wirebackup.AppendDelete(parentId, childId, txtime, xid);
                }

                this.DoActionsOnApply(txtime, xid, this.runOnTxIdMultiples);
            }

            /// <summary>
            /// Appends the RemoveChild operation to the secondary preprocessor
            /// </summary>
            /// <param name="parentId">The parent identifier.</param>
            /// <param name="childId">The child identifier.</param>
            /// <param name="txtime">The transaction time.</param>
            /// <param name="xid">The tranaction id.</param>
            internal void AppendRemoveChild(ulong parentId, ulong childId, long txtime, long xid)
            {
                if (this.wirebackup != null)
                {
                    this.wirebackup.AppendRemoveChild(parentId, childId, txtime, xid);
                }

                this.DoActionsOnApply(txtime, xid, this.runOnTxIdMultiples);
            }

            /// <summary>
            /// Appends the SetAcl operation to the secondary preprocessor
            /// </summary>
            /// <param name="id">The node identifier.</param>
            /// <param name="list">The Acl set.</param>
            /// <param name="txtime">The transaction time.</param>
            /// <param name="xid">The tranaction id.</param>
            internal void AppendSetAcl(ulong id, IReadOnlyList<Acl> list, long txtime, long xid)
            {
                if (this.wirebackup != null)
                {
                    this.wirebackup.AppendSetAcl(id, list, txtime, xid);
                }

                this.DoActionsOnApply(txtime, xid, this.runOnTxIdMultiples);
            }

            /// <summary>
            /// Appends the SetData operation to the secondary preprocessor
            /// </summary>
            /// <param name="id">The node identifier.</param>
            /// <param name="data">The data set.</param>
            /// <param name="txtime">The transaction time.</param>
            /// <param name="xid">The tranaction id.</param>
            internal void AppendSetData(ulong id, byte[] data, long txtime, long xid)
            {
                if (this.wirebackup != null)
                {
                    this.wirebackup.AppendSetData(id, data, txtime, xid);
                }

                this.DoActionsOnApply(txtime, xid, this.runOnTxIdMultiples);
            }

            /// <summary>
            /// Tries to run the command associated to the node, and encoded in the byte[]
            /// </summary>
            /// <param name="node">the node representing who will run the command</param>
            /// <param name="data">the data encoding the command. data must be a string encoded in UTF8, where the string is a RM command. RM commands are "$/[command]?arguments".</param>
            /// <param name="txtime">the time of the tx which contains the command</param>
            /// <param name="xid">the id of the tx which contains the command</param>
            /// <returns>trus if the command was executed. False otherwise</returns>
            internal bool TryRunCommand(IPersistedData node, byte[] data, long txtime, long xid)
            {
                if (node == null)
                {
                    throw new ArgumentNullException("node");
                }

                bool didrun = false;
                string path = Node.BuildPath(node);

                if (data == null || !CanRunInThisReplica(path))
                {
                    return didrun;
                }

                this.DoActionsOnApply(txtime, xid, (t, i) =>
                {
                    didrun = true;

                    string requestedCommand = null;
                    object content = null;
                    string command = null;

                    try
                    {
                        string datastr = Encoding.UTF8.GetString(data);
                        byte[] argumentdata = null;
                        int p = datastr.IndexOf('?');

                        if (p == -1)
                        {
                            command = datastr;
                        }
                        else
                        {
                            command = datastr.Substring(0, p);
                            argumentdata = Encoding.UTF8.GetBytes(datastr.Substring(p + 1));
                        }

                        Code res = this.backend.rmCommands.RunCommandPath(command, argumentdata, null, null, out requestedCommand, out content);
                        Trace.TraceInformation("command {0} was run at {1} with result {2}. content={3}", command, thisCommandPath, res, content);
                    }
                    catch (Exception e)
                    {
                        Trace.TraceInformation("command {0} was run at {1} (content={2}) with exception {3}. ", command, thisCommandPath, content, e);
                    }
                }, false);

                return didrun;
            }

            /// <summary>
            /// Indicates if the given path to a command node is suitable for the current replica at this time
            /// </summary>
            /// <param name="path">path to a command node</param>
            /// <returns>true if we should execute the command</returns>
            private bool CanRunInThisReplica(string path)
            {
                if (string.Equals(path, thisCommandPath))
                {
                    // if the path is our instance path, we can run it
                    return true;
                }

                if (string.Equals(path, thisCommandPathAllReplicas))
                {
                    // if the path is a 'everybody runs', we can run it
                    return true;
                }

                if (this.backend.IsPrimary())
                {
                    // if the path is a 'primary runs' AND we are primary, we can run it
                    return string.Equals(path, thisCommandPathPrimary);
                }

                if (string.Equals(path, thisCommandPathAllSecondaries))
                {
                    // if the path is a 'secondaries run' AND we are secondary, we can run it
                    return true;
                }

                if (string.Equals(path, thisCommandPathOneSecondary))
                {
                    // if the path is a 'oneSecondaries run' AND we are the lowest ID secondary, we can run it

                    // minSec will be the lowest Id of a healthy secondary
                    string minSec = null;

                    foreach (KeyValuePair<string, HealthDefinition> mem in this.backend.Factory.GetHealth())
                    {
                        if (!mem.Value.IsPrimary && mem.Value.HealthRatio > 0.5)
                        {
                            if (minSec == null || minSec.CompareTo(mem.Key) > 0)
                            {
                                minSec = mem.Key;
                            }
                        }
                    }

                    if (String.Equals(minSec, ThisReplicaName))
                    {
                        return true;
                    }
                }

                return false;
            }

            /// <summary>
            /// sets up the tree for commands, with the given Acls and structure
            /// </summary>
            internal void SetupCommandTree()
            {
                // instantiate a fake session with proper credentials
                ClientSession ses = this.backend.GetLoopbackSession(RMCommands.CommanderDigest);

                try
                {
                    // extract the digest from Auth, and build Acls
                    string[] digestieces = ses.Auth.ClientDigest.Split(':');

                    List<Acl> acls = null;
                    if (digestieces.Length == 2)
                    {
                        acls = new List<Acl>() { new Acl((int)Perm.ALL, new Id(digestieces[0], digestieces[1])) };
                    }

                    // now, build the tree
                    RequestResponse resp;

                    // try to create the path to the commands node, with the Acls
                    resp = this.backend.ProcessMessage(new RequestCreate(this.backend.ReplicaCommandPathPrefix, null, null, acls, CreateMode.PersistentAllowPathCreation, null), ses);
                    Trace.TraceInformation("SetupCommandTree: create({0})-->{1}", this.backend.ReplicaCommandPathPrefix, (Code)resp.ResultCode);

                    bool needsAcl = true;

                    // try to override the ACls, in case those were wrong
                    Stat anyStat = new Stat();
                    anyStat.Aversion = anyStat.Cversion = anyStat.Version = -1;
                    resp = this.backend.ProcessMessage(new RequestGetAcl(this.backend.ReplicaCommandPathPrefix, null, anyStat, null), ses);

                    if (resp != null && resp.ResultCode == (int)Code.Ok)
                    {
                        IList<Acl> prevAcl = resp.Content as IList<Acl>;

                        if (EqualityHelper.Equals(acls, prevAcl))
                        {
                            needsAcl = false;
                        }
                    }

                    if (needsAcl)
                    {
                        // try to override the ACls, in case those were wrong
                        resp = this.backend.ProcessMessage(new RequestSetAcl(this.backend.ReplicaCommandPathPrefix, null, acls, -1, null), ses);
                        Trace.TraceInformation("SetupCommandTree: setacl({0})-->{1}", this.backend.ReplicaCommandPathPrefix, (Code)resp.ResultCode);
                    }
                    else
                    {
                        Trace.TraceInformation("SetupCommandTree: setacl({0})-->{1}", this.backend.ReplicaCommandPathPrefix, "not needed");
                    }

                    // now we add the paths we need to have
                    List<string> paths = new List<string>()
                    {
                        this.thisCommandPathPrimary,
                        this.thisCommandPathOneSecondary,
                        this.thisCommandPathAllReplicas,
                        this.thisCommandPathAllSecondaries
                    };

                    // append the instance command nodes
                    foreach (ClusterMember m in this.backend.Factory.GetAgreedMembers())
                    {
                        paths.Add(this.backend.ReplicaCommandPathPrefix + "/$$" + m.MemberId);
                    }

                    // create the command nodes
                    foreach (string path in paths)
                    {
                        resp = this.backend.ProcessMessage(new RequestCreate(path, null, null, null, CreateMode.Persistent, null), ses);
                        Trace.TraceInformation("SetupCommandTree: create({0})-->{1}", path, (Code)resp.ResultCode);
                    }

                }
                finally
                {
                    if (ses != null)
                    {
                        ses.Close();
                    }
                }
            }

            /// <summary>
            /// sets up the initial structure for commodity nodes
            /// </summary>
            internal void SetupCommodityTree()
            {
                // instantiate a fake session with proper credentials
                ClientSession ses = this.backend.GetLoopbackSession(RMCommands.CommanderDigest);

                try
                {
                    List<Acl> acls = null;

                    // now, build the tree
                    RequestResponse resp;

                    // try to create the path to the bulkwatcher node
                    string path = BulkOperation.GetBulkWatcherName(null);
                    resp = this.backend.ProcessMessage(new RequestCreate(path, null, null, acls, CreateMode.PersistentAllowPathCreation, null), ses);

                    Trace.TraceInformation("SetupCommodityTree: create({0})-->{1}", path, resp == null ? Code.Unknown : (Code)resp.ResultCode);
                }
                catch (Exception e)
                {
                    Trace.TraceWarning("SetupCommodityTree: ignorable error {0}", e.Message);
                }
                finally
                {
                    if (ses != null)
                    {
                        ses.Close();
                    }
                }
            }
        }

        /// <summary>
        /// generates a loopback session with the given digest.
        /// </summary>
        /// <param name="digest">the digest to use</param>
        /// <param name="onlyEphemeralChangesAllowed">if true, only operations on ephemeral are allowed</param>
        /// <param name="writesAllowed">if true, this session is allowed to do writes</param>
        /// <param name="readOnlyInterfaceRequiresLocks">if true, locks are needed for RO locks</param>
        /// <returns></returns>
        internal ClientSession GetLoopbackSession(string digest, bool onlyEphemeralChangesAllowed = false, bool writesAllowed = true, bool readOnlyInterfaceRequiresLocks = true)
        {
            ClientSession ses = new ClientSession(null);

            ses.State = ClientSession.SessionState.Initialized;
            ses.writesAllowed = writesAllowed;
            ses.ROInterfaceRequiresLocks = readOnlyInterfaceRequiresLocks;
            ses.SetClientDigest(digest);
            ses.OnlyEphemeralChangesAllowed = writesAllowed && onlyEphemeralChangesAllowed;
            return ses;
        }

        /// <summary>
        /// commands to RM
        /// </summary>
        protected class RMCommands
        {
            protected RingMasterBackendCore backend;

            /// <summary>
            /// command paths will not start with the ususal '/...' but with '$/...'
            /// </summary>
            private const string PrefixPath = "$/";
            public const string CommanderDigest = "digest:commander";

            /// <summary>
            /// The object used to synchronize certain actions with the rest of the system
            /// </summary>
            internal readonly object syncObject = new object();

            /// <summary>
            /// commands are encoded in a create operation for a path.
            /// The path contains the operation and the arguments.
            /// </summary>
            /// <param name="path">the path potentially containing the command</param>
            /// <returns>true if the path is a command</returns>
            public virtual bool IsCommand(string path)
            {
                if (path == null)
                {
                    return false;
                }

                if (path.Length > 2 && path[0] != '/' && path.StartsWith(PrefixPath))
                {
                    return true;
                }

                return false;
            }

            /// <summary>
            /// commands are encoded in a create operation for a path.
            /// This routines tells if the given request is a single command
            /// </summary>
            /// <param name="req">the request potentially containing the command</param>
            /// <returns>true if the request is a command</returns>
            public virtual bool IsCommand(IRingMasterBackendRequest req)
            {
                if (req == null)
                {
                    return false;
                }
                if (req.RequestType != RingMasterRequestType.Create)
                {
                    return false;
                }
                return (IsCommand(req.Path));
            }

            public virtual string GetCommands()
            {
                return "getcommands getstats dumpnodes getsetting getverbositylevel getlocaltime setverbositylevel measure trace restart die gc takecheckpoint cleanuprsl failoverinto downloadurlintolocation importcheckpoint poisonpill";
            }

            /// <summary>
            /// Determines whether the command is allowed at this time
            /// </summary>
            /// <param name="session">The session invoking the command.</param>
            /// <param name="command">The command.</param>
            /// <returns><c>true</c> if the command for the path is allowed at this time; otherwise, <c>false</c>.</returns>
            public virtual bool IsCommandAllowed(ClientSession session, string command)
            {
                bool writesOk = true;
                if (session != null)
                {
                    writesOk = session.writesAllowed;
                }

                if (!this.backend.WritesAllowed)
                {
                    writesOk = false;
                }

                if (writesOk || command == null)
                {
                    return true;
                }

                switch (command)
                {
                    case "getstats":
                    case "dumpnodes":
                    case "getcommands":
                    case "getsetting":
                    case "getverbositylevel":
                    case "getlocaltime":
                    case "mount":
                    case "remountroot":
                    case "unmount":
                    case "remount":
                    case "buildtreefile":
                    case "setverbositylevel":
                    case "trace":
                    case "measure":
                    case "restart":
                    case "die":
                    case "gc":
                    case "cleanuprsl":
                    case "downloadurlintolocation":
                    case "importcheckpoint":
                    case "takecheckpoint":
                        return true;
                    case "failoverinto":
                    case "poisonpill":
                        return false;
                    default:
                        return false;
                }
            }

            /// <summary>
            /// runs the command from the path
            /// </summary>
            /// <param name="req">the request containing the command</param>
            /// <param name="session">the session this command was run from</param>
            /// <param name="lockList">the lock list of the invocation</param>
            /// <returns>the repsonse to the command</returns>
            internal virtual RequestResponse RunCommand(RequestCreate req, ClientSession session, ILockListTransaction lockList)
            {
                if (req == null)
                {
                    throw new ArgumentNullException("req");
                }

                if (session == null)
                {
                    throw new ArgumentNullException("session");
                }

                MutableStat stat = new MutableStat(new FirstStat(0, MutableStat.ConvertTime(DateTime.UtcNow), 0));

                // we require the digest 'Commander'
                if (!string.Equals(session.Auth.ClientDigest, CommanderDigest, StringComparison.InvariantCultureIgnoreCase))
                {
                    return new RequestResponse()
                    {
                        Content = "not executed",
                        ResponsePath = "command",
                        ResultCode = (int)Code.Authfailed,
                        Stat = stat
                    };
                }

                string requestedCommand;
                object content;
                Code result = RunCommandPath(req.Path, req.Data, session, lockList, out requestedCommand, out content);

                return new RequestResponse()
                {
                    Content = content,
                    ResponsePath = requestedCommand,
                    ResultCode = (int)result,
                    Stat = stat
                };
            }

            /// <summary>
            /// runs the command encoded in the given path
            /// </summary>
            /// <param name="path">the command encoded in the path</param>
            /// <param name="data">optionally, the data associated with the request</param>
            /// <param name="lockList">the lock list of the invocation</param>
            /// <param name="requestedCommand"></param>
            /// <param name="content"></param>
            /// <returns></returns>
            public Code RunCommandPath(string path, byte[] data, ClientSession session, ILockListTransaction lockList, out string requestedCommand, out object content)
            {
                if (path == null)
                {
                    throw new ArgumentNullException("path");
                }

                Code result = Code.Apierror;

                requestedCommand = "unknown";
                content = "unknown command";

                if (!IsCommand(path))
                {
                    return result;
                }

                string[] pieces = path.Split('/');

                if (pieces.Length >= 2)
                {
                    requestedCommand = pieces[1].ToLower();

                    if (!IsCommandAllowed(session, requestedCommand))
                    {
                        content = "command not allowed now";
                        return Code.Apierror;
                    }

                    RingMasterEventSource.Log.RunCommand(requestedCommand);
                    this.backend.auditConsumer?.OnRunCommand(requestedCommand);

                    switch (requestedCommand)
                    {
                        case "getsetting":
                            {
                                content = RingMasterBackendCore.GetSetting(pieces[2]);
                                result = Code.Ok;
                                break;
                            }
                        case "gc":
                            {
                                GC.Collect();
                                content = "GC scheduled";
                                result = Code.Ok;
                                break;
                            }
                        case "takecheckpoint":
                            {
                                bool ok = backend.Factory.TakeCheckpoint();
                                content = string.Format("Checkpoint {0}scheduled", ok ? "" : "not ");
                                result = Code.Ok;
                                break;
                            }
                        case "buildtreefile":
                            {
                                string commandResult;
                                string[] args = Encoding.UTF8.GetString(data).Split('|');
                                try
                                {
                                    int ver = int.Parse(args[2]);
                                    RequestResponse resp = this.backend.BuildTreeFile(nodepath: args[0], filename: args[1], version:ver);
                                    commandResult = resp.ResultCode == (int)Code.Ok ? "success" : "failed";
                                    result = (Code)resp.ResultCode;
                                }
                                catch (Exception e)
                                {
                                    commandResult = "failed:" + e.Message;
                                    result = Code.Systemerror;
                                }

                                content = string.Format("buildtreefile: nodepath={0} filename={1} result={2}", args[0], args[1], commandResult);

                                break;
                            }
                        case "mount":
                            {
                                string commandResult;
                                string[] args = Encoding.UTF8.GetString(data).Split('|');
                                try
                                {
                                    RequestResponse resp = this.backend.Mount(nodepath: args[0], filename: args[1], allowremount: false);
                                    commandResult = resp.ResultCode == (int)Code.Ok ? "success" : "failed";
                                    result = (Code)resp.ResultCode;
                                }
                                catch (Exception e)
                                {
                                    commandResult = "failed:" + e.Message;
                                    result = Code.Unknown;
                                }

                                content = string.Format("mount: nodepath={0} filename={1} result={2}", args[0], args[1], commandResult);

                                break;
                            }
                        case "remountroot":
                            {
                                string commandResult;
                                string filepath = Encoding.UTF8.GetString(data);
                                try
                                {
                                    RequestResponse resp = this.backend.Mount(nodepath: "/", filename: filepath, allowremount: true, mountroot:true);
                                    commandResult = resp.ResultCode == (int)Code.Ok ? "success" : "failed";
                                    result = (Code)resp.ResultCode;
                                }
                                catch (Exception e)
                                {
                                    commandResult = "failed:" + e.Message;
                                    result = Code.Unknown;
                                }

                                content = string.Format("mountroot: nodepath=/ filename={0} result={1}", filepath, commandResult);

                                break;
                            }
                        case "unmount":
                            {
                                string commandResult;
                                string[] args = Encoding.UTF8.GetString(data).Split('|');

                                try
                                {
                                    RequestResponse resp = this.backend.Unmount(args[0]);
                                    commandResult = resp.ResultCode == (int)Code.Ok ? "success" : "failed";
                                    result = (Code)resp.ResultCode;
                                }
                                catch (Exception e)
                                {
                                    commandResult = "failed:" + e.Message;
                                    result = Code.Unknown;
                                }

                                content = string.Format("mount: nodepath={0} result={1}", args[0], commandResult);

                                break;
                            }
                        case "remount":
                            {
                                string commandResult;
                                string[] args = Encoding.UTF8.GetString(data).Split('|');
                                try
                                {

                                    RequestResponse resp = this.backend.Mount(nodepath: args[0], filename: args[1], allowremount: true);
                                    commandResult = resp.ResultCode == (int)Code.Ok ? "success" : "failed";
                                    result = (Code)resp.ResultCode;
                                }
                                catch (Exception e)
                                {
                                    commandResult = "failed:" + e.Message;
                                    result = Code.Unknown;
                                }
                                content = string.Format("remount: nodepath={0} result={1}", args[0], commandResult);

                                break;
                            }
                        case "measure":
                            {
                                StringBuilder sb = new StringBuilder();

                                Dictionary<string, object> results;
                                try
                                {
                                    this.backend.CanMeasure = true;
                                    ((IUnsafeTreeAccess)this.backend).LockRootNoSync();

                                    results = this.backend.MeasureFullTree(PlatformHelper.ProcessorCount, MaxTimeForMeasurementInMillis);
                                }
                                finally
                                {
                                    this.backend.CanMeasure = false;
                                    ((IUnsafeTreeAccess)this.backend).ReleaseRoot();
                                }

                                if (results != null)
                                {
                                    foreach (KeyValuePair<string, object> line in results)
                                    {
                                        string text;
                                        string child_i = line.Key;

                                        Exception e = line.Value as Exception;

                                        if (e != null)
                                        {
                                            text = string.Format("Metrics for {0}: {1}", child_i, e);
                                        }
                                        else
                                        {
                                            ulong metrics = (ulong)line.Value;
                                            text = string.Format("Metrics for {0} is {1:X}", child_i, metrics);
                                        }

                                        sb.AppendLine(text);
                                    }
                                }

                                content = sb.ToString();
                                result = Code.Ok;
                                break;
                            }
                        case "getlocaltime":
                            {
                                content = string.Format("local time: " + DateTime.UtcNow.ToString("o"));
                                result = Code.Ok;
                                break;
                            }
                        case "getcommands":
                            {
                                content = GetCommands();
                                result = Code.Ok;
                                break;
                            }
                        case "trace":
                            {
                                string message = "<null>";
                                if (data != null)
                                {
                                    message = Encoding.UTF8.GetString(data);
                                }

                                content = "traced: " + message;
                                result = Code.Ok;
                                Trace.TraceInformation(message);
                                break;
                            }
                        case "failoverinto":
                            {
                                string replica = "<any>";
                                if (data != null)
                                {
                                    replica = Encoding.UTF8.GetString(data);
                                }

                                content = "Failing over into: " + replica + " in 10 seconds";
                                this.backend.FailoverInto(replica, 10000);
                                result = Code.Ok;
                                break;
                            }
                        case "downloadurlintolocation":
                            {
                                string arguments = null;

                                if (data != null)
                                {
                                    arguments = Encoding.UTF8.GetString(data);
                                }

                                // we run this one command asynchronously with any potential replication
                                bool hasStarted = this.backend.DownloadUrlIntoLocation(arguments);
                                if (hasStarted)
                                {
                                    content = string.Format("DownloadUrlIntoLocation started arguments={0}", arguments);
                                    result = Code.Ok;
                                }
                                else
                                {
                                    content = string.Format("DownloadUrlIntoLocation functionality is not implemented");
                                    result = Code.Unimplemented;
                                }

                                break;
                            }
                        case "poisonpill":
                            {
                                string spec = null;

                                if (data != null)
                                {
                                    spec = Encoding.UTF8.GetString(data);
                                }

                                RequestResponse res = GeneratePoisonPill(spec, session, lockList);
                                if (res != null)
                                {
                                    content = string.Format("poison pill executed. Result = {0}", res.Content);
                                    result = (Code)res.ResultCode;
                                }
                                else
                                {
                                    content = "Poison pills not allowed from config";
                                    result = Code.Authfailed;
                                }

                                break;
                            }
                        case "importcheckpoint":
                            {
                                string location = null;

                                if (data != null)
                                {
                                    location = Encoding.UTF8.GetString(data);
                                }

                                RingMasterThreadPool.Instance.QueueUserWorkItem(_ =>
                                {
                                    Thread.Sleep(5000);
                                    bool ok = this.backend.ImportCheckpoint(location);
                                    Trace.TraceWarning("Import checkpoint {0}: {1}", location, ok ? "Succeeded" : "Failed");
                                    if (ok)
                                    {
                                        Trace.TraceWarning("This instance will die now");
                                        Environment.Exit(1);
                                    }
                                });

                                content = "Importing checkpoint " + location + "file and restarting";
                                result = Code.Ok;

                                break;
                            }
                        case "getstats":
                            {
                                lock (this.syncObject)
                                {
                                    content = string.Format("PersistentData.TotalNodes={0} PersistentData.TotalData={1} EphemeralData.TotalNodes={2} EphemeralData.TotalData={3}", backend.Factory.TotalNodes, backend.Factory.TotalData, backend.EphemeralFactory.TotalNodes, backend.EphemeralFactory.TotalData);
                                }

                                result = Code.Ok;

                                break;
                            }
                        case "dumpnodes":
                            {
                                bool scanEphemerals = pieces.Length > 2 && string.Equals(pieces[2], "scanephemerals", StringComparison.InvariantCultureIgnoreCase);
                                content = backend.Factory.DumpAllNodesForDebug();

                                if (scanEphemerals)
                                {
                                    lock (this.syncObject)
                                    {
                                        content = content + Environment.NewLine + "---Eph:" + Environment.NewLine + backend.ScanForEphemeral() + Environment.NewLine + "---";
                                    }
                                }

                                result = Code.Ok;

                                break;
                            }
                        case "getverbositylevel":
                            {
                                content = "verbosity level is " + backend.GetVerbosityLevel();
                                result = Code.Ok;
                                break;
                            }
                        case "setverbositylevel":
                            {
                                int vlev = int.Parse(pieces[2]);
                                content = string.Format("verbosity level was {0} now is set to {1}", backend.GetVerbosityLevel(), vlev);
                                backend.SetupVerbosityLevel(vlev);
                                result = Code.Ok;
                                break;
                            }
                        case "cleanuprsl":
                            {
                                RingMasterThreadPool.Instance.QueueUserWorkItem(_ =>
                                {
                                    Thread.Sleep(10000);
                                    Trace.TraceWarning("This instance will wipe its state {0} now", backend.GetType().Name);
                                    this.backend.Factory.WipeAllDataAndShutdown();
                                    Trace.TraceWarning("This instance will die now");
                                    Environment.Exit(1);
                                });
                                content = "cleaning up RSL folder and restarting";
                                result = Code.Ok;
                                break;
                            }
                        case "restart":
                            {
                                uint waitMS = 10000;

                                if (pieces.Length > 2)
                                {
                                    if (!uint.TryParse(pieces[2], out waitMS))
                                    {
                                        waitMS = 10000;
                                    }
                                }

                                // 2 minutes max wait
                                waitMS = Math.Min(waitMS, 120000);

                                RingMasterThreadPool.Instance.QueueUserWorkItem(_ =>
                                {
                                    Thread.Sleep((int)waitMS);
                                    Trace.TraceInformation("This instance will stop {0} now", backend.GetType().Name);
                                    backend.Stop();

                                    Thread.Sleep(2000);
                                    Trace.TraceInformation("This instance will restart {0} now", backend.GetType().Name);
                                    backend.Start();
                                });

                                content = "restarted in " + waitMS + " miliseconds";
                                result = Code.Ok;
                                break;
                            }
                        case "die":
                            {
                                RingMasterThreadPool.Instance.QueueUserWorkItem(_ =>
                                {
                                    Thread.Sleep(10000);
                                    Trace.TraceWarning("This instance will die now");
                                    Environment.Exit(1);
                                });

                                if (pieces.Length > 2)
                                {
                                    backend.FailoverInto(pieces[2]);
                                }

                                content = "die in 10 seconds";
                                result = Code.Ok;
                                break;
                            }
                    }
                }

                return result;
            }

            /// <summary>
            /// Generates a poison pill.
            /// </summary>
            /// <param name="spec">the poison pill specification</param>
            /// <param name="session">the session where this poison pill needs to be executed</param>
            /// <param name="lockList">the lock list of the invocation</param>
            /// <returns>the result of applying the generated poison pill, or null if not allowed</returns>
            private RequestResponse GeneratePoisonPill(string spec, ClientSession session, ILockListTransaction lockList)
            {
                if (!ArePoisonPillAllowed)
                {
                    return null;
                }

                try
                {
                    if (String.IsNullOrWhiteSpace(spec))
                    {
                        throw new ArgumentException("spec must have a content.");
                    }

                    if (session == null)
                    {
                        throw new ArgumentNullException("session");
                    }

                    int idx = spec.IndexOf(':');

                    if (idx == -1)
                    {
                        throw new FormatException("spec must be <action>:<path>");
                    }

                    string action = spec.Substring(0, idx);
                    string path = spec.Substring(idx + 1);

                    this.backend.SetPoisonPillPath(path, action, session, lockList);

                    return new RequestResponse()
                    {
                        CallId = 0,
                        Content = "poisonpill prepared",
                        ResponsePath = path,
                        ResultCode = (int)Code.Ok
                    };
                }
                catch (FormatException e)
                {
                    return new RequestResponse()
                    {
                        CallId = 0,
                        Content = "Exception while parsing poisonpill spec: " + e.Message,
                        ResponsePath = "/",
                        ResultCode = (int)Code.Badarguments
                    };
                }
                catch (Exception e)
                {
                    return new RequestResponse()
                    {
                        CallId = 0,
                        Content = "Exception while parsing poisonpill spec: " + e.Message,
                        ResponsePath = "/",
                        ResultCode = (int)Code.Apierror
                    };
                }
            }

            public RMCommands(RingMasterBackendCore be)
            {
                this.backend = be;
            }
        }

        private void ValidateEphemeralStats()
        {
            ((IUnsafeTreeAccess)this).LockRoot();
            try
            {
                ulong count = (ulong)ScanForEphemeral(this.Root).Count();
                if (count != this.EphemeralFactory.TotalNodes)
                {
                    Console.WriteLine("count={0};ephemeral.count={1}", count, this.EphemeralFactory.TotalNodes);
                    Debugger.Launch();
                    Debugger.Break();
                }
            }
            finally
            {
                ((IUnsafeTreeAccess)this).ReleaseRoot();
            }
        }

        private string ScanForEphemeral()
        {
            StringBuilder sb = new StringBuilder();
            foreach (Node n in ScanForEphemeral(this.Root))
            {
                sb.AppendLine(n.BuildPath());
            }
            return sb.ToString();
        }

        private IEnumerable<Node> ScanForEphemeral(Node root)
        {
            foreach (IPersistedData child in root.ChildrenMapping.Values)
            {
                if (child.IsEphemeral)
                {
                    yield return child.Node;
                }
                if (child.GetChildrenCount() > 0)
                {
                    foreach (Node n in ScanForEphemeral(child.Node))
                    {
                        yield return n;
                    }
                }
            }
        }

        /// <summary>
        /// Class RequestInternalRun.
        /// </summary>
        public class RequestInternalRun : BackendRequestWithContext<RequestDefinitions.RequestInternalRun, NoType>
        {
            private readonly VoidCallbackDelegate callback;

            public Func<RequestInternalRun, ILockListTransaction, RequestResponse> ActionToRun
            {
                get; private set;
            }

            public RequestInternalRun(string path, object ctx, Func<RequestInternalRun, ILockListTransaction, RequestResponse> actionToRun, VoidCallbackDelegate cb, ulong uid = 0)
                : base(new RequestDefinitions.RequestInternalRun(path,uid), ctx)
            {
                this.ActionToRun = actionToRun;
                this.callback = cb;
            }

            protected override void NotifyComplete(int resultCode, NoType ignore, IStat stat)
            {
                if (this.callback == null)
                {
                    return;
                }

                this.callback(resultCode, this.Path, this.Context);
            }
        }

        /// <summary>
        /// Builds a TreeFile for the given nodepath.
        /// </summary>
        /// <param name="nodepath">The nodepath.</param>
        /// <param name="filename">The filename.</param>
        /// <param name="version">The version.</param>
        /// <returns>the response of the operation</returns>
        public RequestResponse BuildTreeFile(string nodepath, string filename, int version)
        {
            ClientSession ses = this.GetLoopbackSession(RMCommands.CommanderDigest);
            try
            {
                RequestInternalRun req = new RequestInternalRun(nodepath, null, (x, l) => { return BuildTreeFile(x, l, version, filename); }, null);

                return this.ProcessMessage(req, ses);
            }
            finally
            {
                ses.Close();
            }
        }

        /// <summary>
        /// Mounts the specified filename on the given nodepath.
        /// </summary>
        /// <param name="nodepath">The nodepath.</param>
        /// <param name="filename">The filename.</param>
        /// <param name="allowremount">if set to <c>true</c> remounts are allowed.</param>
        /// <returns>the response of the operation</returns>
        public RequestResponse Mount(string nodepath, string filename, bool allowremount, bool mountroot = false)
        {
            ClientSession ses = this.GetLoopbackSession(RMCommands.CommanderDigest);
            try
            {
                RequestInternalRun req = new RequestInternalRun(nodepath, null, (x, l) => { return this.Mount(x, l, ses, filename, allowremount, mountroot); }, null);

                return this.ProcessMessage(req, ses);
            }
            finally
            {
                ses.Close();
            }
        }

        private Node previousRoot = null;

        private RequestResponse Mount(RequestInternalRun req, ILockListTransaction lockList, ClientSession ses, string filename, bool allowremount, bool mountroot)
        {
            // if mountroot is true, move the current root to prevoiusroot, and set as root what we get from the mount.
            // also make sure we move into readonly mode.
            if (!mountroot)
            {
                string nodepath = req.Path;
                Node child = null;
                Node parent;
                child = this.Root.GetNode(nodepath, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.WRITE, out parent);

                if (!allowremount && child != null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nodeexists,
                        Stat = null,
                        Content = null
                    };
                }

                if (child != null)
                {
                    if (!child.Persisted.IsEphemeral)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Noauth,
                            Stat = null,
                            Content = null
                        };
                    }

                    RequestResponse resp = this.Unmount(nodepath, lockList, ses);

                    if (resp.ResultCode != (int)Code.Ok)
                    {
                        return resp;
                    }
                    child = null;
                }

                // create child as ephemeral, providing factory
                RequestCreate cr = new RequestCreate(nodepath, null, null, null, CreateMode.Ephemeral, null);

                RequestResponse reso = this.Create(cr, ses, lockList, filename);

                return reso;
            }
            else
            {
                // must allow remount
                if (!allowremount)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nodeexists,
                        Stat = null,
                        Content = null
                    };
                }

                // must be the root path
                string nodepath = req.Path;
                if (!String.Equals("/", req.Path))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = null
                    };
                }

                // plan B: if things fail, set things back to the current state.
                {
                    Node prevRoot = this.Root;
                    Node prev_prevRoot = this.previousRoot;

                    lockList.RunOnAbort(() =>
                    {
                        this.previousRoot = prev_prevRoot;
                        this.Root = prevRoot;
                    });
                }

                // if the filename is '<previous>' this is a 'go back to previous' operation
                if (string.Equals(filename, "<previous>"))
                {
                    if (this.previousRoot != null)
                    {
                        this.Root = this.previousRoot;
                        this.previousRoot = null;
                    }

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Ok,
                        Stat = null,
                        Content = null
                    };
                }

                // else, try yo mount the file
                IPersistedDataFactory<Node> persFact = this.EphemeralMountPointFactory(filename);
                persFact.Activate(this, this);
                IPersistedData childData = this.CreateData(persFact, lockList, string.Empty, null, null, true);

                // we are done. return the node we have
                lockList.RunOnCommit(() =>
                {
                    // set the tree in lockdown
                    this.IsInFullLockDown = true;
                    this.previousRoot = Root;
                    this.Root = childData.Node;
                });

                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = null,
                    Content = null
                };
            }
        }

        private RequestResponse BuildTreeFile(RequestInternalRun req, ILockListTransaction lockList, int version, string filename)
        {
            string nodepath = req.Path;
            Node child = null;
            Node parent;
            child = this.Root.GetNode(nodepath, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.WRITE, out parent);

            if (child == null)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Nonode,
                    Stat = null,
                    Content = null
                };
            }

            // note we have acquired "child" in RW, so nothing under it can do writes now, but it is possible
            // that we have some ongoing transaction doing writes under it.
            // to be 100% consistent, this method should instead of taking a RW lock on child, take a RO lock on all nodes under it.
            IPersistedDataFactory<Node> factory = EphemeralMountPointFactory(null);
            bool ok = factory.TakeCheckpoint(child.Persisted, filename, version);

            return new RequestResponse()
            {
                ResponsePath = nodepath,
                ResultCode = ok ? (int)Code.Ok : (int)Code.Unknown,
                Stat = null,
                Content = null
            };
        }

        /// <summary>
        /// Unmounts the specified nodepath.
        /// </summary>
        /// <param name="nodepath">The nodepath.</param>
        /// <returns>the response of the operation</returns>
        public RequestResponse Unmount(string nodepath)
        {
            ClientSession ses = this.GetLoopbackSession(RMCommands.CommanderDigest);
            try
            {
                RequestInternalRun req = new RequestInternalRun(nodepath, null, (x,l)=> { return Unmount(x.Path, l, ses); }, null);

                return this.ProcessMessage(req, ses);
            }
            finally
            {
                ses.Close();
            }
        }

        private RequestResponse Unmount(string nodepath, ILockListTransaction lockList, ClientSession ses)
        {
            Node child = null;
            Node parent;
            child = this.Root.GetNode(nodepath, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.WRITE, out parent);

            if (child == null)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Nonode,
                    Stat = null,
                    Content = null
                };
            }

            IMountPointNode mp = child as IMountPointNode;
            if (mp == null)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Noauth,
                    Stat = null,
                    Content = null
                };
            }

            lockList.RunOnCommit(() =>
            {
                mp.Close();
            });

            RequestDelete del = new RequestDelete(nodepath, null, -1, null);

            return this.Delete(del, ses, lockList);
        }

        /// <summary>
        /// Imports a checkpoint from the given location, and terminates this process.
        /// </summary>
        /// <param name="location">The location of the checkpoint file.</param>
        /// <returns><c>true</c> if import succeeded and failover will happen soon, <c>false</c> otherwise.</returns>
        private bool ImportCheckpoint(string location)
        {
            bool result = false;
            try
            {
                if (!File.Exists(location))
                {
                    throw new FileNotFoundException("location");
                }

                result = this.Factory.ImportCheckpoint(location);

                if (!result)
                {
                    Trace.TraceWarning("ImportCheckpoint failed: Factory returned false");
                }
            }
            catch (Exception e)
            {
                Trace.TraceWarning("ImportCheckpoint failed: {0}", e);
            }

            return result;
        }

        /// <summary>
        /// Downloads the URL into the given location.
        /// </summary>
        /// <param name="urlAndDestination">The URL and the destination, encoded in an 'arguments' string.</param>
        /// <returns>true if the download was successful</returns>
        private bool DownloadUrlIntoLocation(string urlAndDestination)
        {
            DownloadUrlIntoLocationFunctionDelegate download = DownloadUrlIntoLocationFunction;

            if (download == null)
            {
                return false;
            }

            Task.Run(() =>
            {
                return download(urlAndDestination);
            });

            return true;
        }

        /// <summary>
        /// fails over the replica.
        /// It favors the replica passed as argument to take over primariness (not guaranteed).
        /// It stops the local service after the given time
        /// </summary>
        /// <param name="replicaToFailover">The replica to favor the failover.</param>
        /// <param name="delayBeforeStopServiceInMillis">The delay before stopping the service, in milliseconds. if Infinite, this means we don't want to stop the service explicitly here</param>
        /// <returns><c>true</c> if we were primary and the failover was issued, <c>false</c> otherwise.</returns>
        public bool FailoverInto(string replicaToFailover, int delayBeforeStopServiceInMillis = Timeout.Infinite)
        {
            // action to run when we are ready to go down.
            Action action = new Action( () =>
            {
                if (delayBeforeStopServiceInMillis != Timeout.Infinite)
                {
                    Thread.Sleep(delayBeforeStopServiceInMillis);
                    this.StopService();
                }
            });

            if (!this.IsPrimary())
            {
                action();
                return false;
            }

            if (delayBeforeStopServiceInMillis < 0)
            {
                delayBeforeStopServiceInMillis = 0;
            }

            ManualResetEvent evt = ManualResetEventPool.InstancePool.GetOne();

            this.Factory.FailoverInto(replicaToFailover, () =>
            {
                action();
                ManualResetEventPool.InstancePool.Set(evt);
            });

            ManualResetEventPool.InstancePool.WaitOneAndReturn(ref evt);

            return true;
        }

        public delegate string getSettingFunctionDelegate(string settingName);

        public delegate bool DownloadUrlIntoLocationFunctionDelegate(string urlAndDestination);

        /// <summary>
        /// the function to obtain a setting.
        /// </summary>
        private static getSettingFunctionDelegate getSettingFunction = null;

        /// <summary>
        /// Get or set the trace level for RingMasterBackendCore trace messages.
        /// </summary>
        public static TraceLevel TraceLevel
        {
            get
            {
                return RingMasterEventSource.Log.TraceLevel;
            }

            set
            {
                RingMasterEventSource.Log.TraceLevel = value;
            }
        }

        /// <summary>
        /// Gets a value indicating if poison pill are allowed
        /// </summary>
        private static bool ArePoisonPillAllowed
        {
            get
            {
                return GetSetting("RingMaster.AllowPoisonPills", bool.TryParse, false);
            }
        }

        /// <summary>
        /// Gets or sets the function to obtain a setting.
        /// </summary>
        /// <value>The GetSetting function.</value>
        public static getSettingFunctionDelegate GetSettingFunction
        {
            get
            {
                return getSettingFunction;
            }

            set
            {
                getSettingFunction = value;
                InitializeSettings();
            }
        }

        /// <summary>
        /// Gets or sets the function to download a URL into a location.
        /// </summary>
        /// <value>The function to download a URL into a location.</value>
        public static DownloadUrlIntoLocationFunctionDelegate DownloadUrlIntoLocationFunction { get; set; }

        /// <summary>
        /// gets a setting as indicated by the getsettingfunction
        /// </summary>
        /// <param name="settingName"></param>
        /// <returns></returns>
        internal static string GetSetting(string settingName)
        {
            getSettingFunctionDelegate getSettingFunction = GetSettingFunction;

            if (getSettingFunction == null)
            {
                return null;
            }
            try
            {
                return getSettingFunction(settingName);
            }
            catch
            {
                // ignore
            }
            return null;
        }

        /// <summary>
        /// parsing function delegate
        /// </summary>
        /// <typeparam name="T">the typed value</typeparam>
        /// <param name="str">The string value.</param>
        /// <param name="val">The typed value.</param>
        /// <returns><c>true</c> if the parsing succeeded, <c>false</c> otherwise.</returns>
        internal delegate bool TryParseFun<T>(string str, out T val);

        /// <summary>
        /// Gets the setting. provides a defaultValue and a stringToT parsing function.
        /// </summary>
        /// <typeparam name="T">the type of the setting value</typeparam>
        /// <param name="settingName">Name of the setting.</param>
        /// <param name="parse">The function to parse the value string into typed value.</param>
        /// <param name="defaultValue">The default value.</param>
        /// <returns>the typed value.</returns>
        internal static T GetSetting<T>(string settingName, TryParseFun<T> parse, T defaultValue)
        {
            T res;

            if (parse == null)
            {
                throw new ArgumentNullException("parse");
            }

            string fromConfig = GetSetting(settingName);

            if (fromConfig == null || !parse(fromConfig, out res))
            {
                return defaultValue;
            }

            return res;
        }

        protected RMCommands rmCommands { get; private set; }

        public string ReplicaCommandPathPrefix = "/$metadata/commands";

        /// <summary>
        /// Creates the specified req.
        /// </summary>
        /// <param name="request">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">The session's locklist.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Create(
            RequestCreate request,
            ClientSession session,
            ILockListTransaction lockList,
            string useEphemeralMountPointFactory = null)
        {
            ////Trace.TraceInformation($"Thread-{Thread.CurrentThread.ManagedThreadId} Create: {request.Path} - {hasAcquiredLocks}");

            CreateMode createMode = request.CreateMode;
            bool mustAllowPathCreation = createMode.HasFlag(CreateMode.AllowPathCreationFlag);
            bool mustSucceedEvenIfNodeExists = createMode.HasFlag(CreateMode.SuccessEvenIfNodeExistsFlag);
            bool isEphemeral = createMode.HasFlag(CreateMode.Ephemeral);
            bool isSequential = createMode.HasFlag(CreateMode.Sequential);

            // CreateMode.AllowPathCreationFlag is not compatible with CreateMode.Ephemeral or CreateMode.EphemeralSequential
            // because intermediate nodes (if any) would have to be created as persistent nodes.
            if (isEphemeral && mustAllowPathCreation)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Badarguments,
                    Stat = null,
                    Content = null
                };
            }

            if (rmCommands.IsCommand(request.Path))
            {
                RingMasterEventSource.Log.RequestCommand(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, request.Path);
                this.auditConsumer?.OnRequestCommand(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, request.Path);
                return rmCommands.RunCommand(request, session, lockList);
            }

            bool abort = true;
            try
            {
                Stopwatch timer = Stopwatch.StartNew();
                int parentlevel;
                string lastChildName;
                Node lastMatch;

                Node parent = this.Root.GetPathParent(request.Path, lockList, Node.WildCardBehavior.NotAllowed, out lastChildName, out lastMatch, out parentlevel);

                if (parent == null && mustAllowPathCreation)
                {
                    // create the whole path before the last one.
                    string[] pathpieces = request.Path.Split('/');

                    // we assume the path starts with a '/'
                    if (pathpieces.Length > 0 && String.Empty.Equals(pathpieces[0]))
                    {
                        // Intermediate parent nodes must be persistent (Ephemeral nodes can't have children and PersistentSequential does not make sense for parent nodes)
                        RequestCreate req1 = new RequestCreate(String.Empty, null, null, null, CreateMode.Persistent, null);

                        bool mustStop = false;
                        for (int i = 1; !mustStop && i < pathpieces.Length - 1; i++)
                        {
                            req1.Path = req1.Path + "/" + pathpieces[i];
                            Node pathNode = this.Root.GetNode(req1.Path, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.READ, out parent);
                            if (pathNode == null)
                            {
                                RequestResponse resp = this.Create(req1, session, lockList);

                                if (resp.ResultCode != (int)Code.Ok)
                                {
                                    mustStop = true;
                                }
                            }
                        }

                        parent = this.Root.GetPathParent(request.Path, lockList, Node.WildCardBehavior.NotAllowed, out lastChildName, out lastMatch, out parentlevel);
                    }
                }

                if (parent == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                if (string.IsNullOrEmpty(lastChildName))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                if (parent.Persisted.IsEphemeral)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nochildrenforephemerals,
                        Stat = null,
                        Content = null
                    };
                }

                if (this.limits.MaxNodeNameLength > 0 && lastChildName.Length > this.limits.MaxNodeNameLength && !SessionIsLimitExempt(session))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = string.Format("Node name exceeds maximum node name length of {0}", this.limits.MaxNodeNameLength)
                    };
                }

                if (request.Path != null && this.limits.MaxNodePathLength > 0 && request.Path.Length > this.limits.MaxNodePathLength && !SessionIsLimitExempt(session))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = string.Format("Node path length exceeds maximum of {0} characters", this.limits.MaxNodePathLength)
                    };
                }

                if (request.Data != null && this.limits.MaxNodeDataSize > 0 && request.Data.Length > this.limits.MaxNodeDataSize && !SessionIsLimitExempt(session))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = string.Format("Data size exceeds maximum of {0} bytes", this.limits.MaxNodeDataSize)
                    };
                }

                if (request.Acl != null)
                {
                    string aclValidationErrorMessage;
                    if (!this.ValidateAclLimits(request.Acl, session, out aclValidationErrorMessage))
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badarguments,
                            Stat = null,
                            Content = aclValidationErrorMessage
                        };
                    }
                }

                // req.Path is not / and lastChildName.Length > 0 at this point.
                string parentpath = request.Path.Substring(0, request.Path.Length - lastChildName.Length - 1);
                if (string.IsNullOrEmpty(parentpath))
                {
                    parentpath = "/";
                }

                IPersistedDataFactory<Node> persFact;

                if (!isEphemeral)
                {
                    persFact = this.Factory;
                }
                else
                {
                    if (useEphemeralMountPointFactory!=null)
                    {
                        persFact = this.EphemeralMountPointFactory(useEphemeralMountPointFactory);
                        persFact.Activate(this, this);
                    }
                    else
                    {
                        persFact = this.EphemeralFactory;
                    }
                }

                lockList.AddAndLockRw(parent, Perm.CREATE, parentlevel, isEphemeral);

                if (isSequential)
                {
                    lastChildName += parent.Persisted.Stat.Cversion.ToString("D10");
                }

                Node child = parent.TryGetChild(lastChildName, false);

                if (child != null)
                {
                    if (!isSequential && mustSucceedEvenIfNodeExists)
                    {
                        abort = false;

                        // this is truly a setdata operation, since the node already exists and it is allowed from createmode.
                        RequestSetData setdatarequest = new RequestSetData(
                            path: request.Path,
                            context: request.Context,
                            data: request.Data,
                            version: child.Persisted.Stat.Version,
                            callback: request.Callback == null
                                ? (StatCallbackDelegate)null
                                : (int rc, string path, object ctx, IStat stat) => { request.Callback(rc, path, ctx, null); },
                            dataCommand: false);
                        RequestResponse resp = this.SetData(setdatarequest, session, lockList);

                        if (resp.ResultCode == (int)Code.Ok)
                        {
                            // content will be null, indicating the creation was not needed, and this was a setdata operation
                            resp.Content = null;
                        }

                        return resp;
                    }
                    else
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nodeexists,
                            Stat = child.NodeStat,
                            Content = child.Name
                        };
                    }
                }

                IReadOnlyList<Acl> newAcl = null;
                if (request.Acl != null && request.Acl.Count > 0)
                {
                    newAcl = request.Acl;
                }

                IPersistedData childData = this.CreateData(persFact, lockList, lastChildName, newAcl, request.Data, (useEphemeralMountPointFactory != null));

                ((IUnsafeTreeAccess)this).UnsafeCreate(childData, lockList.TxTime, request.Path, lockList.TxId, lockList);

                child = childData.Node;

                // This is to verify ACL of the child node
                lockList.AddAndLockRw(child, Perm.WRITE, parentlevel + 1);

                IMutableStat prevStat = lockList.SnapStatIfNeeded(parent.Persisted);

                ((IUnsafeTreeAccess)this).UnsafeAddChild(parent.Persisted, child.Persisted, lockList.TxTime, parentpath, lockList.TxId, lockList);

                lockList.AppendCreate(persFact, childData, lockList.TxTime);
                lockList.AppendAddChild(parent.Persisted, childData, lockList.TxTime, prevStat);

                lockList.RunOnCommit(() =>
                {
                    if (child.Persisted.IsEphemeral)
                    {
                        RingMasterServerInstrumentation.Instance.UpdateEphemeralNodeCounts(this.EphemeralFactory.TotalData, this.EphemeralFactory.TotalNodes);
                    }
                    else
                    {
                        RingMasterServerInstrumentation.Instance.UpdatePersistentNodeCounts(this.Factory.TotalData, this.Factory.TotalNodes);
                    }

                    // if the child is ephemeral, we need to get rid of it when the session ends.
                    if (childData.IsEphemeral)
                    {
                        // make sure the path is right. Specially if this is sequential
                        string path = request.Path;

                        if (createMode.HasFlag(CreateMode.Sequential))
                        {
                            path = path.Substring(0, path.LastIndexOf('/')) + "/" + childData.Name;
                        }

                        session.AddOnTerminateAction("oid-" + child.GlobalUniqueId, (terminating) =>
                        {
                            Trace.TraceInformation("cleaning up ephemeral oid-{0} @ {1}", childData.Id, path);
                            Stopwatch sw = Stopwatch.StartNew();
                            int count = 0;

                            // This task is useless for ephemeral nodes, don't await it.
                            Task taskReplication;

                            while (null == BareProcessMessage(new RequestDelete(path, null, -1, null), session, ref sw, ref count, out taskReplication))
                            {
                                if (sw.ElapsedMilliseconds > s_maxRetryOperationMillis)
                                {
                                    Trace.TraceError("We couldn't cleanup the ephemeral oid-{0} @ {1} on time", childData.Id, path);
                                    Debugger.Launch();
                                    break;
                                }
                            }
                        });
                    }
                });

                abort = false;
                timer.Stop();

                RingMasterEventSource.Log.RequestCreateSucceeded(session.SessionId, request.Uid, request.Path, timer.ElapsedMilliseconds);
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = child.Name
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestCreateFailed(session.SessionId, request.Uid, request.Path, ex.ToString());
                }
                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Completes the change.
        /// </summary>
        /// <param name="pd">the persisted data object to update</param>
        /// <param name="zxid">The zxid.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="chg">The CHG.</param>
        private void UpdateStat(IPersistedData pd, long zxid, long txtime, ChangeKind chg, int delta = 0)
        {
            if (pd == null)
            {
                throw new ArgumentNullException("pd");
            }

            IMutableStat stat = pd.Stat;

            if (chg != ChangeKind.NodeCreated)
            {
                stat = CompleteNode.EnsureCompleteStat(pd);
                stat.Mtime = txtime;
                stat.Mzxid = zxid;
            }

            switch (chg)
            {
                case ChangeKind.ChildrenAdded:
                    stat.NumChildren++;
                    stat.Cversion++;
                    stat.Pzxid = zxid;
                    break;
                case ChangeKind.ChildrenRemoved:
                    stat.NumChildren--;
                    stat.Cversion++;
                    stat.Pzxid = zxid;
                    break;
                case ChangeKind.DataChanged:
                    stat.Version++;
                    stat.DataLength += delta;
                    RmAssert.IsTrue(pd.Stat.DataLength >= 0);
                    break;
                case ChangeKind.AclChanged:
                    stat.Aversion++;
                    break;
                case ChangeKind.NodeDeleted:
                    stat.Version++;
                    break;
                case ChangeKind.NodeCreated:
                case ChangeKind.None:
                    break;
            }

            pd.Stat = stat;
        }

        /// <summary>
        /// Executes the specified req.
        /// </summary>
        /// <param name="request">The req.</param>
        /// <param name="session">the session</param>
        /// <param name="lockList">The session's lockList.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Multi(RequestMulti request, ClientSession session, ILockListTransaction lockList)
        {
            RingMasterEventSource.Log.Multi(request.Uid, request.Requests.Count, request.CompleteSynchronously);

            // For multi the request can set synchronous commit.
            // Note that if we have nested multis we must complete synchronously if any of the multis
            // have the synchronous flag set so we never flip synchronous to asynchronous.
            if (!lockList.FinishSynchronous)
            {
                lockList.FinishSynchronous = request.CompleteSynchronously;
            }

            if (request.ScheduledName != null)
            {
                return this.ScheduleMulti(request, session, lockList);
            }

            List<OpResult> results = new List<OpResult>();

            // No need to do the "lock round" if RO interface does not require locks.
            // However still need "lock round" for read operations for RW interface because we may
            // take read lock on /y while another thread takes write lock on /x. We then try to
            // read lock /x and the other thread write lock /y and we have deadlock.
            if (session.ROInterfaceRequiresLocks)
            {
                // lock IN ORDER the accessed paths
                this.LockMultiPathsInOrder(request, lockList);
            }

            var timer = Stopwatch.StartNew();

            // now execute the operations as specified in the request.
            // Note: more locking may happen if op1 is create 'some/path' and op2 is create 'some/path/later'
            for (int i = 0; i < request.Requests.Count; i++)
            {
                IRingMasterBackendRequest innerRequest = request.Requests[i];

                RequestResponse response = this.ValidateRequest(innerRequest, session);

                if (response == null)
                {
                    response = this.DispatchRequest(innerRequest, session, lockList);
                }

                OpResult opr = OpResult.GetOpResult(innerRequest.RequestType, response);

                results.Add(opr);

                if (timer.ElapsedMilliseconds > s_maxRetryOperationMillis)
                {
                    lockList.MarkForAbort();
                    RingMasterEventSource.Log.MultiTimeout(request.Uid, request.Requests.Count, i, timer.ElapsedMilliseconds);
                    break;
                }

                if (lockList.IsMarkedForAbort())
                {
                    break;
                }

                if (opr.ErrCode != Code.Ok)
                {
                    lockList.MarkForAbort();
                    break;
                }
            }

            return new RequestResponse()
            {
                ResultCode = (int)Code.Ok,
                Stat = default(Stat),
                Content = results
            };
        }

        /// <summary>
        /// Schedules the multi.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">The lock list.</param>
        /// <returns>RequestResponse.</returns>
        /// <exception cref="System.NotImplementedException"></exception>
        private RequestResponse ScheduleMulti(RequestMulti req, ClientSession session, ILockListTransaction lockList)
        {
            string scheduledName = req.ScheduledName;
            req.ScheduledName = null;

            Stopwatch timer = Stopwatch.StartNew();
            IRingMasterBackendRequest[] reqs = new IRingMasterBackendRequest[1];
            reqs[0] = new RequestCreate(ScheduledCommand.GetCommandPath(scheduledName), null, ScheduledCommand.GetBytes(req, new MarshallerChannel(null)), null, CreateMode.Persistent, null);
            RequestResponse response = this.Multi(new RequestMulti(reqs, context: null, callback: (OpsResultCallbackDelegate)null, completeSynchronously: req.CompleteSynchronously, scheduledName: null), session, lockList);

            RingMasterEventSource.Log.ScheduleMultiCompleted(session.SessionId, req.Uid, scheduledName, timer.ElapsedMilliseconds);
            return response;
        }

        /// <summary>
        /// Executes the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">the session</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Batch(RequestBatch req, ClientSession session)
        {
            RingMasterEventSource.Log.Batch(req.Uid, req.Requests.Count, req.CompleteSynchronously);

            bool needsSync = req.CompleteSynchronously;

            List<OpResult> results = new List<OpResult>(req.Requests.Count);

            Stopwatch timer = Stopwatch.StartNew();
            // If the request is associated with the transaction manager execution queue, then the request
            // came from the transaction manager.
            bool isFromTransactionManager = (req.ExecutionQueueId == TransactionManagerExecutionQueueId) || (req.Auth?.ClientIdentity == "TransactionManager");
            ulong batchId = req.Uid;
            ulong timeStreamId = req.TimeStreamId;
            ulong minTransactionId = ulong.MaxValue;
            ulong maxTransactionId = ulong.MinValue;
            ulong transactionId = ulong.MinValue;
            TimeStreamInfo timeStream = null;

            // If the request came from the transaction manager, verify that
            // the request's batch id is strictly one more than the last applied batch id
            // This will ensure that batches are applied in the order that they are supposed to be
            // applied and the same batch is not applied twice.
            if (isFromTransactionManager)
            {
                lock (this.timeStreamInfo)
                {
                    if (!this.timeStreamInfo.TryGetValue(timeStreamId, out timeStream))
                    {
                        timeStream = new TimeStreamInfo();
                        this.timeStreamInfo.Add(timeStreamId, timeStream);
                    }
                }

                if ((timeStream.LastAppliedBatchId != ulong.MaxValue) && (batchId != timeStream.LastAppliedBatchId + 1))
                {
                    RingMasterEventSource.Log.ApplyBatch_BatchIdNotInSequence(timeStreamId, batchId, timeStream.LastAppliedBatchId);
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Apierror
                    };
                }
            }

            // now execute the operations as specified in the request.
            for (int i = 0; i < req.Requests.Count; i++)
            {
                IRingMasterBackendRequest req_i = req.Requests[i];

                OpResult opr;

                RequestResponse res = ValidateRequest(req_i, session);

                if (res == null)
                {
                    bool previousValueForRequestSynchronous = false;

                    bool isLast = (i == req.Requests.Count - 1);

                    OverrideRequestSynchronization(req_i, isLast, ref previousValueForRequestSynchronous, ref needsSync);

                    // If the batch came from the transaction manager, Verify that each request in the batch is in
                    // strictly increasing order of transaction ids and the first transaction id in the batch is exactly
                    // one more than the last transaction that was applied.
                    if (isFromTransactionManager && (req_i.Overrides != null))
                    {
                        transactionId = req_i.Overrides.TxId;

                        minTransactionId = Math.Min(minTransactionId, transactionId);
                        maxTransactionId = Math.Max(maxTransactionId, transactionId);

                        if (timeStream.LastSeenTransactionId != ulong.MaxValue)
                        {
                            // We are applying a batch where each request in the batch has a transaction id.  The requests in the batch
                            // are applied one after the other.  Each request's transaction id must be strictly one more than the transaction id
                            // of the previous request seen for this time stream.  The transaction Id of the last *successful* request is recorded in a node in this RM. When the
                            // TM retries a batch, it reads the last successful transaction id from RM and issues the retry.  In that case, the transaction id
                            // in the batch may be less than what we expect.  When that happens, we increment a counter.
                            if (transactionId != timeStream.LastSeenTransactionId + 1)
                            {
                                RingMasterEventSource.Log.ApplyBatch_ExternalTransactionIdNotInSequence(timeStreamId, batchId, transactionId, timeStream.LastSeenTransactionId);
                                RingMasterServerInstrumentation.Instance.OnIncorrectExternalTransactionId(transactionId, timeStream.LastSeenTransactionId + 1);
                            }
                        }

                        timeStream.LastSeenTransactionId = transactionId;
                    }

                    // If the individual request within the batch does not have its own auth,
                    // set the auth from the batch request.
                    if (req_i.Auth == null)
                    {
                        req_i.Auth = req.Auth;
                    }

                    res = ProcessMessage(req_i, session);

                    RestoreRequestSynchronization(req_i, previousValueForRequestSynchronous);
                }

                opr = OpResult.GetOpResult(req_i.RequestType, res);

                // If the first request in the batch has succeeded then mark this batch id as the last
                // applied batch id.
                if ((i == 0) && isFromTransactionManager && (opr.ErrCode == Code.Ok))
                {
                    RmAssert.IsTrue(opr.ResultType == OpCode.SetData);
                    timeStream.LastAppliedBatchId = batchId;
                }

                results.Add(opr);

                if (timer.ElapsedMilliseconds > s_maxRetryOperationMillis)
                {
                    RingMasterEventSource.Log.BatchTimeout(batchId, req.Requests.Count, i, timer.ElapsedMilliseconds);
                    break;
                }

                // If the result of the request came back as OperationCancelled, that means the server is shutting down and
                // we need to stop processing. We'll return whatever results we have accumulated so far, but the client
                // cannot necessarily rely on them because we don't actually honor synchronous commit until the end
                if (res.ResultCode == (int)Code.OperationCancelled)
                {
                    if (isFromTransactionManager)
                    {
                        RingMasterEventSource.Log.ApplyBatchAborted(timeStreamId, batchId, minTransactionId, maxTransactionId, transactionId, timer.ElapsedMilliseconds);
                    }

                    return new RequestResponse
                    {
                        ResultCode = (int)Code.OperationCancelled,
                        Stat = default(Stat),
                        Content = results
                    };
                }
            }

            if (needsSync)
            {
                RequestSetData multi = new RequestSetData("/$metadata/synchronization/$syncpoint", null, null, -1, null);
                ProcessMessage(new RequestMulti(new IRingMasterBackendRequest[] { multi }, null, null, true), session);
            }

            if (isFromTransactionManager)
            {
                RingMasterServerInstrumentation.Instance.OnTransactionManagerBatchApplied(batchId, maxTransactionId);
                RingMasterEventSource.Log.ApplyBatchSucceeded(timeStreamId, batchId, minTransactionId, maxTransactionId, timer.ElapsedMilliseconds);
            }

            return new RequestResponse()
            {
                ResultCode = (int)Code.Ok,
                Stat = default(Stat),
                Content = results
            };
        }

        /// <summary>
        /// changes the synchroniozation requirements on the request based on wether this is the last request in a series,
        /// wether the current request requires or not synchronization, and if the series requires final synchronization.
        /// The table is as follows:
        ///   isLast    needsSync   r.CompleteSynchronously || r.CompleteSynchronously'    needsSync'
        /// ------------------------------------------------||-----------------------------------------
        ///     0          0               0                ||           0                     0
        ///     0          0               1                ||           0                     1
        ///     0          1               0                ||           0                     1
        ///     0          1               1                ||           0                     1
        ///     1          0               0                ||           0                     0
        ///     1          0               1                ||           1                     0
        ///     1          1               0                ||           1                     1
        ///     1          1               1                ||           1                     0
        /// The goal is for a series of operations, have at most ONE synchronization, and at the very end of the series,
        /// and if possible, not adding any additional artificial synchronization.
        /// </summary>
        /// <param name="r"></param>
        /// <param name="isLast"></param>
        /// <param name="previousValueForRequestSynchronous"></param>
        /// <param name="needsSync"></param>
        private void OverrideRequestSynchronization(IRingMasterBackendRequest r, bool isLast, ref bool previousValueForRequestSynchronous, ref bool needsSync)
        {
            // by default, request not multi or batch are async
            previousValueForRequestSynchronous = false;

            if (r.RequestType == RingMasterRequestType.Multi || r.RequestType == RingMasterRequestType.Batch)
            {
                IRingMasterBackendCompondRequest m = (IRingMasterBackendCompondRequest)r;

                previousValueForRequestSynchronous = m.CompleteSynchronously;

                m.CompleteSynchronously = isLast && (needsSync || previousValueForRequestSynchronous);

                if (previousValueForRequestSynchronous != m.CompleteSynchronously)
                {
                    PushDeepCompleteSynchronously(m);
                }
            }

            needsSync = (!isLast && (needsSync || previousValueForRequestSynchronous)) ||
                        (isLast && needsSync && !previousValueForRequestSynchronous);
        }

        private void PushDeepCompleteSynchronously(IRingMasterBackendCompondRequest m)
        {
            Debug.Assert(m != null, "m cannot be null");

            foreach (IRingMasterBackendRequest r in m.Requests)
            {
                if (r == null)
                {
                    continue;
                }

                if (r.RequestType == RingMasterRequestType.Multi || r.RequestType == RingMasterRequestType.Batch)
                {
                    IRingMasterBackendCompondRequest n = (IRingMasterBackendCompondRequest)r;

                    n.CompleteSynchronously = m.CompleteSynchronously;
                    PushDeepCompleteSynchronously(n);
                }
            }
        }

        /// <summary>
        /// restores a previously stored synchronization requirement for a request
        /// </summary>
        /// <param name="r"></param>
        /// <param name="previousValueForRequestSynchronous"></param>
        private void RestoreRequestSynchronization(IRingMasterBackendRequest r, bool previousValueForRequestSynchronous)
        {
            Debug.Assert(r != null, "r cannot be null");

            if (r.RequestType == RingMasterRequestType.Multi || r.RequestType == RingMasterRequestType.Batch)
            {
                ((IRingMasterBackendCompondRequest)r).CompleteSynchronously = previousValueForRequestSynchronous;
            }
        }

        /// <summary>
        /// locks the proper paths for a multi request, including nested multis if needed, and considering RO vs RW locks,
        /// and normalizing the path order.
        /// </summary>
        /// <param name="req">multi request</param>
        /// <param name="lockList">locklist giving context to this call</param>
        private void LockMultiPathsInOrder(RequestMulti req, ILockListTransaction lockList)
        {
            Dictionary<string, IRingMasterBackendRequest> set = new Dictionary<string, IRingMasterBackendRequest>(req.Requests.Count);

            var pending = new Stack<RequestMulti>(req.Requests.Count);
            pending.Push(req);

            while (pending.Count > 0)
            {
                RequestMulti top = pending.Pop();
                foreach (var r in top.Requests)
                {
                    bool isMulti;
                    bool hasWatcher;
                    bool isReadOnly = this.IsReadOnlyRequest(r, out isMulti, out hasWatcher);

                    if (isMulti)
                    {
                        pending.Push((RequestMulti)r);
                    }
                    else
                    {
                        // skip empty paths
                        if (string.IsNullOrEmpty(r.Path))
                        {
                            continue;
                        }

                        // if the request is RW, we need to override the existing one with this.
                        // (if the existing was RO, it will not be RW, otherwise, we are replacing a RW with another RW, which is harmless)
                        if (!isReadOnly)
                        {
                            set[r.Path] = r;
                        }
                        else
                        {
                            // if the request is RO, we need to insert it only if there is no other previous request for this path.
                            if (!set.ContainsKey(r.Path))
                            {
                                set.Add(r.Path, r);
                            }
                        }
                    }
                }
            }

            // now we have "set" with exactly one request per path. And requests are either RW or RO, whichever was higher.
            // we will build a sorted list with those now.
            List<IRingMasterBackendRequest> order = new List<IRingMasterBackendRequest>(set.Count);
            foreach(IRingMasterBackendRequest r in set.Values)
            {
                order.Add(r);
            }

            order.Sort((r1, r2) =>
            {
                return string.Compare(r1.Path, r2.Path);
            });

            // finally, we iterate on the sorted list, and take the locks.
            foreach (IRingMasterBackendRequest r in order)
            {
                bool isMulti;
                bool hasWatcher;
                bool isReadOnly = IsReadOnlyRequest(r, out isMulti, out hasWatcher);

                Node parent;
                Perm perm = isReadOnly ? Perm.READ : Perm.WRITE;

                // Note: Need perm for both node and parent to ensure write lock is taken on both. If we are doing
                // create or delete both the child and parent need to be write locked. At some point we may choose to
                // optimize this by not obtaining parent write lock for SetData/SetAcl/etc. but that will require
                // improving the sorting to put create/delete first to ensure we always take write lock before read lock
                // because upgrade to write lock puts you at the end of the writer queue.
                this.Root.GetNode(r.Path, lockList, Node.WildCardBehavior.AllowAnywhere, perm, perm, out parent);
            }
        }

        /// <summary>
        /// Locks the root.
        /// </summary>
        void IUnsafeTreeAccess.LockRoot()
        {
            if (this.Root != null)
            {
                Trace.TraceInformation("locking root...");

                // lock the root. we are secondary and all replication is being blocked by the replication backend already.
                ((IUnsafeTreeAccess)this).LockRootNoSync();
                Trace.TraceInformation("root sync ready");
            }
        }

        private ILockObject rootLock = null;

        /// <summary>
        /// Locks the root without synchronizing it.
        /// </summary>
        void IUnsafeTreeAccess.LockRootNoSync()
        {
            if (this.Root != null)
            {
                rootLock = this.Root.AcquireLockRw(0);
            }
        }

        /// <summary>
        /// Releases the root.
        /// </summary>
        void IUnsafeTreeAccess.ReleaseRoot()
        {
            if (this.Root != null)
            {
                rootLock.ReleaseWriterLock();
            }
        }

        /// <summary>
        /// Move the specified node.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">the sessions locklist</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Move(RequestMove req, ClientSession session, ILockListTransaction lockList)
        {
            bool abort = true;
            try
            {
                Node parentSrc;
                Node child;

                {
                    int childlevel;

                    // no no no, you cannot move commands
                    if (rmCommands.IsCommand(req.Path))
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badarguments,
                            Stat = null,
                            Content = null
                        };
                    }

                    child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.NotAllowed, Perm.WRITE, Perm.DELETE, out parentSrc, out childlevel);

                    if (child == null)
                    {
                        // not found
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nonode,
                            Stat = null,
                            Content = null
                        };
                    }

                    if (req.Version != -1)
                    {
                        // if the user cares about the version check it
                        if (!child.IsVersion(req.Version))
                        {
                            // grong version
                            return new RequestResponse()
                            {
                                ResultCode = (int)Code.Badversion,
                                Stat = null,
                                Content = null
                            };
                        }
                    }

                    /// no no no no... you cannot move the root!
                    if (parentSrc == null)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badarguments,
                            Stat = null,
                            Content = $"Can't move a node whose parent is null. Node level: {childlevel}, Node name: {child.Name}."
                        };
                    }

                    if (!child.IsEmpty())
                    {
                        if ((req.MoveMode & MoveMode.OnlyIfSourcePathIsEmpty) == MoveMode.OnlyIfSourcePathIsEmpty)
                        {
                            return new RequestResponse()
                            {
                                ResultCode = (int)Code.Notempty,
                                Stat = null,
                                Content = null
                            };
                        }
                    }
                }
                // source node is ready.

                // now get the destination node.
                Node parentDst = null;
                int parentDstlevel=0;

                {
                    Node ignore;

                    parentDst = this.Root.GetNode(req.PathDst, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.CREATE, out ignore, out parentDstlevel);

                    if (parentDst == null && ((req.MoveMode & MoveMode.AllowPathCreationFlag) == MoveMode.AllowPathCreationFlag))
                    {
                        RequestCreate req1 = new RequestCreate(req.PathDst, null, null, null, CreateMode.PersistentAllowPathCreation, null);

                        RequestResponse resp = this.DispatchRequest(req1, session, lockList);

                        if (resp.ResultCode != (int)Code.Ok)
                        {
                            return resp;
                        }

                        parentDst = this.Root.GetNode(req.PathDst, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.CREATE, out ignore, out parentDstlevel);
                    }

                    if (parentDst == null)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nonode,
                            Stat = null,
                            Content = null
                        };
                    }

                    if (parentDst.Persisted.IsEphemeral)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nochildrenforephemerals,
                            Stat = null,
                            Content = null
                        };
                    }
                }

                // now we are ready for deletion
                {
                    // the destination path for the creation has the name of the moved child
                    string finalDstName = req.PathDst + (req.PathDst == "/" ? "" : "/") + child.Name;

                    // 1. Check child name doesn't exist in destination path
                    Node childDst = parentDst.TryGetChild(child.Name, false);

                    if (childDst != null)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nodeexists,
                            Stat = null,
                            Content = null
                        };
                    }

                    // 2. lock the parent at destination for writes
                    lockList.AddAndLockRw(parentDst, Perm.CREATE, parentDstlevel, child.Persisted.IsEphemeral);

                    // 3. save old stats
                    IMutableStat prevStatParentSrc = lockList.SnapStatIfNeeded(parentSrc.Persisted);
                    IMutableStat prevStatParentDst = lockList.SnapStatIfNeeded(parentDst.Persisted);
                    IMutableStat prevChildStat = lockList.SnapStatIfNeeded(child.Persisted);

                    // 4. move the node
                    string parentSrcpath = req.Path.Substring(0, req.Path.Length - child.Name.Length);
                    string parentDstpath = req.PathDst;

                    ((IUnsafeTreeAccess)this).UnsafeRemoveChild(parentSrc.Persisted, child.Persisted, lockList.TxTime, parentSrcpath, lockList.TxId, lockList);

                    ((IUnsafeTreeAccess)this).UnsafeAddChild(parentDst.Persisted, child.Persisted, lockList.TxTime, parentDstpath, lockList.TxId, lockList);

                    lockList.AppendMove(parentSrc.Persisted, parentDst.Persisted, child.Persisted, lockList.TxTime, prevChildStat, prevStatParentSrc, prevStatParentDst);

                    abort = false;

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Ok,
                        Stat = child.NodeStat,
                        Content = finalDstName
                    };
                }
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Deletes the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">the sessions locklist</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Delete(RequestDelete req, ClientSession session, ILockListTransaction lockList)
        {
            bool abort = true;
            try
            {
                Node parent;

                int childlevel;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.NotAllowed, Perm.WRITE, Perm.DELETE, out parent, out childlevel);

                if (child == null)
                {
                    if ((req.DeleteMode & DeleteMode.SuccessEvenIfNodeDoesntExist) == DeleteMode.SuccessEvenIfNodeDoesntExist)
                    {
                        abort = false;

                        // note stat will be null indicating the delete was not needed
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Ok,
                            Stat = null,
                            Content = null
                        };
                    }

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                if (!child.IsVersion(req.Version))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = child.NodeStat,
                        Content = null
                    };
                }

                /// no no no no... you cannot delete the root!
                if (parent == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = child.NodeStat,
                        Content = $"Can't remove a node whose parent is null. Node level: {childlevel}, Node name: {child.Name}."
                    };
                }

                //int parentLevel = parent.GetLevel();
                //parent.LockWrite(lockList, Perm.DELETE, parentLevel);

                if (!child.IsEmpty())
                {
                    if (!req.IsCascade)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Notempty,
                            Stat = child.NodeStat,
                            Content = null
                        };
                    }

                    if (!req.DeleteMode.HasFlag(DeleteMode.FastDelete) || DeleteTask.RequiresIndividualDeletes(this))
                    {
                        // Slow delete
                        this.UnsafeDeleteChildren(lockList, session, req.Path.Substring(0, req.Path.LastIndexOf('/')), child, childlevel);
                        this.DeleteEmptyNode(lockList, session, parent, req.Path, child);
                    }
                    else
                    {
                        // Fast delete
                        this.DoFastDelete(lockList, session, parent, req.Path, child);
                    }
                }
                else
                {
                    this.DeleteEmptyNode(lockList, session, parent, req.Path, child);
                }

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = null
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestDeleteFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        private void DoFastDelete(ILockListTransaction lockList, ClientSession session, Node parent, string childpath, Node child)
        {
            IMutableStat prevChildStat = lockList.SnapStatIfNeeded(child.Persisted);
            IMutableStat prevParentStat = lockList.SnapStatIfNeeded(parent.Persisted);

            DeleteTask cnt = new DeleteTask(lockList, session, this, child);
            cnt.DeleteNodesRecursively();
            ((IUnsafeTreeAccess)this).UnsafeRemove(parent.Persisted, child.Persisted, lockList.TxTime, childpath, lockList.TxId, lockList);
        }

        private class DeleteTask
        {
            private readonly ILockListTransaction lockList;
            private readonly ClientSession session;
            private readonly bool anyBulkWatcher;
            private readonly RingMasterBackendCore backend;
            private readonly Node topNode;
            private Node node;
            private int numPersistent;
            private int dataPersistent;

            public static bool RequiresIndividualDeletes(RingMasterBackendCore backend)
            {
                return backend.EphemeralFactory.RequiresCallsForEachDelete || backend.Factory.RequiresCallsForEachDelete;
            }

            public DeleteTask(ILockListTransaction lockList, ClientSession session, RingMasterBackendCore backend, Node child)
            {
                if (RequiresIndividualDeletes(backend))
                {
                    throw new InvalidOperationException("fast delete is only for factories not requiring individual deletes");
                }

                this.backend = backend;
                this.lockList = lockList;
                this.session = session;
                this.anyBulkWatcher = ClientSession.AnyBulkWatcher(child.BuildPath());
                this.topNode = this.node = child;
                numPersistent = 0;
                dataPersistent = 0;
            }

            public void DeleteNodesRecursively()
            {
                this.InternalDeleteNodesRecursively();

                lockList.AppendRemoveNodeAndAllChildren(this.topNode.Persisted, lockList.TxTime, null);

                lockList.RunOnCommit(() =>
                {
                    // we didn't remove the stats as we browsed the tree,
                    // so during "commit", we need to correct the stats
                    this.backend.Factory.RecordStatsDelta(-this.numPersistent, -this.dataPersistent);

                    RingMasterServerInstrumentation.Instance.UpdateEphemeralNodeCounts(this.backend.EphemeralFactory.TotalData, this.backend.EphemeralFactory.TotalNodes);
                    RingMasterServerInstrumentation.Instance.UpdatePersistentNodeCounts(this.backend.Factory.TotalData, this.backend.Factory.TotalNodes);
                });
            }

            private void InternalDeleteNodesRecursively()
            {
                IPersistedData pd = this.node.Persisted;

                if (pd.IsEphemeral)
                {
                    this.lockList.RunOnCommit(() =>
                    {
                        session.RemoveOnTerminateAction("oid-" + this.node.GlobalUniqueId);
                    });
                }
                else
                {
                    if (this.topNode != this.node)
                    {
                        this.numPersistent++;
                        this.dataPersistent += pd.Stat.DataLength;
                    }
                }

                if (this.anyBulkWatcher || this.node.HasWatchers())
                {
                    // note we will call BuildPath for every node with watcher. That is a good choice if there is not that many nodes with watchers.
                    this.node.ScheduleTriggerWatchers(ChangeKind.NodeDeleted, this.node.BuildPath(), this.lockList);
                }

                if (!this.node.IsEmpty())
                {
                    // note this.node will change as per the recursion from this point on, so we should not make assumptions about its value anymore
                    // and use only pd.Node
                    foreach (IPersistedData child in ((CompleteNode)pd.Node).ChildrenNodes)
                    {
                        this.node = child.Node;
                        this.InternalDeleteNodesRecursively();
                    }
                }
            }
        }

        private void DeleteEmptyNode(ILockListTransaction lockList, ClientSession session, Node parent, string childpath, Node child)
        {
            IMutableStat prevChildStat = lockList.SnapStatIfNeeded(child.Persisted);
            IMutableStat prevParentStat = lockList.SnapStatIfNeeded(parent.Persisted);

            ((IUnsafeTreeAccess)this).UnsafeRemove(parent.Persisted, child.Persisted, lockList.TxTime, childpath, lockList.TxId, lockList);

            lockList.AppendRemove(parent.Persisted, child.Persisted, lockList.TxTime, prevChildStat, prevParentStat,
                () =>
                {
                    if (child.Persisted.IsEphemeral)
                    {
                        this.EphemeralFactory.RecordNodeUndelete(child.Persisted);
                    }
                    else
                    {
                        this.Factory.RecordNodeUndelete(child.Persisted);
                    }
                });

            lockList.RunOnCommit(() =>
            {
                if (child.Persisted.IsEphemeral)
                {
                    RingMasterServerInstrumentation.Instance.UpdateEphemeralNodeCounts(this.EphemeralFactory.TotalData, this.EphemeralFactory.TotalNodes);
                }
                else
                {
                    RingMasterServerInstrumentation.Instance.UpdatePersistentNodeCounts(this.Factory.TotalData, this.Factory.TotalNodes);
                }
                session.RemoveOnTerminateAction("oid-" + child.GlobalUniqueId);
            });
        }

        private void UnsafeDeleteChildren(ILockListTransaction lockList, ClientSession session, string parentpath, Node node, int childLevel)
        {
            string childpath = parentpath + "/" + node.Name;
            lockList.AddAndLockRw(node, Perm.DELETE, childLevel);

            var completeNode = node as CompleteNode;
            if (completeNode != null)
            {
                var childrenPersistedData = completeNode.ChildrenNodes.ToList();
                foreach (var pd in childrenPersistedData)
                {
                    if (pd.GetChildrenCount() != 0)
                    {
                        this.UnsafeDeleteChildren(lockList, session, childpath, pd.Node, childLevel + 1);
                    }

                    this.DeleteEmptyNode(lockList, session, node, childpath + "/" + pd.Name, pd.Node);
                }
            }
        }

        /// <summary>
        /// Checks the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Check(RequestCheck req, ILockListTransaction lockList)
        {
            bool abort = true;
            try
            {
                Node parent;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.AllowInBranch, Perm.READ, Perm.READ, out parent);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                if (!child.IsVersion(req.Version, req.UniqueIncarnationId, req.UniqueIncarnationIdKind))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = child.NodeStat,
                        Content = null
                    };
                }

                if (!child.IsChildVersion(req.CVersion))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = child.NodeStat,
                        Content = null
                    };
                }

                if (!child.IsAclVersion(req.AVersion))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = child.NodeStat,
                        Content = null
                    };
                }

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = null
                };
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Existses the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">The session's locklist</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Exists(RequestExists req, ClientSession session, ILockListTransaction lockList)
        {
            bool abort = true;
            try
            {
                Node parent;

                bool bulkWatcherSpecifierWasPresent = false;
                string path = BulkOperation.RemoveBulkWatcherSpecifier(req.Path, out bulkWatcherSpecifierWasPresent);

                Node child = this.Root.GetNode(path, lockList, Node.WildCardBehavior.AllowInBranch, Perm.READ, Perm.READ, out parent);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                RegisterWatcherOnNode(req.Watcher, session, lockList, req.Path, child);

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Content = child.NodeStat,
                    Stat = null
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestExistsFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }
                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// if true, we will enable debugging of the watcher locations
        /// </summary>
        private static bool s_debugWatcherLocations;

        /// <summary>
        /// if true, psudonodes will be disabled
        /// </summary>
        private static bool s_dontStartPseudoNodes;

        /// <summary>
        /// maximum time we can spend retrying on an operation.
        /// </summary>
        internal static int s_maxRetryOperationMillis;

        /// <summary>
        /// A request is considered a long running request if it takes more than this time to complete.
        /// </summary>
        internal static TimeSpan s_longRunningRequestThreshold;

        static RingMasterBackendCore()
        {
            // this will load the defaults
            InitializeSettings();
        }

        /// <summary>
        /// Initializes the settings based on the current GetSetting function, and sets default appropriatedly
        /// </summary>
        private static void InitializeSettings()
        {
            s_debugWatcherLocations = GetSetting("RingMaster.DebugWatcherLocations", bool.TryParse, false);

            s_dontStartPseudoNodes = GetSetting("RingMaster.DontStartPseudoNodes", bool.TryParse, false);

            s_maxRetryOperationMillis = GetSetting("RingMaster.MaxRetryOperationMillis", int.TryParse, 2500);

            Node.MaxAcquireRWLockTime = TimeSpan.FromMilliseconds(GetSetting("RingMaster.MaxAcquireRWLockTimeMillis", int.TryParse, 500));

            // By default, the long running request threshold is high to reduce log spew.  It can be reduced to the desired value to debug
            // requests that take more than the expected time.
            s_longRunningRequestThreshold = TimeSpan.FromMilliseconds(GetSetting("RingMaster.LongRunningRequestThreshold", int.TryParse, 100000));
        }

        /// <summary>
        /// Registers the watcher on node.
        /// </summary>
        /// <param name="reqWatcher">The req watcher.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">the lock list for the session</param>
        /// <param name="path">The path.</param>
        /// <param name="child">The child.</param>
        private static void RegisterWatcherOnNode(IWatcher reqWatcher, ClientSession session, ILockListTransaction lockList, string path, Node child)
        {
            // we don't do anything if this session is a RO lockless.
            if (!session.writesAllowed || !session.ROInterfaceRequiresLocks)
            {
                return;
            }

            lockList.RunOnCommit(() =>
            {
                RegisterWatcherOnNodeDuringCommit(reqWatcher, session, path, child);
            });
        }

        /// <summary>
        /// Registers the watcher on node.
        /// </summary>
        /// <param name="reqWatcher">The req watcher.</param>
        /// <param name="session">The session.</param>
        /// <param name="path">The path.</param>
        /// <param name="child">The child.</param>
        private static void RegisterWatcherOnNodeDuringCommit(IWatcher reqWatcher, ClientSession session, string path, Node child)
        {
            MarshallerChannel.ProxyWatcher pxw = reqWatcher as MarshallerChannel.ProxyWatcher;

            if (pxw == null && reqWatcher != null)
            {
                pxw = new MarshallerChannel.FakeProxyWatcher(reqWatcher, path);
            }

            bool bulkWatcherSpecifierWasPresent = false;
            path = BulkOperation.RemoveBulkWatcherSpecifier(path, out bulkWatcherSpecifierWasPresent);

            bool isBulk = bulkWatcherSpecifierWasPresent || BulkOperation.IsBulkWatcher(path);

            // if the watcher is NOT installed on a bulkWatcher node:
            if (!isBulk)
            {
                string id = child.GlobalUniqueId;

                // remove -if it exists- any watcher that was installed in this node by this session.
                if (session.HasOnTerminateActions)
                {
                    Action<bool> previous;
                    if (session.TryRemoveOnTerminateAction("watcher-" + id, out previous))
                    {
                        // this will remove the watcher from the child as well
                        previous(false);
                    }
                }

                //if this is uninstallation of a watcher... we are done
                if (pxw == null)
                {
                    return;
                }

                //now, add the watcher to the child
                string tostring = null;

                if (s_debugWatcherLocations)
                {
                    tostring = string.Format("{0}:{1} {2}", path, session.Auth.ClientDigest, isBulk ? "Bulk" : "");
                    RingMasterEventSource.Log.WatcherSet(session.SessionId, id, tostring);
                }

                child.AddWatcher(pxw, tostring);

                if (pxw.OneUse)
                {
                    //now, we set the watcher callback to remove the watcher from the session
                    pxw.OnProcess = evt =>
                    {
                        session.RemoveOnTerminateAction("watcher-" + id);
                    };
                }
                else
                {
                    pxw.OnProcess = evt =>
                    {
                        if (evt.EventType == WatchedEvent.WatchedEventType.WatcherRemoved)
                        {
                            session.RemoveOnTerminateAction("watcher-" + id);
                        }
                        else if ((evt.EventType == WatchedEvent.WatchedEventType.NodeDeleted) && evt.Path.Equals(path))
                        {
                            pxw.ProcessAndAbandon(true);
                        }
                    };
                }
                ClientSession clt = session;

                //and finally, if the session closes, to cleanup the watcher.
                session.AddOnTerminateAction("watcher-" + id, (terminating) =>
                {
                    ILockObject obj = null;

                    if (terminating)
                    {
                        obj = child.AcquireLockRw(child.GetLevel());
                    }

                    try
                    {
                        if (s_debugWatcherLocations)
                        {
                            RingMasterEventSource.Log.WatcherRemoved(session.SessionId, id, tostring);
                        }

                        child.RemoveWatcher(pxw);
                    }
                    finally
                    {
                        if (obj != null)
                        {
                            obj.ReleaseWriterLock();
                        }
                    }

                    pxw.ProcessAndAbandon(false);
                });
            }
            else if (bulkWatcherSpecifierWasPresent)
            {
                ClientSession.AddBulkWatcher(session.SessionId, path, pxw);
            }
            else
            {
                BulkWatcherSpec bulkWatcher = BulkWatcherSpec.Create(child.Data, string.Format("{0}_{1}", session.SessionId, path), pxw);
                ClientSession.AddBulkWatcher(session.SessionId, bulkWatcher.Subpath, pxw);
            }
        }

        /// <summary>
        /// Gets the acl.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="lockList">the session's locklist</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse GetAcl(RequestGetAcl req, ILockListTransaction lockList)
        {
            bool abort = true;
            try
            {
                Node parent;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.READ, Perm.READ, out parent);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                //
                // We shouldnt be checking version for this API since there is no way to specify one correctly if you want the latest one.
                // So we make Stat Optional here. If specified we strictly check versions. If not specified, we give you back the latest we have
                //
                if (req.Stat != null)
                {
                    if (!child.IsAclVersion(req.Stat.Aversion) ||
                        !child.IsVersion(req.Stat.Version) ||
                        !child.IsChildVersion(req.Stat.Cversion))
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badversion,
                            Stat = null,
                            Content = null
                        };
                    }
                }

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = child.Acl
                };
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Gets the children.
        /// </summary>
        /// <param name="request">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">the sessions locklist</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse GetChildren(RequestGetChildren request, ClientSession session, ILockListTransaction lockList)
        {
            bool abort = true;
            try
            {
                Stopwatch timer = Stopwatch.StartNew();
                Node parent;
                Node child = this.Root.GetNode(request.Path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.READ, Perm.READ, out parent);

                if (child == null)
                {
                    // this is a metanode, that returns the list of watchers for the parent node
                    if (parent != null && request.Path.EndsWith("$watchers") && request.Watcher == null)
                    {
                        string[] watchers = parent.GetWatcherList();

                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Ok,
                            Stat = parent.NodeStat,
                            Content = watchers
                        };
                    }

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                if ((child.ChildrenCount > this.limits.MaxGetChildrenEnumerationCount) && string.IsNullOrEmpty(request.RetrievalCondition))
                {
                    RingMasterEventSource.Log.RequestGetChildrenEnumerationLimitExceeded(
                        session.SessionId,
                        request.Uid,
                        request.Path,
                        child.ChildrenCount,
                        this.limits.MaxGetChildrenEnumerationCount);

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.TooManyChildren,
                        Stat = null,
                        Content = null
                    };
                }

                RegisterWatcherOnNode(request.Watcher, session, lockList, request.Path, child);

                IList<string> children;

                try
                {
                    children = child.RetrieveChildren(request.RetrievalCondition, this.limits.MaxGetChildrenEnumerationCount).ToList();
                }
                catch (ArgumentException exception)
                {
                    RingMasterEventSource.Log.RequestGetChildrenRetrieveChildrenFailed(session.SessionId, request.Uid, request.Path, child.ChildrenCount, request.RetrievalCondition, exception.ToString());
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = null
                    };
                }

                abort = false;

                timer.Stop();
                RingMasterEventSource.Log.RequestGetChildrenSucceeded(
                    session.SessionId,
                    request.Uid,
                    request.Path,
                    request.RetrievalCondition,
                    children.Count,
                    timer.ElapsedMilliseconds);

                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = children
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestGetChildrenFailed(session.SessionId, request.Uid, request.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Gets the data.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">The session's Locklist</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse GetData(RequestGetData req, ClientSession session, ILockListTransaction lockList)
        {
            bool abort = true;

            try
            {
                Node parent;

                bool isBulk = false;
                bool withStat;

                if (PathDecoration.IsFullContentPath(req.Path, out withStat))
                {
                    req.Path = PathDecoration.GetBasePathForFullContentPath(req.Path);
                    isBulk = true;
                }

                Node.WildCardBehavior wildcard = Node.WildCardBehavior.AllowAnywhere;

                if (req.NoWildcardsForPath)
                {
                    wildcard = Node.WildCardBehavior.NotAllowed;
                }

                Node child = this.Root.GetNode(req.Path, lockList, wildcard, Perm.READ, Perm.READ, out parent, req.FaultbackOnParentData, req.OptionArgument);

                string responsePath = null;

                if (child == null)
                {
                    string parentPath = null;

                    if (req.FaultbackOnParentData && parent != null)
                    {
                        parentPath = Node.BuildPath(parent.Persisted);
                    }

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                        ResponsePath = parentPath
                    };
                }

                // if the child returning the data is not the one queried, return the real path.
                responsePath = req.Path;

                if (req.FaultbackOnParentData)
                {
                    responsePath = Node.BuildPath(child.Persisted);
                }

                if (isBulk)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Ok,
                        Stat = req.NoStatRequired ? null : child.NodeStat,
                        Content = BulkOperation.SerializeAllData(child, withStat),
                        ResponsePath = responsePath
                    };
                }

                RegisterWatcherOnNode(req.Watcher, session, lockList, req.Path, child);

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = req.NoStatRequired ? null : child.NodeStat,
                    Content = child.Data,
                    ResponsePath = responsePath
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestGetDataFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Synchronizes the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="lockList">The session's LockList</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Sync(RequestSync req, ILockListTransaction lockList)
        {
            bool abort = true;
            Node child = null;

            try
            {
                Node parent;
                child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.READ, out parent);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                RequestResponse resp = null;

                if (child != null)
                {
                    lockList.RunOnCommit(() =>
                    {
                        child.Sync();

                        // we need to modify the returned stat after the sync completes.
                        resp.Stat = child.NodeStat;
                    });
                }

                abort = false;

                resp = new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = null,
                    Content = null
                };

                return resp;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Generates a change that will produce a poison pill on the given path
        /// </summary>
        /// <param name="path">the path to poison</param>
        /// <param name="spec">the poison pill specification</param>
        /// <param name="session">the session that generated the pill</param>
        /// <param name="lockList">the locklist for the invocation</param>
        private void SetPoisonPillPath(string path, string spec, IClientSession session, ILockListTransaction lockList)
        {
            if (session == null)
            {
                throw new ArgumentNullException("session");
            }

            if (lockList == null)
            {
                throw new ArgumentNullException("lockList");
            }

            Node parent;
            Node child = this.Root.GetNode(path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.ADMIN, Perm.READ, out parent);

            if (child == null)
            {
                throw new KeyNotFoundException(path);
            }

            lockList.AppendPoison(child.Persisted, spec, lockList.TxTime);
        }

        /// <summary>
        /// Sets the acl.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The client session</param>
        /// <param name="lockList">the sessions locklist</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse SetAcl(RequestSetAcl req, ClientSession session, ILockListTransaction lockList)
        {
            bool abort = true;

            try
            {
                if (req.Acl != null)
                {
                    string aclValidationErrorMessage;
                    if (!this.ValidateAclLimits(req.Acl, session, out aclValidationErrorMessage))
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badarguments,
                            Stat = null,
                            Content = aclValidationErrorMessage
                        };
                    }
                }

                Node parent;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.ADMIN, Perm.READ, out parent);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                if (!child.IsAclVersion(req.Version))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = null,
                        Content = null
                    };
                }

                //child.LockWrite(lockList, Perm.ADMIN);

                IMutableStat prevStat = lockList.SnapStatIfNeeded(child.Persisted);
                IReadOnlyList <Acl> prevAcl = child.Persisted.Acl;

                IReadOnlyList<Acl> newAcl = null;

                if (req.Acl != null && req.Acl.Count > 0)
                {
                    newAcl = req.Acl;
                }

                ((IUnsafeTreeAccess)this).UnsafeSetAcl(child.Persisted, newAcl, lockList.TxTime, req.Path, lockList.TxId, lockList);

                lockList.AppendSetAcl(child.Persisted, lockList.TxTime, prevAcl, prevStat);

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = null
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestSetAclFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }
                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Sets the data.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The client session</param>
        /// <param name="lockList">the sesisons locklist</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse SetData(RequestSetData req, ClientSession session, ILockListTransaction lockList)
        {
            bool abort = true;

            try
            {
                if (req.Data != null && this.limits.MaxNodeDataSize > 0 && req.Data.Length > this.limits.MaxNodeDataSize && !SessionIsLimitExempt(session))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = string.Format("Data size exceeds maximum of {0} bytes", this.limits.MaxNodeDataSize)
                    };
                }

                Node parent;
                int childlevel;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.WRITE, Perm.READ, out parent, out childlevel);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null
                    };
                }

                if (!child.IsVersion(req.Version))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = null,
                        Content = null
                    };
                }

                byte[] prevData = child.Persisted.Data;

                IMutableStat prevStat = lockList.SnapStatIfNeeded(child.Persisted);

                byte[] data = req.Data;
                if (req.IsDataCommand)
                {
                    SetDataOperations op = SetDataOperations.TryCreate(child.Persisted, req);
                    if (op != null)
                    {
                        data = op.GetRequestData();
                    }
                }

                IPersistedData node = child.Persisted;
                // It is possible for this setData to be a command for a replica.
                if (session != null && req.Path.StartsWith(this.ReplicaCommandPathPrefix))
                {
                    RingMasterEventSource.Log.RequestCommand(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, req.Path);
                    this.auditConsumer?.OnRequestCommand(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, req.Path);
                }

                ((IUnsafeTreeAccess)this).UnsafeSetData(node, data, lockList.TxTime, req.Path, lockList.TxId, lockList);

                lockList.AppendSetData(child.Persisted, lockList.TxTime, prevData, prevStat);

                lockList.RunOnCommit(() =>
                {
                    if (child.Persisted.IsEphemeral)
                    {
                        RingMasterServerInstrumentation.Instance.UpdateEphemeralNodeCounts(this.EphemeralFactory.TotalData, this.EphemeralFactory.TotalNodes);
                    }
                    else
                    {
                        RingMasterServerInstrumentation.Instance.UpdatePersistentNodeCounts(this.Factory.TotalData, this.Factory.TotalNodes);
                    }
                });

                abort = false;

                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = null
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestSetDataFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }
                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        internal class SetDataOperations
        {
            private readonly RequestSetData req;
            private readonly IPersistedData prevData;
            private readonly SetDataOperationCode operation;
            private readonly long number;

            private SetDataOperations(RequestSetData req, IPersistedData prevData, SetDataOperationCode operation, long number)
            {
                this.req = req;
                this.prevData = prevData;
                this.operation = operation;
                this.number = number;
            }

            public static SetDataOperations TryCreate(IPersistedData prevData, RequestSetData req)
            {
                if (req == null)
                {
                    throw new ArgumentNullException("req");
                }

                SetDataOperationCode operation;
                long number;

                if (!SetDataOperationHelper.Instance.TryRead(req.Data, out operation, out number))
                {
                    return null;
                }

                return new SetDataOperations(req, prevData, operation, number);
            }

            public byte[] GetRequestData()
            {
                switch (operation)
                {
                    case SetDataOperationCode.InterlockedAddIfVersion:
                        {
                            byte[] data = prevData.Data;
                            if (data.Length != sizeof(long))
                            {
                                throw new InvalidOperationException("data in the node should be able to hold a long");
                            }
                            IoSession ios = new IoSession() { Buffer = data, MaxBytes = data.Length };
                            IoSession res_ios = new IoSession() { Buffer = new byte[data.Length], MaxBytes = data.Length };

                            long prevlong;
                            DataEncodingHelper.Read(ios, out prevlong);
                            prevlong += number;
                            ios.Pos = 0;
                            DataEncodingHelper.Write(prevlong, res_ios);

                            return res_ios.Buffer;
                        }
                    case SetDataOperationCode.InterlockedXORIfVersion:
                        {
                            byte[] data = prevData.Data;
                            if (data.Length != sizeof(long))
                            {
                                throw new InvalidOperationException("data in the node should be able to hold a long");
                            }
                            IoSession ios = new IoSession() { Buffer = data, MaxBytes = data.Length };
                            IoSession res_ios = new IoSession() { Buffer = new byte[data.Length], MaxBytes = data.Length };

                            long prevlong;
                            DataEncodingHelper.Read(ios, out prevlong);
                            prevlong ^= number;
                            ios.Pos = 0;
                            DataEncodingHelper.Write(prevlong, res_ios);

                            return res_ios.Buffer;
                        }
                    default:
                        throw new NotImplementedException("I don't understand operation " + operation);
                }
            }
        }

        public void Dispose()
        {
            if (this.Root != null)
            {
                this.Root = null;
            }
        }

        /// <summary>
        /// Fixes parent stat and node structures when a child is added
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <param name="child">The child.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="path">The path.</param>
        /// <param name="xid">The tx_id.</param>
        /// <param name="locklist">The locklist for this session.</param>
        void IUnsafeTreeAccess.UnsafeAddChild(IPersistedData parent, IPersistedData child, long txtime, string path, long xid, ILockListTransaction locklist)
        {
            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }

            if (child == null)
            {
                throw new ArgumentNullException("child");
            }

            if (locklist == null && IsPathLockedDown(path))
            {
                throw new InvalidAclException(path, "lockdown");
            }

            if (forceWB || locklist == null)
            {
                secondarypreprocessor.AppendAddChild(parent.Id, child.Id, txtime, xid);
            }

            locklist?.ValidateLockList(parent, Perm.CREATE, child, Perm.WRITE);

            this.UpdateStat(parent, xid, txtime, ChangeKind.ChildrenAdded);
            parent.Node.AddChild(child.Node);

            parent.Node.ScheduleTriggerWatchers(ChangeKind.ChildrenAdded, path, locklist);
        }

        void IUnsafeTreeAccess.DoNodeForAddChildren(IPersistedData parent, List<IPersistedData> children)
        {
            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }

            if (children == null)
            {
                throw new ArgumentNullException("children");
            }

            parent.Node.AddChildren(children);
        }

        /// <summary>
        /// Unsafe. Add ephemeral child.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="path">The path.</param>
        /// <param name="xid">The tx_id.</param>
        /// <param name="session">The session.</param>
        void IUnsafeTreeAccess.UnsafeAddEphemeralChild(IPersistedData parent, string path)
        {
            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }

            parent.Node.ScheduleTriggerWatchers(ChangeKind.ChildrenAdded, path, null);
        }

        /// <summary>
        /// Fixes parent and child stats and node structures when a child is removed
        /// </summary>
        /// <param name="node">The node.</param>
        /// <param name="parent">The parent.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="path">The path.</param>
        /// <param name="xid">The tx_id.</param>
        /// <param name="locklist">The locklist for this session.</param>
        void IUnsafeTreeAccess.UnsafeRemove(IPersistedData parent, IPersistedData node, long txtime, string path, long xid, ILockListTransaction locklist)
        {
            ((IUnsafeTreeAccess)this).UnsafeRemoveChild(parent, node, txtime, path, xid, locklist);
            ((IUnsafeTreeAccess)this).UnsafeDeleteNode(parent, node, txtime, path, xid, locklist);
        }

        /// <summary>
        /// Fixes parent and child stats and node structures when a child is removed
        /// </summary>
        /// <param name="node">The node.</param>
        /// <param name="parent">The parent.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="path">The path.</param>
        /// <param name="xid">The tx_id.</param>
        /// <param name="locklist">The locklist for this session.</param>
        void IUnsafeTreeAccess.UnsafeRemoveChild(IPersistedData parent, IPersistedData node, long txtime, string path, long xid, ILockListTransaction locklist)
        {
            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }

            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            if (locklist == null && IsPathLockedDown(path))
            {
                throw new InvalidAclException(path, "lockdown");
            }

            if (forceWB || locklist == null)
            {
                secondarypreprocessor.AppendRemoveChild(parent.Id, node.Id, txtime, xid);
            }

            locklist?.ValidateLockList(parent, Perm.WRITE, node, Perm.WRITE);

            this.UpdateStat(parent, xid, txtime, ChangeKind.ChildrenRemoved);

            parent.Node.RemoveChild(node.Name);

            parent.Node.ScheduleTriggerWatchers(ChangeKind.ChildrenRemoved, GetParentPath(path), locklist);
        }

        /// <summary>
        /// Fixes parent and child stats and node structures when a child is removed
        /// </summary>
        /// <param name="node">The node.</param>
        /// <param name="parent">The parent.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="path">The path.</param>
        /// <param name="xid">The tx_id.</param>
        /// <param name="locklist">The locklist for this session.</param>
        void IUnsafeTreeAccess.UnsafeDeleteNode(IPersistedData parent, IPersistedData node, long txtime, string path, long xid, ILockListTransaction locklist)
        {
            if (parent == null)
            {
                throw new ArgumentNullException("parent");
            }

            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            if (locklist == null && IsPathLockedDown(path))
            {
                throw new InvalidAclException(path, "lockdown");
            }

            if (forceWB || locklist == null)
            {
                secondarypreprocessor.AppendDelete(parent.Id, node.Id, txtime, xid);
            }

            locklist?.ValidateLockList(parent, Perm.WRITE, node, Perm.WRITE);

            this.UpdateStat(node, xid, txtime, ChangeKind.NodeDeleted);
            if (node.IsEphemeral)
            {
                this.EphemeralFactory.Delete(node);
            }
            else
            {
                this.Factory.Delete(node);
            }

            node.Node.ScheduleTriggerWatchers(ChangeKind.NodeDeleted, path, locklist);
        }

        /// <summary>
        /// returns the path to the parent of the given node
        /// </summary>
        /// <param name="path">the path to the child</param>
        /// <returns>the path to the parent</returns>
        private string GetParentPath(string path)
        {
            if (path == null)
            {
                return null;
            }
            int idx = path.LastIndexOf('/');
            if (idx <= 0)
            {
                return "/";
            }
            return path.Substring(0, idx);
        }

        /// <summary>
        /// Fixes child stats and node structures when a node is created
        /// </summary>
        /// <param name="node">The node.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="path">The path.</param>
        /// <param name="xid">The tx_id.</param>
        /// <param name="locklist">The locklist for this session.</param>
        void IUnsafeTreeAccess.UnsafeCreate(IPersistedData node, long txtime, string path, long xid, ILockListTransaction locklist)
        {
            if (locklist == null && IsPathLockedDown(path))
            {
                throw new InvalidAclException(path, "lockdown");
            }

            if (forceWB || locklist == null)
            {
                secondarypreprocessor.AppendCreate(node, txtime, xid);
            }

            this.UpdateStat(node, xid, txtime, ChangeKind.NodeCreated);
            this.DoNodeForCreate(node);

            node.Node.ScheduleTriggerWatchers(ChangeKind.NodeCreated, path, locklist);
        }

        /// <summary>
        /// adjust the node for the create operation
        /// </summary>
        /// <param name="node"></param>
        public void DoNodeForCreate(IPersistedData node)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            node.Node = CompleteNode.CreateNode(node);
        }

        /// <summary>
        /// Fixes child stats and node structures when acl's change
        /// </summary>
        /// <param name="node">The node.</param>
        /// <param name="list">The list.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="path">The path.</param>
        /// <param name="xid">The tx_id.</param>
        /// <param name="locklist">The locklist for this session.</param>
        void IUnsafeTreeAccess.UnsafeSetAcl(IPersistedData node, IReadOnlyList<Acl> list, long txtime, string path, long xid, ILockListTransaction locklist)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            if (locklist == null && IsPathLockedDown(path))
            {
                throw new InvalidAclException(path, "lockdown");
            }

            if (forceWB || locklist == null)
            {
                secondarypreprocessor.AppendSetAcl(node.Id, list, txtime, xid);
            }

            locklist?.ValidateLockList(null, Perm.NONE, node, Perm.WRITE);

            this.UpdateStat(node, xid, txtime, ChangeKind.AclChanged);
            node.Node.SetAcl(list);

            node.Node.ScheduleTriggerWatchers(ChangeKind.AclChanged, path, locklist);
        }

        /// <summary>
        /// Applies on the secondary the poison pill, if it is allowed in this configuration. Otherwise, does nothing.
        /// WARNING: THIS API IS NOT TO BE INVOKED EXCEPT FOR VALIDATING POISON PILLS!!!
        /// </summary>
        /// <param name="node">the PD this poison pill applies to</param>
        /// <param name="spec">the spec of the poison pill</param>
        /// <param name="txtime">the time for this tx</param>
        /// <param name="xid">the transdaction id</param>
        void IUnsafeTreeAccess.UnsafeSetPoisonPill(IPersistedData node, string spec, long txtime, long xid)
        {
            if (!ArePoisonPillAllowed)
            {
                return;
            }

            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            if (spec == null)
            {
                throw new ArgumentNullException("spec");
            }

            Trace.WriteLine(string.Format("Executing Poison Pill: {0} {1} {2} {3}", node.Name, spec, xid, txtime));

            // we will do things about the spec later. for now, just throw something when this is invoked.
            throw new InvalidOperationException(spec);
        }

        /// <summary>
        /// Fixes child stats and node structures when data (byte[]) change
        /// </summary>
        /// <param name="node">The node.</param>
        /// <param name="data">The data.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="path">The path.</param>
        /// <param name="xid">The tx_id.</param>
        /// <param name="locklist">The locklist for this session.</param>
        void IUnsafeTreeAccess.UnsafeSetData(IPersistedData node, byte[] data, long txtime, string path, long xid, ILockListTransaction locklist)
        {
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }

            if (locklist == null && IsPathLockedDown(path))
            {
                throw new InvalidAclException(path, "lockdown");
            }

            if (forceWB || locklist == null)
            {
                secondarypreprocessor.AppendSetData(node.Id, data, txtime, xid);
            }

            // It is possible for this setData to be a command for a replica.
            // if so, we will give it to the secondaryprocessor and let it decide what to do with it
            if (node.Name.Length >= 2 && node.Name[0] == '$' && node.Name[1] == '$' && secondarypreprocessor.ThisReplicaName != null)
            {
                secondarypreprocessor.TryRunCommand(node, data, txtime, xid);
            }

            locklist?.ValidateLockList(null, Perm.NONE, node, Perm.WRITE);
            int delta = -node.Stat.DataLength;
            if (data != null)
            {
                delta += data.Length;
            }

            this.UpdateStat(node, xid, txtime, ChangeKind.DataChanged, delta);
            node.Node.SetData(data);

            if (node.IsEphemeral)
            {
                this.EphemeralFactory.RecordDataDelta(delta);
            }
            else
            {
                if (locklist == null)
                {
                    this.Factory.RecordDataDelta(delta);
                }
                else
                {
                    locklist.RunOnCommit(() =>
                    {
                        this.Factory.RecordDataDelta(delta);
                    });
                }
            }

            node.Node.ScheduleTriggerWatchers(ChangeKind.DataChanged, path, locklist);
        }

        /// <summary>
        /// Unsafe. Clear tree.
        /// </summary>
        void IUnsafeTreeAccess.UnsafeClearTree()
        {
            RingMasterThreadPool.Instance.QueueUserWorkItem(ign =>
                {
                    long lastXId;
                    this.Root = this.Factory.LoadTree(out lastXId);
                    LockListForRW.XidProvider = new UIdProvider(lastXId);
                });
        }

        private bool ValidateAclLimits(IReadOnlyList<Acl> acls, ClientSession session, out string errorMessage)
        {
            errorMessage = null;

            if (acls == null)
            {
                return true;
            }

            if (this.limits.MaxAclsPerNode > 0 && acls.Count > this.limits.MaxAclsPerNode && !SessionIsLimitExempt(session))
            {
                errorMessage = string.Format("Number of ACLs exceeds maximum allowed of {0}", this.limits.MaxAclsPerNode);
                return false;
            }

            if (acls.Any(a => a == null || a.Id == null || (this.limits.MaxAclIdentiferLength > 0 && ((a.Id.Scheme.Length > this.limits.MaxAclIdentiferLength) || (a.Id.Identifier != null && a.Id.Identifier.Length > this.limits.MaxAclIdentiferLength)) && !SessionIsLimitExempt(session))))
            {
                errorMessage = string.Format("Invalid ACL specified. ACLs must not be null, have a scheme, and must have scheme/identifer length of no more than {0} characters", this.limits.MaxAclIdentiferLength);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Determines if a session is limit exempt
        /// </summary>
        /// <param name="session">The client session</param>
        /// <returns>True if the session is limit exempt, false otherwise</returns>
        /// <remarks>The root session must be treated as exempt so limits do not break internal nodes (e.g. under $metadata)</remarks>
        private static bool SessionIsLimitExempt(ClientSession session)
        {
            return session != null && session.Auth != null && session.Auth.IsSuperSession;
        }

        /// <summary>
        /// Determines if a request processing exception is due to user error
        /// </summary>
        /// <param name="exception">The exception that occured</param>
        /// <returns>True if the exception is due to a user error, false otherwise</returns>
        private static bool IsUserError(Exception exception)
        {
            return exception is InvalidAclException;
        }

        /// <summary>
        /// Defines RingMaster Limits
        /// </summary>
        private sealed class RingMasterLimits
        {
            /// <summary>
            /// Gets or sets the maximum number of characters allowed in a single node name
            /// </summary>
            public uint MaxNodeNameLength { get; set; }

            /// <summary>
            /// Gets or sets the total maximum number of characters allowed in a full node path (including /)
            /// </summary>
            public uint MaxNodePathLength { get; set; }

            /// <summary>
            /// Gets or sets the maximum data size of a node in bytes
            /// </summary>
            public uint MaxNodeDataSize { get; set; }

            /// <summary>
            /// Gets or sets the maximum number of ACLs allowed per node
            /// </summary>
            public uint MaxAclsPerNode { get; set; }

            /// <summary>
            /// Gets or sets the maximum length of an ACL identifer
            /// </summary>
            public uint MaxAclIdentiferLength { get; set; }

            /// <summary>
            /// Gets or sets the maximum number of children that can be retrieved by a
            /// single GetChildren request.
            /// </summary>
            public int MaxGetChildrenEnumerationCount { get; set; }

            /// <summary>
            /// Threshold of number of child nodes for a node below which a sorted dictionary will not be used.
            /// </summary>
            public int MinSortedDictionaryThreshold { get; set; }

            /// <summary>
            /// Threshold of number of child nodes for a node above which a sorted dictionary will be used.
            /// </summary>
            public int MaxSortedDictionaryThreshold { get; set; }
        }

        /// <summary>
        /// Data structure to keep track of time stream progress.
        /// </summary>
        private sealed class TimeStreamInfo
        {
            public ulong LastSeenTransactionId { get; set; } = ulong.MaxValue;

            public ulong LastAppliedBatchId { get; set; } = ulong.MaxValue;
        }
    }
}

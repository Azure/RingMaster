// <copyright file="RingMasterBackendCore.cs" company="Microsoft Corporation">
//   Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>

namespace Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;

    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend.AsyncCallback;
    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend.Data;
    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend.HelperTypes;
    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Backend.Persistence;
    using Microsoft.Azure.Networking.Infrastructure.RingMaster.Data;

    using Code = Microsoft.Azure.Networking.Infrastructure.RingMaster.Data.RingMasterException.Code;
    using Perm = Microsoft.Azure.Networking.Infrastructure.RingMaster.Data.Acl.Perm;
    using RequestDefinitions = Microsoft.Azure.Networking.Infrastructure.RingMaster.Requests;
    using RequestResponse = Microsoft.Azure.Networking.Infrastructure.RingMaster.Requests.RequestResponse;
    using RingMasterRequestType = Microsoft.Azure.Networking.Infrastructure.RingMaster.Requests.RingMasterRequestType;

    /// <summary>
    /// Class RingMasterBackendCore.
    /// This implements the actual business logics on the server.
    /// </summary>
    public partial class RingMasterBackendCore : IPersistedDataFactoryClient, IRingMasterRequestExecutor, IDisposable
    {
        /// <summary>
        /// The root digest
        /// </summary>
        public const string RootDigest = "digest:root";

        /// <summary>
        /// if true, we will foce the creation of a WB trace
        /// </summary>
        private const bool ForceWB = false;

        /// <summary>
        /// The max time in seconds a primary promotion may take
        /// </summary>
        private const int MaxSecondsForPrimaryPromotion = 60;

        /// <summary>
        /// Unique Id of the execution queue where all requests from the transaction manager will be queued.
        /// </summary>
        private static readonly Guid TransactionManagerExecutionQueueId = new Guid(0xa49152f7, 0x8f9c, 0x4606, 0x97, 0x6d, 0x74, 0xd7, 0xe9, 0xa6, 0xd8, 0x3c);

        /// <summary>
        /// Maximum number of samples in node.Data used to compute a PersistentData hash value.
        /// </summary>
        private static int maxSamplesForDataHashSet = 8;

        /// <summary>
        /// The maximum time in millis to complete the measurement
        /// </summary>
        private static int maxTimeForMeasurementInMillis = (int)TimeSpan.FromMinutes(2).TotalMilliseconds;

        /// <summary>
        /// When measuring, we will trace a info line every TraceMeasuredNodesInMultiplesOf nodes measured.
        /// </summary>
        private static int traceMeasuredNodesInMultiplesOf = 500000;

        /// <summary>
        /// if true, psudonodes will be disabled
        /// </summary>
        private static bool dontStartPseudoNodes;

        /// <summary>
        /// the function to obtain a setting.
        /// </summary>
        private static getSettingFunctionDelegate getSettingFunction = null;

        /// <summary>
        /// if true, we will enable debugging of the watcher locations
        /// </summary>
        private static bool debugWatcherLocations;

        /// <summary>
        /// Interface to an object that can consume audit events generated by this class.
        /// </summary>
        private readonly IRingMasterAudit auditConsumer;

        /// <summary>
        /// Gets or sets the limits for RingMaster
        /// </summary>
        private readonly RingMasterLimits limits;

        /// <summary>
        /// The list of paths to be locked down
        /// </summary>
        private readonly LockDownSet lockDownPaths = new LockDownSet();

        /// <summary>
        /// the instance to manage cluster psudo-nodes.
        /// </summary>
        private readonly PseudoNodes pseudoNodes;

        /// <summary>
        /// The _has root
        /// </summary>
        private ManualResetEvent hasRoot = new ManualResetEvent(false);

        /// <summary>
        /// Cached Information about time stream progress
        /// </summary>
        private Dictionary<ulong, TimeStreamInfo> timeStreamInfo = new Dictionary<ulong, TimeStreamInfo>();

        /// <summary>
        /// The last time CanBecomePrimary was invoked
        /// </summary>
        private DateTime lastCanBP = DateTime.MinValue;

        /// <summary>
        /// The measure session identifier. Every time we are doing a measurement, this id is incremented.
        /// That is also used to cancel the ongoing measurements.
        /// </summary>
        private long measureSessionId = 0;

        /// <summary>
        /// The processor of actions on replicas as secondaries
        /// </summary>
        private SecondaryPreprocessor secondarypreprocessor;

        /// <summary>
        /// If true, it will start main endpoint on secondary nodes
        /// </summary>
        private bool startMainEndpointOnSecondary;

        /// <summary>
        /// If true, it will start the extra endpoints on secondary nodes
        /// </summary>
        private bool startExtraEndpointOnSecondary;

        /// <summary>
        /// the lock to protect two concurrent changes on the lockdownpath
        /// </summary>
        private object lockDownPathsChangeLock = new object();

        private Timer timerTermination = null;

        private ILockObject rootLock = null;

        private Node previousRoot = null;

        /// <summary>
        /// Action to take on service start
        /// </summary>
        private Action onStart = null;

        /// <summary>
        /// Action to take on service stop
        /// </summary>
        private Action onStop = null;

        static RingMasterBackendCore()
        {
            // this will load the defaults
            InitializeSettings();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="RingMasterBackendCore"/> class.
        /// </summary>
        /// <param name="factory">The factory.</param>
        /// <param name="auditConsumer">Interface to an object that can consume audit events generated by this class</param>
        /// <param name="sslWrappingForRMLoopbackConnect">SSL wrapper to connect to RM service</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors", Justification = "reviewed")]
        public RingMasterBackendCore(IPersistedDataFactory<Node> factory, IRingMasterAudit auditConsumer = null, SslWrapping sslWrappingForRMLoopbackConnect = null)
        {
            this.auditConsumer = auditConsumer;
            this.RmCommands = this.InstanitateRMCommands();

            this.Factory = factory;
            this.EphemeralFactory = new EphemeralFactory();
            this.pseudoNodes = new PseudoNodes(this, GetSetting);

            this.startMainEndpointOnSecondary = GetSetting("RingMaster.StartMainEndpointOnSecondary", bool.TryParse, false);
            this.startExtraEndpointOnSecondary = GetSetting("RingMaster.StartExtraEndpointsOnSecondary", bool.TryParse, false);

            this.Blacklist = GetSetting("RingMaster.Paths.NotAllowedToFail", TryParseStringIntoHash, new HashSet<string>());
            this.IgnoreList = GetSetting("RingMaster.Paths.IgnoreForLockDown", TryParseStringIntoHash, new HashSet<string>());

            this.limits = new RingMasterLimits
            {
                MaxNodeNameLength = GetSetting<uint>("RingMasterLimits.MaxNodeNameLength", uint.TryParse, 0),
                MaxNodePathLength = GetSetting<uint>("RingMasterLimits.MaxNodePathLength", uint.TryParse, 0),
                MaxNodeDataSize = GetSetting<uint>("RingMasterLimits.MaxNodeDataSize", uint.TryParse, 0),
                MaxAclsPerNode = GetSetting<uint>("RingMasterLimits.MaxAclsPerNode", uint.TryParse, 0),
                MaxAclIdentiferLength = GetSetting<uint>("RingMasterLimits.MaxAclIdentiferLength", uint.TryParse, 0),
                MaxGetChildrenEnumerationCount = GetSetting<int>("RingMasterLimits.MaxGetChildrenEnumerationCount", int.TryParse, 10000),
                MinSortedDictionaryThreshold = GetSetting<int>("RingMasterLimits.MinSortedDictionaryThreshold", int.TryParse, 40000),
                MaxSortedDictionaryThreshold = GetSetting<int>("RingMasterLimits.MaxSortedDictionaryThreshold", int.TryParse, 50000),
                MaxBatchExecutionMilliseconds = GetSetting<int>("RingMasterLimits.MaxBatchExecutionMilliseconds", int.TryParse, 300000),
                MaxMultiExecutionMilliseconds = GetSetting<int>("RingMasterLimits.MaxMultiExecutionMilliseconds", int.TryParse, 300000),
            };

            Node.MinSortedDictionaryThreshold = this.limits.MinSortedDictionaryThreshold;
            Node.MaxSortedDictionaryThreshold = this.limits.MaxSortedDictionaryThreshold;

            RingMasterEventSource.Log.RingMasterNodeChildrenLimits(this.limits.MaxGetChildrenEnumerationCount, Node.MinSortedDictionaryThreshold, Node.MaxSortedDictionaryThreshold);

            int multiples = GetSetting("RingMaster.SecondaryPreprocessor.RunOnMultiplesOf", int.TryParse, 0);

            this.secondarypreprocessor = new SecondaryPreprocessor(this, multiples, this.MeasureTree);
            this.SslWrappingForRMLoopbackConnect = sslWrappingForRMLoopbackConnect;
        }

#pragma warning disable SA1300 // begin with upper-case letter
        /// <summary>
        /// Delegate to get the setting for the backend
        /// </summary>
        /// <param name="settingName">name of the setting</param>
        /// <returns>Value of the setting</returns>
        public delegate string getSettingFunctionDelegate(string settingName);
#pragma warning restore

        /// <summary>
        /// Delegate to download the specified URL
        /// </summary>
        /// <param name="urlAndDestination">URL to download</param>
        /// <returns>If the operation is succeeded</returns>
        public delegate bool DownloadUrlIntoLocationFunctionDelegate(string urlAndDestination);

        /// <summary>
        /// parsing function delegate
        /// </summary>
        /// <typeparam name="T">the typed value</typeparam>
        /// <param name="str">The string value.</param>
        /// <param name="val">The typed value.</param>
        /// <returns><c>true</c> if the parsing succeeded, <c>false</c> otherwise.</returns>
        internal delegate bool TryParseFun<T>(string str, out T val);

        /// <summary>
        /// Even triggered after becoming primary
        /// </summary>
        internal event Action OnAfterBecomePrimary = null;

        /// <summary>
        /// Event triggered when the primary status is lost
        /// </summary>
        internal event Action OnAfterPrimaryStatusLost = null;

        /// <summary>
        /// Gets or sets the function to obtain a setting.
        /// </summary>
        /// <value>The GetSetting function.</value>
        public static getSettingFunctionDelegate GetSettingFunction
        {
            get
            {
                return getSettingFunction;
            }

            set
            {
                getSettingFunction = value;
                InitializeSettings();
            }
        }

        /// <summary>
        /// Gets or sets the function to download a URL into a location.
        /// </summary>
        /// <value>The function to download a URL into a location.</value>
        public static DownloadUrlIntoLocationFunctionDelegate DownloadUrlIntoLocationFunction { get; set; }

        /// <summary>
        /// Gets or sets the action to start the backend service
        /// </summary>
        public Action<bool, bool> StartService { get; set; }

        /// <summary>
        /// Gets or sets the action to stop the backend service
        /// </summary>
        public Action StopService { get; set; }

        /// <summary>
        /// Gets or sets the ephemeral mount point factory.
        /// </summary>
        /// <value>The ephemeral mount point factory.</value>
        public Func<string, IPersistedDataFactory<Node>> EphemeralMountPointFactory { get; set; }

        /// <summary>
        /// Gets the list of paths that if an operation on any of them fail, we need global lockdown
        /// </summary>
        public HashSet<string> Blacklist { get; private set; }

        /// <summary>
        /// Gets the list of paths that are safe to not lock down
        /// </summary>
        public HashSet<string> IgnoreList { get; private set; }

        /// <summary>
        /// Gets the prefix of replica command path
        /// </summary>
        public string ReplicaCommandPathPrefix => "/$metadata/commands";

        /// <summary>
        /// Gets or sets maximum time we can spend retrying on an operation.
        /// </summary>
        internal static int MaxRetryOperationMillis { get; set; }

        /// <summary>
        /// Gets or sets a request is considered a long running request if it takes more than this time to complete.
        /// </summary>
        internal static TimeSpan LongRunningRequestThreshold { get; set; }

        /// <summary>
        /// Gets or sets the factory
        /// </summary>
        internal IPersistedDataFactory<Node> Factory { get; set; }

        /// <summary>
        /// Gets a value indicating whether writes are allowed
        /// </summary>
        internal bool WritesAllowed { get; private set; }

        /// <summary>
        /// Gets a value indicating whether this replica is in full lockdown right now
        /// </summary>
        internal bool IsInFullLockDown { get; private set; }

        /// <summary>
        /// Gets or sets the ephemeral factory
        /// </summary>
        internal IPersistedDataFactory<Node> EphemeralFactory { get; set; }

        /// <summary>
        /// Gets or sets the root node
        /// </summary>
        protected Node Root { get; set; }

        /// <summary>
        /// Gets the RMCommands
        /// </summary>
        protected RMCommands RmCommands { get; private set; }

        /// <summary>
        /// Gets a value indicating whether poison pill are allowed
        /// </summary>
        private static bool ArePoisonPillAllowed
        {
            get
            {
                return GetSetting("RingMaster.AllowPoisonPills", bool.TryParse, false);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this instance can take a measurement right now
        /// </summary>
        private bool CanMeasure { get; set; }

        /// <summary>
        /// Gets or sets the SSL wrapping for server to connect to itself
        /// </summary>
        private SslWrapping SslWrappingForRMLoopbackConnect { get; set; }

        /// <summary>
        /// Sets the pseudo nodes data.
        /// </summary>
        /// <param name="port">The port to the primary.</param>
        /// <param name="ssl">The SSL to use.</param>
        public void SetPseudoNodesData(int port, SslWrapping ssl)
        {
            this.onStart = () =>
            {
                this.StartPseudoNodes(port, ssl);
            };

            this.onStop = () =>
            {
                this.StopPseudoNodes();
            };
        }

        /// <summary>
        /// Sets the pseudo nodes data.
        /// </summary>
        public void SetPseudoNodesDataAsLoopback()
        {
            this.onStart = () =>
            {
                this.StartPseudoNodes(() =>
                {
                    return new LoopbackRingMaster(this);
                });
            };

            this.onStop = () =>
            {
                this.StopPseudoNodes();
            };
        }

        /// <summary>
        /// sets up wirebackup on the given configuration
        /// </summary>
        /// <param name="wireBackupPath">path to drop the wirebackup files</param>
        /// <param name="maxEvents">max number of events per file</param>
        /// <param name="maxTimeInMillis">max time in millis per file</param>
        /// <param name="maxEventsBetweenSnapshots">max eents between snapshots</param>
        /// <param name="maxTimeBetweenSnapshotsMillis">max time between snapshots im millis</param>
        /// <param name="keepBackupForSec">Keep backup for seconds and delete it</param>
        public void SetupWireBackup(string wireBackupPath, int maxEvents, int maxTimeInMillis, int maxEventsBetweenSnapshots, int maxTimeBetweenSnapshotsMillis, int keepBackupForSec)
        {
            this.DisableWireBackup();

            WireBackup wirebackup = new WireBackup(wireBackupPath, this.TakeWBSnapshot, maxEvents, maxTimeInMillis, maxEventsBetweenSnapshots, maxTimeBetweenSnapshotsMillis, keepBackupForSec);
            this.secondarypreprocessor.SetWireBackup(wirebackup, true);
        }

        /// <summary>
        /// Takes the wirebackup snapshot.
        /// </summary>
        /// <returns><c>true</c> if the wirebackup snapshot was taken, <c>false</c> otherwise.</returns>
        public bool TakeWBSnapshot()
        {
            if (this.Root == null)
            {
                return false;
            }

            // exit if we are not in position to take a snapshot now
            // this can be because we are a primary, or because we may become a primary in the following few seconds
            if (this.IsOrMayBecomePrimary())
            {
                return false;
            }

            // if not, take the root's lock. That will also idicate the CanBecomePrimary we are not eligible right now to become a primary
            ((IUnsafeTreeAccess)this).LockRootNoSync();

            bool result;

            try
            {
                // record a new snapshot is being taken
                int newId = this.secondarypreprocessor.GenerateNewWBackupId();
                result = this.TakeWBSnapshot(newId, this.Root.Persisted);
            }
            finally
            {
                ((IUnsafeTreeAccess)this).ReleaseRoot();
            }

            return true;
        }

        /// <summary>
        /// disables the wire backup
        /// </summary>
        public void DisableWireBackup()
        {
            this.secondarypreprocessor.StopWireBackup();
        }

        /// <summary>
        /// waits until invoking stop is safe for the cluster, or up to the given maxTime.
        /// </summary>
        /// <param name="maxTime">the expiration time for the validation</param>
        /// <param name="lastHealth">Last health state</param>
        /// <returns>true if it is safe to stop the instance</returns>
        public bool WaitUntilStopIsSafe(DateTime maxTime, out ClusterState lastHealth)
        {
            while (true)
            {
                bool failoverWillHappen;

                if (!this.Factory.UnsafeToStopInstance(this.Factory.Name, out failoverWillHappen))
                {
                    lastHealth = new ClusterState(this.Factory);
                    return true;
                }

                Trace.TraceInformation("WaitUntilStopIsSafe: not safe yet");

                if (DateTime.UtcNow > maxTime)
                {
                    lastHealth = new ClusterState(this.Factory);
                    return false;
                }

                Thread.Sleep(15000);
            }
        }

        /// <summary>
        /// Whether this replica is the primary
        /// </summary>
        /// <returns>True if primary, false if otherwise</returns>
        public bool IsPrimary()
        {
            return this.WritesAllowed;
        }

        /// <summary>
        /// Called when [become primary].
        /// </summary>
        public void OnBecomePrimary()
        {
            long lastTx = this.Factory.GetLastXId();

            Trace.TraceInformation(" I am primary (PID={0}) LastTx={1}", Process.GetCurrentProcess().Id, lastTx);
            LockListForRW.XidProvider = new UIdProvider(lastTx);

            RingMasterThreadPool.Instance.QueueUserWorkItem(ign =>
            {
                this.hasRoot.WaitOne();

                this.WritesAllowed = true;

                this.secondarypreprocessor.CancelAnyOngoingActivity();

                try
                {
                    this.secondarypreprocessor.SetupCommodityTree();
                    this.pseudoNodes.SetupTreeStructure();

                    if (!dontStartPseudoNodes)
                    {
                        this.secondarypreprocessor.SetupCommandTree();
                    }
                }
                catch (Exception e)
                {
                    RingMasterServerInstrumentation.Instance.OnUnexpectedException("RingMasterBackendCore.SetupCommandTree", e);
                    Trace.TraceWarning("RingMasterBackendCore: Command Tree initialization failed. This instance will continue without it. Exception was: {0}", e);
                }

                this.OnAfterBecomePrimary?.Invoke();

                this.StartService?.Invoke(true, true);
            });
        }

        /// <summary>
        /// Sets the runtime memberset function
        /// </summary>
        /// <param name="getRuntimeMembersetFunction">Function to get the cluster member set</param>
        public void SetRuntimeMembersetFunction(Func<ClusterMember[]> getRuntimeMembersetFunction)
        {
            this.pseudoNodes.SetRuntimeMembersetFunction(getRuntimeMembersetFunction);
        }

        /// <summary>
        /// Called when [primary status lost].
        /// </summary>
        public void OnPrimaryStatusLost()
        {
            Trace.TraceInformation("Primary status lost. ProcessId={0}", Process.GetCurrentProcess().Id);
            this.WritesAllowed = false;

            // schedule an abrupt death within the following 30 seconds.
            this.timerTermination = new Timer(
                (o) =>
                {
                    Trace.TraceInformation("Primary Status lost and no termination happened on time. Killing the process.");
                    this.timerTermination = null;
                    Process.GetCurrentProcess().Kill();
                    Environment.Exit(0);
                },
                null,
                30000,
                Timeout.Infinite);

            // The Stop needs to be done asynchronously so the State Machine can be deactivated (we are in a thread from the SM)
            ThreadPool.QueueUserWorkItem(_ =>
            {
                this.OnAfterPrimaryStatusLost?.Invoke();

                Trace.TraceInformation("Primary Status lost. Restarting the backend.");
                this.Stop();
                Thread.Sleep(5000);
                this.Start();

                Timer t = this.timerTermination;

                if (t != null)
                {
                    this.timerTermination = null;
                    t.Change(Timeout.Infinite, Timeout.Infinite);
                }
            });
        }

        /// <summary>
        /// indicates if the given path is locked down
        /// </summary>
        /// <param name="path">path that might be locked down</param>
        /// <returns>true if the path is locked down</returns>
        public bool IsPathLockedDown(string path)
        {
            if (this.lockDownPaths.IsEmpty())
            {
                return false;
            }

            while (!string.IsNullOrEmpty(path))
            {
                if (this.lockDownPaths.Contains(path))
                {
                    RingMasterEventSource.Log.PathIsLockedDown(path);
                    return true;
                }

                int i = path.LastIndexOf('/');

                if (i < 0)
                {
                    break;
                }

                if (i == 0 && path.Length > 1)
                {
                    path = "/";
                    continue;
                }

                path = path.Substring(0, i);
            }

            return false;
        }

        /// <summary>
        /// Called when the replication layer decides it is unsafe to allow any change on the given paths
        /// This method takes the list of paths the replication layer found part of the faulty transaction, and also the list of paths that actually failed in the operation (those may be left in a random state)
        /// It also indicates if the replication layer things the replication of commands need to be frozen, so no futher replications can be done or executed.
        /// This method takes that data, and decides if, even though replication layer doesn't demand to be frozen, any of the failed paths is critical, and therefore, the freeze is needed.
        /// The second thing this method does is to see what paths from the affected paths need to be locked down (so no API can access those).. plus, emits events for that.
        /// Thirdly, if the situation grants it, this method will open the RO ports, so we are at least open for RO operations if there is a replication freeze.
        /// </summary>
        /// <param name="pathsToLockDown">The paths to lock down.</param>
        /// <param name="pathsFailed">The paths failed. A null here means all paths to lock down failed</param>
        /// <param name="poisonPillPrevented">if true, the lower layer is indicating the poison pill was fully prevented</param>
        /// <param name="replicationIsInReadOnly">if true, this means the replication layer is not in ReadOnly</param>
        public void OnPathsLockdownRequested(IEnumerable<string> pathsToLockDown, IEnumerable<string> pathsFailed, bool poisonPillPrevented, ref bool replicationIsInReadOnly)
        {
            RingMasterEventSource.Log.OnPathsLockdownRequested(poisonPillPrevented, replicationIsInReadOnly);
            lock (this.lockDownPathsChangeLock)
            {
                if (!replicationIsInReadOnly)
                {
                    HashSet<string> newSet = new HashSet<string>();

                    // add all previously known locked paths, if we have any
                    foreach (string p in this.lockDownPaths.GetPaths())
                    {
                        newSet.Add(p);
                    }

                    if (pathsToLockDown != null)
                    {
                        foreach (string s in pathsToLockDown)
                        {
                            // skip the paths that are ignorable
                            if (pathsFailed == null || !this.CanLockDownPathBeIgnored(s))
                            {
                                newSet.Add(s);
                            }
                        }
                    }

                    if (pathsFailed != null)
                    {
                        foreach (string s in pathsFailed)
                        {
                            if (!this.CanLockDownPathBeIgnored(s))
                            {
                                newSet.Add(s);
                            }
                        }
                    }

                    RemoveRedundantPaths(newSet);

                    // update the known lock down paths
                    // here, not we cannot replace lockDownPaths, since that collection is already
                    // in use for the currently opened sessions. We instead want to MODIFY that collection
                    this.lockDownPaths.ReplacePaths(newSet);

                    foreach (string path in newSet)
                    {
                        RingMasterEventSource.Log.OnPathsLockdownRequested_FinalSet(path);
                    }

                    if (!this.NoneInBlackList(newSet))
                    {
                        replicationIsInReadOnly = true;
                    }
                }

                RingMasterServerInstrumentation.Instance.OnLockDownFound(this.lockDownPaths.GetPaths(), replicationIsInReadOnly);

                if (replicationIsInReadOnly)
                {
                    RingMasterEventSource.Log.OnPathsLockdownRequested_FullLockdown();

                    // disable write ability for sure
                    this.WritesAllowed = false;
                    this.IsInFullLockDown = true;

                    this.startMainEndpointOnSecondary = true;
                    this.startExtraEndpointOnSecondary = true;

                    if (this.Root != null)
                    {
                        // if this is a secondary already loaded, just open the endpoints now
                        this.OpenEndpointsOnSecondaryIfNeeded();
                    }

                    this.lockDownPaths.IgnoreAllpaths = this.lockDownPaths.IgnoreAllpaths | poisonPillPrevented;
                }
                else
                {
                    this.IsInFullLockDown = false;
                    foreach (string s in this.lockDownPaths.GetPaths())
                    {
                        RingMasterEventSource.Log.OnPathsLockdownRequested_PartialLockdown(s);
                    }

                    this.lockDownPaths.IgnoreAllpaths = false;
                }
            }
        }

        /// <summary>
        /// Determines whether this instance [can become primary].
        /// </summary>
        /// <returns><c>true</c> if this instance can become primary; otherwise, <c>false</c>.</returns>
        public bool CanBecomePrimary()
        {
            this.RecordPromotionQuery();

            return true;
        }

        /// <summary>
        /// Starts this instance.
        /// </summary>
        public void Start()
        {
            if (this.Factory == null)
            {
                Trace.TraceError("RingMasterBackendCore.Start: Factory cannot be null");
                throw new InvalidOperationException("Factory cannot be null when calling Start()");
            }

            Trace.TraceInformation("Start() was called");

            long lastXId;
            this.Factory.Activate(this, this);
            Trace.TraceInformation("Start() will call LoadTree");
            this.Root = this.Factory.LoadTree(out lastXId);
            Trace.TraceInformation("Start() should have a root: {0}", this.Root != null);

            Trace.TraceInformation("RingMasterBackendCore.Start: Last TransactionId={0}", lastXId);

            ManualResetEventPool.InstancePool.Set(this.hasRoot);

            this.OpenEndpointsOnSecondaryIfNeeded();

            if (this.onStart != null)
            {
                this.onStart();
            }
        }

        /// <summary>
        /// Stops this instance.
        /// </summary>
        public void Stop()
        {
            if (this.onStop != null)
            {
                this.onStop();
            }

            if (this.StopService != null)
            {
                this.StopService();
            }

            if (this.Factory != null)
            {
                this.Factory.Deactivate();
            }
        }

        /// <inheritdoc />
        public void Dispose()
        {
            if (this.Root != null)
            {
                this.Root = null;
            }

            if (this.hasRoot != null)
            {
                this.hasRoot.Dispose();
                this.hasRoot = null;
            }
        }

        /// <summary>
        /// Processes the session initialization.
        /// </summary>
        /// <param name="call">The call.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse.</returns>
        /// <exception cref="System.Exception">
        /// We shouldnt know about this uninitialized session yet.
        /// or
        /// First request from an unitialized session should be RequestInit.
        /// </exception>
        public RequestResponse ProcessSessionInitialization(RequestCall call, ClientSession session)
        {
            if (call == null)
            {
                throw new ArgumentNullException(nameof(call));
            }

            if (session == null)
            {
                throw new ArgumentNullException(nameof(session));
            }

            ulong callId = call.CallId;

            RequestInit initR = call.Request as RequestInit;
            if (initR != null)
            {
                return this.ProcessSessionInitialization(session, initR, callId);
            }

            Trace.TraceWarning(
                "[SessionId={0}] First request should be RequestInit it was {1}",
                session.SessionId,
                call.Request);

            throw new InvalidOperationException("First request from an unitialized session should be RequestInit.");
        }

        /// <summary>
        /// Processes the message.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="onCompletion">completion routine</param>
        /// <exception cref="System.InvalidOperationException">RequestInit can be issued only once in a session lifetime</exception>
        public void ProcessMessage(IRingMasterBackendRequest req, ClientSession session, Action<RequestResponse, Exception> onCompletion)
        {
            ////session.RenewTimer();
            Task taskReplication;
            RequestResponse resp = this.ProcessMessage(req, session, out taskReplication);

            var duration = Stopwatch.StartNew();

            if (taskReplication != null)
            {
                taskReplication.ContinueWith(
                    task =>
                    {
                        onCompletion?.Invoke(resp, task.Exception);

                        if (!task.IsFaulted && !task.IsCanceled)
                        {
                            RingMasterServerInstrumentation.Instance.OnResponseWaitForReplication(duration.Elapsed);
                        }
                        else
                        {
                            Trace.TraceError("ProcessMessage Failed: " + task.Exception);
                        }
                    });
            }
        }

        /// <summary>
        /// Builds a TreeFile for the given nodepath.
        /// </summary>
        /// <param name="nodepath">The nodepath.</param>
        /// <param name="filename">The filename.</param>
        /// <param name="version">The version.</param>
        /// <returns>the response of the operation</returns>
        public RequestResponse BuildTreeFile(string nodepath, string filename, int version)
        {
            ClientSession ses = this.GetLoopbackSession(RMCommands.CommanderDigest);
            try
            {
                RequestInternalRun req = new RequestInternalRun(nodepath, null, (x, l) => { return this.BuildTreeFile(x, l, version, filename); }, null);

                return this.ProcessMessage(req, ses);
            }
            finally
            {
                ses.Close();
            }
        }

        /// <summary>
        /// Mounts the specified filename on the given nodepath.
        /// </summary>
        /// <param name="nodepath">The nodepath.</param>
        /// <param name="filename">The filename.</param>
        /// <param name="allowremount">if set to <c>true</c> remounts are allowed.</param>
        /// <param name="mountRoot">Whether to mount the root node</param>
        /// <returns>the response of the operation</returns>
        public RequestResponse Mount(string nodepath, string filename, bool allowremount, bool mountRoot = false)
        {
            ClientSession ses = this.GetLoopbackSession(RMCommands.CommanderDigest);
            try
            {
                RequestInternalRun req = new RequestInternalRun(nodepath, null, (x, l) => { return this.Mount(x, l, ses, filename, allowremount, mountRoot); }, null);

                return this.ProcessMessage(req, ses);
            }
            finally
            {
                ses.Close();
            }
        }

        /// <summary>
        /// Unmounts the specified nodepath.
        /// </summary>
        /// <param name="nodepath">The nodepath.</param>
        /// <returns>the response of the operation</returns>
        public RequestResponse Unmount(string nodepath)
        {
            ClientSession ses = this.GetLoopbackSession(RMCommands.CommanderDigest);
            try
            {
                RequestInternalRun req = new RequestInternalRun(nodepath, null, (x, l) => { return this.Unmount(x.Path, l, ses); }, null);

                return this.ProcessMessage(req, ses);
            }
            finally
            {
                ses.Close();
            }
        }

        /// <summary>
        /// fails over the replica.
        /// It favors the replica passed as argument to take over primariness (not guaranteed).
        /// It stops the local service after the given time
        /// </summary>
        /// <param name="replicaToFailover">The replica to favor the failover.</param>
        /// <param name="delayBeforeStopServiceInMillis">The delay before stopping the service, in milliseconds. if Infinite, this means we don't want to stop the service explicitly here</param>
        /// <returns><c>true</c> if we were primary and the failover was issued, <c>false</c> otherwise.</returns>
        public bool FailoverInto(string replicaToFailover, int delayBeforeStopServiceInMillis = Timeout.Infinite)
        {
            // action to run when we are ready to go down.
            Action action = new Action(() =>
            {
                if (delayBeforeStopServiceInMillis != Timeout.Infinite)
                {
                    Thread.Sleep(delayBeforeStopServiceInMillis);
                    this.StopService();
                }
            });

            if (!this.IsPrimary())
            {
                action();
                return false;
            }

            if (delayBeforeStopServiceInMillis < 0)
            {
                delayBeforeStopServiceInMillis = 0;
            }

            ManualResetEvent evt = ManualResetEventPool.InstancePool.GetOne();

            this.Factory.FailoverInto(replicaToFailover, () =>
            {
                action();
                ManualResetEventPool.InstancePool.Set(evt);
            });

            ManualResetEventPool.InstancePool.WaitOneAndReturn(ref evt);

            return true;
        }

        /// <summary>
        /// adjust the node for the create operation
        /// </summary>
        /// <param name="node">Node being created</param>
        public void DoNodeForCreate(IPersistedData node)
        {
            if (node == null)
            {
                throw new ArgumentNullException(nameof(node));
            }

            node.Node = CompleteNode.CreateNode(node);
        }

        /// <summary>
        /// gets a setting as indicated by the getsettingfunction
        /// </summary>
        /// <param name="settingName">Name of the setting</param>
        /// <returns>Value of the setting</returns>
        internal static string GetSetting(string settingName)
        {
            getSettingFunctionDelegate getSettingFunction = GetSettingFunction;

            if (getSettingFunction == null)
            {
                return null;
            }

            try
            {
                return getSettingFunction(settingName);
            }
            catch
            {
                // ignore
                Trace.TraceInformation($"Could not get setting {settingName} from config.");
            }

            return null;
        }

        /// <summary>
        /// Gets the setting. provides a defaultValue and a stringToT parsing function.
        /// </summary>
        /// <typeparam name="T">the type of the setting value</typeparam>
        /// <param name="settingName">Name of the setting.</param>
        /// <param name="parse">The function to parse the value string into typed value.</param>
        /// <param name="defaultValue">The default value.</param>
        /// <returns>the typed value.</returns>
        internal static T GetSetting<T>(string settingName, TryParseFun<T> parse, T defaultValue)
        {
            T res;

            if (parse == null)
            {
                throw new ArgumentNullException(nameof(parse));
            }

            string fromConfig = GetSetting(settingName);

            if (fromConfig == null || !parse(fromConfig, out res))
            {
                return defaultValue;
            }

            return res;
        }

        /// <summary>
        /// measures the whole tree and returns a dictionary of childOfRootName->measurement.
        /// measurement may be a ulong, or an Exception
        /// </summary>
        /// <param name="nthreads">the number of threads to use for the measurement</param>
        /// <param name="maxMeasurementTimeInMillis">max time to complete the measurement</param>
        /// <returns>the dictionary of measurements, where the key is the name of a node child of root, and the value is a measurement (ulong) or an exception</returns>
        internal Dictionary<string, object> MeasureFullTree(int nthreads, int maxMeasurementTimeInMillis)
        {
            ExecutionQueue q = new ExecutionQueue(nthreads);
            Dictionary<string, object> results = new Dictionary<string, object>();

            IEnumerable<string> children = this.Root.RetrieveChildren();

            long sessionId = Interlocked.Increment(ref this.measureSessionId);

            HelperTypes.CountdownEvent ev = new HelperTypes.CountdownEvent(1);

            foreach (string child in children)
            {
                string child_i = child;
                Trace.TraceInformation("Metrics for child: {0} scheduled", child_i);
                ev.Add(1);

                q.Enqueue(
                    _ =>
                    {
                        object line;
                        int numnodes = 0;
                        try
                        {
                            ulong metrics = this.Measure(ref numnodes, sessionId, this.Root.TryGetChild(child_i, false));
                            line = metrics;
                        }
                        catch (Exception e)
                        {
                            line = e;
                        }

                        lock (results)
                        {
                            results.Add(child_i, line);
                        }

                        ev.DecrementAndSetIfZero();
                    },
                    child);
            }

            ev.DecrementAndSetIfZero();

            if (!ev.WaitOne(maxMeasurementTimeInMillis))
            {
                this.measureSessionId++;
            }

            q.Drain(ExecutionQueue.DrainMode.DisallowAllFurtherEnqueues);

            return results;
        }

        /// <summary>
        /// Starts the pseudo nodes
        /// </summary>
        /// <param name="getRingMaster">Function to get the ring master object</param>
        internal void StartPseudoNodes(Func<AbstractRingMaster> getRingMaster)
        {
            if (!dontStartPseudoNodes)
            {
                Trace.TraceInformation("RingMasterBackendCore.Start: Starting pseudonodes");
                this.pseudoNodes.SetupPseudoNodes(getRingMaster, this.RmCommands.SyncObject);
            }
        }

        /// <summary>
        /// Starts the pseudo nodes
        /// </summary>
        /// <param name="port">Port number</param>
        /// <param name="ssl">SSL wrapping object</param>
        internal void StartPseudoNodes(int port, SslWrapping ssl)
        {
            if (!dontStartPseudoNodes)
            {
                Trace.TraceInformation("RingMasterBackendCore.Start: Starting pseudonodes");
                this.pseudoNodes.SetupPseudoNodes(port, this.SslWrappingForRMLoopbackConnect != null ? this.SslWrappingForRMLoopbackConnect : ssl, this.RmCommands.SyncObject);
            }
        }

        /// <summary>
        /// Stops the pseudo nodes
        /// </summary>
        internal void StopPseudoNodes()
        {
            if (!dontStartPseudoNodes)
            {
                Trace.TraceInformation("RingMasterBackendCore.Stop: Stopping pseudonodes");
                this.pseudoNodes.Stop();
            }
        }

        /// <summary>
        /// Open the endpoints on the secondary, if such thing is needed
        /// </summary>
        internal void OpenEndpointsOnSecondaryIfNeeded()
        {
            // initialize the txId to whatever we have right now.
            if (LockListForRW.XidProvider == null)
            {
                LockListForRW.XidProvider = new FixedUIdProvider(1);
            }

            if (this.startMainEndpointOnSecondary || this.startExtraEndpointOnSecondary)
            {
                this.pseudoNodes.CreateLockDownNodeIfNeeded();

                this.StartService(this.startMainEndpointOnSecondary, this.startExtraEndpointOnSecondary);
            }
        }

        /// <summary>
        /// generates a loopback session with the given digest.
        /// </summary>
        /// <param name="digest">the digest to use</param>
        /// <param name="onlyEphemeralChangesAllowed">if true, only operations on ephemeral are allowed</param>
        /// <param name="writesAllowed">if true, this session is allowed to do writes</param>
        /// <param name="readOnlyInterfaceRequiresLocks">if true, locks are needed for RO locks</param>
        /// <returns>Loop back client session</returns>
        internal ClientSession GetLoopbackSession(string digest, bool onlyEphemeralChangesAllowed = false, bool writesAllowed = true, bool readOnlyInterfaceRequiresLocks = true)
        {
            ClientSession ses = new ClientSession(null);

            ses.State = ClientSession.SessionState.Initialized;
            ses.WritesAllowed = writesAllowed;
            ses.ROInterfaceRequiresLocks = readOnlyInterfaceRequiresLocks;
            ses.SetClientDigest(digest);
            ses.OnlyEphemeralChangesAllowed = writesAllowed && onlyEphemeralChangesAllowed;
            return ses;
        }

        /// <summary>
        /// Measures the full tree.
        /// </summary>
        /// <param name="txTime">The tx time that triggered this.</param>
        /// <param name="txId">The tx identifier that triggered this.</param>
        protected void MeasureTree(long txTime, long txId)
        {
            // see if this replica is the secondary with smaller Id in the clusterset.
            try
            {
                Trace.TraceInformation("MeasureTree invoked at txtime={0} txid={1}?", MutableStat.ConvertTime(txTime).ToString("o"), txId);

                List<string> members = new List<string>();

                if (this.IsPrimary())
                {
                    return;
                }

                Dictionary<string, HealthDefinition> dict = this.Factory.GetHealth();

                foreach (KeyValuePair<string, HealthDefinition> elem in dict)
                {
                    if (!elem.Value.IsPrimary)
                    {
                        members.Add(elem.Key);
                    }
                }

                if (members.Count == 0)
                {
                    return;
                }

                members.Sort();

                Trace.TraceInformation("Factory.Name={0} members=[{1}]", this.Factory.Name, string.Join(",", members));

                if (!string.Equals(this.Factory.Name, members[0]))
                {
                    Trace.TraceInformation("skipping measurement because we are not the right instance to measure");

                    return;
                }

                Trace.TraceInformation("proceeding to measuring now!");

                // now, we know we are THE replica that needs to measure the tree... do it now.
                Stopwatch sw = Stopwatch.StartNew();

                Dictionary<string, object> results = this.MeasureFullTree(PlatformHelper.ProcessorCount, maxTimeForMeasurementInMillis);

                sw.Stop();

                foreach (KeyValuePair<string, object> line in results)
                {
                    string text;
                    Exception e = line.Value as Exception;
                    if (e != null)
                    {
                        text = e.ToString();
                        RingMasterServerInstrumentation.Instance.OnMeasurement(-1, line.Key, txId);
                    }
                    else
                    {
                        ulong metrics = (ulong)line.Value;
                        text = string.Format("{0:X}", metrics);
                        RingMasterServerInstrumentation.Instance.OnMeasurement((long)metrics, line.Key, txId);
                    }

                    Trace.TraceInformation("Metrics for {0} is {1} ({2} ms)", line.Key, text, sw.ElapsedMilliseconds);
                }

                RingMasterServerInstrumentation.Instance.OnMeasurementCompleted(sw.ElapsedMilliseconds, txId);
            }
            catch (Exception ex)
            {
                Trace.TraceWarning("tree measurement failed: {0}", ex);
            }
        }

        /// <summary>
        /// instantiates a new RMCommand object for this backend
        /// </summary>
        /// <returns>RM command</returns>
        protected virtual RMCommands InstanitateRMCommands()
        {
            return new RMCommands(this);
        }

        /// <summary>
        /// Setup the logging verbosity level
        /// </summary>
        /// <param name="level">Level to set</param>
        protected virtual void SetupVerbosityLevel(int level)
        {
        }

        /// <summary>
        /// Gets the current verbosity level
        /// </summary>
        /// <returns>current level</returns>
        protected virtual string GetVerbosityLevel()
        {
            return "1";
        }

        /// <summary>
        /// Initializes the settings based on the current GetSetting function, and sets default appropriatedly
        /// </summary>
        private static void InitializeSettings()
        {
            debugWatcherLocations = GetSetting("RingMaster.DebugWatcherLocations", bool.TryParse, false);

            dontStartPseudoNodes = GetSetting("RingMaster.DontStartPseudoNodes", bool.TryParse, false);

            MaxRetryOperationMillis = GetSetting("RingMaster.MaxRetryOperationMillis", int.TryParse, 2500);

            Node.MaxAcquireRWLockTime = TimeSpan.FromMilliseconds(GetSetting("RingMaster.MaxAcquireRWLockTimeMillis", int.TryParse, 500));

            // By default, the long running request threshold is high to reduce log spew.  It can be reduced to the desired value to debug
            // requests that take more than the expected time.
            LongRunningRequestThreshold = TimeSpan.FromMilliseconds(GetSetting("RingMaster.LongRunningRequestThreshold", int.TryParse, 100000));
        }

        /// <summary>
        /// Registers the watcher on node.
        /// </summary>
        /// <param name="reqWatcher">The req watcher.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">the lock list for the session</param>
        /// <param name="path">The path.</param>
        /// <param name="child">The child.</param>
        private static void RegisterWatcherOnNode(IWatcher reqWatcher, ClientSession session, ILockListTransaction lockList, string path, Node child)
        {
            // we don't do anything if this session is a RO lockless.
            if (!session.WritesAllowed || !session.ROInterfaceRequiresLocks)
            {
                return;
            }

            lockList.RunOnCommit(() =>
            {
                RegisterWatcherOnNodeDuringCommit(reqWatcher, session, path, child);
            });
        }

        /// <summary>
        /// Registers the watcher on node.
        /// </summary>
        /// <param name="reqWatcher">The req watcher.</param>
        /// <param name="session">The session.</param>
        /// <param name="path">The path.</param>
        /// <param name="child">The child.</param>
        private static void RegisterWatcherOnNodeDuringCommit(IWatcher reqWatcher, ClientSession session, string path, Node child)
        {
            MarshallerChannel.ProxyWatcher pxw = reqWatcher as MarshallerChannel.ProxyWatcher;

            if (pxw == null && reqWatcher != null)
            {
                pxw = new MarshallerChannel.FakeProxyWatcher(reqWatcher, path);
            }

            bool bulkWatcherSpecifierWasPresent = false;
            path = BulkOperation.RemoveBulkWatcherSpecifier(path, out bulkWatcherSpecifierWasPresent);

            bool isBulk = bulkWatcherSpecifierWasPresent || BulkOperation.IsBulkWatcher(path);

            // if the watcher is NOT installed on a bulkWatcher node:
            if (!isBulk)
            {
                string id = child.GlobalUniqueId;

                // remove -if it exists- any watcher that was installed in this node by this session.
                if (session.HasOnTerminateActions)
                {
                    Action<bool> previous;
                    if (session.TryRemoveOnTerminateAction("watcher-" + id, out previous))
                    {
                        // this will remove the watcher from the child as well
                        previous(false);
                    }
                }

                // if this is uninstallation of a watcher... we are done
                if (pxw == null)
                {
                    return;
                }

                // now, add the watcher to the child
                string tostring = null;

                if (debugWatcherLocations)
                {
                    tostring = string.Format("{0}:{1} {2}", path, session.Auth.ClientDigest, isBulk ? "Bulk" : string.Empty);
                    RingMasterEventSource.Log.WatcherSet(session.SessionId, id, tostring);
                }

                child.AddWatcher(pxw, tostring);

                if (pxw.Kind.HasFlag(WatcherKind.OneUse))
                {
                    // now, we set the watcher callback to remove the watcher from the session
                    pxw.OnProcess = evt =>
                    {
                        session.RemoveOnTerminateAction("watcher-" + id);
                    };
                }
                else
                {
                    pxw.OnProcess = evt =>
                    {
                        if (evt.EventType == WatchedEvent.WatchedEventType.WatcherRemoved)
                        {
                            session.RemoveOnTerminateAction("watcher-" + id);
                        }
                        else if ((evt.EventType == WatchedEvent.WatchedEventType.NodeDeleted) && evt.Path.Equals(path))
                        {
                            pxw.ProcessAndAbandon(true);
                        }
                    };
                }

                ClientSession clt = session;

                // and finally, if the session closes, to cleanup the watcher.
                session.AddOnTerminateAction("watcher-" + id, (terminating) =>
                {
                    ILockObject obj = null;

                    if (terminating)
                    {
                        obj = child.AcquireLockRw(child.GetLevel());
                    }

                    try
                    {
                        if (debugWatcherLocations)
                        {
                            RingMasterEventSource.Log.WatcherRemoved(session.SessionId, id, tostring);
                        }

                        child.RemoveWatcher(pxw);
                    }
                    finally
                    {
                        if (obj != null)
                        {
                            obj.ReleaseWriterLock();
                        }
                    }

                    pxw.ProcessAndAbandon(false);
                });
            }
            else if (bulkWatcherSpecifierWasPresent)
            {
                ClientSession.AddBulkWatcher(session.SessionId, path, pxw);
            }
            else
            {
                BulkWatcherSpec bulkWatcher = BulkWatcherSpec.Create(child.Data, string.Format("{0}_{1}", session.SessionId, path), pxw);
                ClientSession.AddBulkWatcher(session.SessionId, bulkWatcher.Subpath, pxw);
            }
        }

        /// <summary>
        /// Determines if a session is limit exempt
        /// </summary>
        /// <param name="session">The client session</param>
        /// <returns>True if the session is limit exempt, false otherwise</returns>
        /// <remarks>The root session must be treated as exempt so limits do not break internal nodes (e.g. under $metadata)</remarks>
        private static bool SessionIsLimitExempt(ClientSession session)
        {
            return session != null && session.Auth != null && session.Auth.IsSuperSession;
        }

        /// <summary>
        /// Determines if a request processing exception is due to user error
        /// </summary>
        /// <param name="exception">The exception that occured</param>
        /// <returns>True if the exception is due to a user error, false otherwise</returns>
        private static bool IsUserError(Exception exception)
        {
            return exception is InvalidAclException;
        }

        /// <summary>
        /// Determines whether the path has a prefix in the given hash (and ,if orExactMatch is true, has an exact match)
        /// </summary>
        /// <param name="path">The path.</param>
        /// <param name="paths">The paths.</param>
        /// <param name="wasExactMatch">if set to <c>true</c> the match was an exact match, otherwise, path is a longer path than one in the paths hash</param>
        /// <returns><c>true</c> if the path has a prefix in the given hash (and ,if orExactMatch is true, has an exact match); otherwise, <c>false</c>.</returns>
        private static bool ContainsSubPath(string path, HashSet<string> paths, out bool wasExactMatch)
        {
            wasExactMatch = false;
            foreach (string p in paths)
            {
                string other = p;

                if (other == path)
                {
                    wasExactMatch = true;
                    return true;
                }

                if (!other.EndsWith("/"))
                {
                    other = other + "/";
                }

                if (!path.EndsWith("/"))
                {
                    path = path + "/";
                }

                if (path.StartsWith(other))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Removes the redundant paths from the hashset. RemoveRedundantPaths({'/foo/bar/toe','/foo/bar'}) = { '/foo/bar' }
        /// </summary>
        /// <param name="paths">The paths, potentially with redundant deeper paths on it</param>
        private static void RemoveRedundantPaths(HashSet<string> paths)
        {
            List<string> redundant = new List<string>();

            foreach (string path in paths)
            {
                bool wasExact;

                if (ContainsSubPath(path, paths, out wasExact) && !wasExact)
                {
                    redundant.Add(path);
                }
            }

            foreach (string path in redundant)
            {
                paths.Remove(path);
            }
        }

        /// <summary>
        /// Tries to parse a string into a hash of strings.
        /// </summary>
        /// <param name="setting">The input string with a comma or semicomma separated list of strings.</param>
        /// <param name="value">The hash of strings.</param>
        /// <returns><c>true</c> if the parsing was successful, <c>false</c> otherwise.</returns>
        private static bool TryParseStringIntoHash(string setting, out HashSet<string> value)
        {
            try
            {
                value = new HashSet<string>();

                if (!string.IsNullOrWhiteSpace(setting))
                {
                    string[] values = setting.Split(new char[] { ';', ' ', ',' }, StringSplitOptions.RemoveEmptyEntries);

                    foreach (string v in values)
                    {
                        value.Add(v);
                    }
                }

                return true;
            }
            catch (Exception)
            {
                value = null;
                return false;
            }
        }

        /// <summary>
        /// Takes the wb snapshot. as long as the wirebackup id is the one we got from the stack
        /// </summary>
        /// <param name="wbId">The wb identifier.</param>
        /// <param name="nd">The node to start from.</param>
        /// <returns><c>true</c> if we took the whole snapshot, <c>false</c> otherwise.</returns>
        private bool TakeWBSnapshot(int wbId, IPersistedData nd)
        {
            // check that the WB was not aborted
            if (wbId != this.secondarypreprocessor.WbackupId)
            {
                return false;
            }

            this.secondarypreprocessor.AppendCreate(nd, nd.Stat.Ctime, nd.Stat.Czxid);

            foreach (IPersistedData d in nd.Node.ChildrenMapping.Values)
            {
                this.secondarypreprocessor.AppendAddChild(nd.Id, d.Id, nd.Stat.Ctime, nd.Stat.Czxid);
            }

            foreach (IPersistedData d in nd.Node.ChildrenMapping.Values)
            {
                if (!this.TakeWBSnapshot(wbId, d))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Records this replica may become primary in the following few seconds
        /// </summary>
        private void RecordPromotionQuery()
        {
            this.lastCanBP = DateTime.UtcNow;

            this.secondarypreprocessor.CancelAnyOngoingActivity();
        }

        /// <summary>
        /// Indicates if is is posible for this replica to become primary in the following few seconds
        /// </summary>
        /// <returns><c>true</c> if we are or we may be primary in the next few seconds, <c>false</c> otherwise.</returns>
        private bool IsOrMayBecomePrimary()
        {
            if (this.IsPrimary())
            {
                return true;
            }

            return DateTime.UtcNow - this.lastCanBP < TimeSpan.FromSeconds(MaxSecondsForPrimaryPromotion);
        }

        /// <summary>
        /// Indicates if none of the given path is in the blackList
        /// </summary>
        /// <param name="paths">The paths.</param>
        /// <returns><c>true</c> if none of the paths is blacklisted, <c>false</c> otherwise.</returns>
        private bool NoneInBlackList(IEnumerable<string> paths)
        {
            if (paths == null || this.Blacklist == null)
            {
                return false;
            }

            foreach (string path in paths)
            {
                bool wasExact;
                bool contains = ContainsSubPath(path, this.Blacklist, out wasExact);
                Trace.TraceInformation("- is {0} in {1}? --> {2}", path, "blackList", contains);

                if (contains)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Determines whether this path lockdown can be ignored
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns><c>true</c> if this path lockdown can be ignored; otherwise, <c>false</c>.</returns>
        private bool CanLockDownPathBeIgnored(string path)
        {
            bool ignore = false;
            bool wasExact;
            if (this.IgnoreList != null && ContainsSubPath(path, this.IgnoreList, out wasExact))
            {
                ignore = true;
            }

            Trace.TraceInformation("- is {0} in {1}? --> {2}", path, "ignore list", ignore);
            return ignore;
        }

        /// <summary>
        /// measures the node in depth, computing a HashCode of the whole subtree
        /// </summary>
        /// <param name="numnodes"> the total number of nodes explored so far</param>
        /// <param name="measureSessionId">the sessionId which started this measurement</param>
        /// <param name="node">the node to measure</param>
        /// <returns>the resulting measurement to xor with</returns>
        private ulong Measure(ref int numnodes, long measureSessionId, Node node)
        {
            numnodes++;

            if (numnodes % traceMeasuredNodesInMultiplesOf == 1)
            {
                Trace.TraceInformation("Metrics from thread {0} -> {1} nodes done ({2})", Thread.CurrentThread.ManagedThreadId, numnodes, Node.BuildPath(node.Persisted));
            }

            if (this.WritesAllowed && !this.CanMeasure)
            {
                // cancel, as we just became primary and we are not forced on the measurement
                throw new InvalidOperationException("became primary");
            }

            if (this.measureSessionId != measureSessionId)
            {
                // cancel, as we just found out our sessionId is not the last one
                throw new InvalidOperationException("measureSessionId chancged");
            }

            if (node == null || node.Persisted.IsEphemeral)
            {
                return 0;
            }

            ulong measurement = this.Measure(node.Persisted);

            if (node.ChildrenMapping != null)
            {
                ulong childrenM = 0;
                IEnumerable<string> children = node.RetrieveChildren();

                foreach (string child in children)
                {
                    Node childNode = node.TryGetChild(child, false);
                    childrenM ^= (ulong)childNode.Persisted.Id.GetHashCode();
                    measurement ^= this.Measure(ref numnodes, measureSessionId, childNode);
                }

                measurement ^= childrenM;
            }

            return measurement;
        }

        /// <summary>
        /// measures a single node
        /// </summary>
        /// <param name="pd">the node to measure</param>
        /// <returns>the hashcode for the node, and all its members</returns>
        private ulong Measure(IPersistedData pd)
        {
            ulong metric = 0;

            metric ^= (ulong)pd.Id.GetHashCode();

            metric ^= (ulong)pd.Name.GetHashCode();

            metric ^= (ulong)pd.Stat.GetHashCode();

            if (pd.Data != null)
            {
                ulong hc = (ulong)EqualityHelper.MeasureByteArrayWithSampling(pd.Data, maxSamplesForDataHashSet);

                metric ^= (ulong)hc;
            }

            if (pd.Acl != null)
            {
                foreach (Acl acl in pd.Acl)
                {
                    metric ^= (ulong)acl.GetHashCode();
                }
            }

            return metric;
        }

        /// <summary>
        /// processes a message configuring the session
        /// </summary>
        /// <param name="session">client session</param>
        /// <param name="initRequest">Init request that is the first request received in a client session</param>
        /// <param name="callId">Unique ID</param>
        /// <returns>Response object</returns>
        private RequestResponse ProcessSessionInitialization(ClientSession session, RequestInit initRequest, ulong callId)
        {
            string passwd;

            RmAssert.IsTrue(session != null, "session cannot be null");

            if (!string.IsNullOrEmpty(initRequest.SessionPwd))
            {
                passwd = initRequest.SessionPwd;
            }
            else
            {
                passwd = Guid.NewGuid().ToString();
            }

            session.Redirection = initRequest.Redirection;

            if (initRequest.Auth != null && initRequest.Auth.IsSuperSession)
            {
                session.ROInterfaceRequiresLocks = true;
            }
            else
            {
                session.ROInterfaceRequiresLocks = initRequest.RoInterfaceRequiresLocks;
            }

            RingMasterEventSource.Log.InitializeSession(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity);
            this.auditConsumer?.OnInitializeSession(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity);

            session.SetClientDigest(string.Empty);
            session.State = ClientSession.SessionState.Initialized;
            return new RequestResponse()
            {
                CallId = callId,
                ResultCode = (int)Code.Ok,
                Stat = null,
                Content = new string[] { string.Empty + session.SessionId, passwd },
            };
        }

        private RequestResponse ProcessMessage(IRingMasterBackendRequest request, ClientSession session)
        {
            Task taskReplication;
            return this.ProcessMessage(request, session, out taskReplication);
        }

        /// <summary>
        /// Processes a request from a session.
        /// </summary>
        /// <param name="request">The request.</param>
        /// <param name="session">The session this request comes from.</param>
        /// <param name="taskReplication">async task to indicate the replication completion on output</param>
        /// <returns>RequestResponse.</returns>
        /// <exception cref="System.TimeoutException">retriable exception exceeded maximum time alloted</exception>
        /// <exception cref="System.InvalidOperationException">Session  + session.SessionId +  is in a state calls are not allowed anymore:  + session.State</exception>
        private RequestResponse ProcessMessage(IRingMasterBackendRequest request, ClientSession session, out Task taskReplication)
        {
            RequestResponse response;

            taskReplication = null;

            if (!this.Factory.IsActive)
            {
                // If the factory is not active, we need to cancel the request now.
                RingMasterEventSource.Log.ProcessMessage_PersistedDataFactoryNotActive(session.SessionId, request.Uid);
                return this.OperationCancelled(request, session);
            }

            response = this.ValidateRequest(request, session);

            if (response != null)
            {
                RingMasterEventSource.Log.ProcessMessage_RequestValidationFailed(session.SessionId, request.Uid);
                return response;
            }

            SemaphoreRepository.ILockToken releaseToken = null;

            session.BeginInvocation();

            Stopwatch timer = Stopwatch.StartNew();
            try
            {
                if (request.ExecutionQueueId != Guid.Empty)
                {
                    if (!SemaphoreRepository.Instance.FindAndTryAcquire(request.ExecutionQueueId, request.ExecutionQueueTimeoutMillis, out releaseToken))
                    {
                        RingMasterEventSource.Log.ProcessMessage_FailedToAcquireExecutionQueue(session.SessionId, request.Uid, request.ExecutionQueueId.ToString());

                        return new RequestResponse() { ResponsePath = request.Path, Content = null, Stat = null, ResultCode = (int)Code.Waitqueuetimeoutonserver };
                    }
                }

                int retryCount = 0;

                do
                {
                    switch (session.State)
                    {
                        case ClientSession.SessionState.Terminating:
                            // If the session is terminating, we can just let the operation
                            // go for as long as it needs to, as we really need to execute this.
                            break;
                        case ClientSession.SessionState.Initialized:
                            // Under no circumstances we can take longer than MaxRetryOperation time
                            // for a regular invocation.
                            if (timer.ElapsedMilliseconds > MaxRetryOperationMillis)
                            {
                                RingMasterEventSource.Log.ProcessMessage_Timeout(session.SessionId, request.Uid, timer.ElapsedMilliseconds);

                                Trace.TraceError($"ServerOperationTimeout Thread-{Thread.CurrentThread.ManagedThreadId}");
                                return new RequestResponse() { ResponsePath = request.Path, ResultCode = (int)Code.ServerOperationTimeout };
                            }

                            break;
                        default:
                            throw new InvalidOperationException("Session " + session.SessionId + " is in a state calls are not allowed anymore: " + session.State);
                    }

                    response = this.BareProcessMessage(request, session, ref timer, ref retryCount, out taskReplication);
                }
                while (response == null);

                return response;
            }
            finally
            {
                if (releaseToken != null)
                {
                    SemaphoreRepository.Instance.Release(releaseToken);
                }

                session.EndInvocation();
            }
        }

        private RequestResponse BareProcessMessage(IRingMasterBackendRequest request, ClientSession session, ref Stopwatch timer, ref int retryCount, out Task taskReplication)
        {
            RequestResponse response = null;

            ILockListTransaction lockList = session.GetOrCreateLockList(request, this.lockDownPaths);

            // otherwise, go for it.
            try
            {
                taskReplication = null;
                response = this.DispatchRequest(request, session, lockList, false);

                Debug.Assert(response != null, $"{nameof(this.DispatchRequest)} should not return null, or the request will run forever");
                timer.Stop();

                // If writes are allowed for this session, then log information about each completed message.
                // the information is only logged to EventSource so it will not affect performance.
                if (session.WritesAllowed)
                {
                    RingMasterEventSource.Log.ProcessMessageSucceeded(session.SessionId, request.Uid, lockList.TxId, (int)request.RequestType, request.Path, timer.ElapsedMilliseconds);
                }
            }
            catch (InvalidAclException ex)
            {
                RingMasterServerInstrumentation.Instance.OnAuthFailed(ex);
                lockList.MarkForAbort();
                response = new RequestResponse() { ResultCode = (int)Code.Authfailed, Stat = null, Content = null };
            }
            catch (RetriableOperationException rex)
            {
                RingMasterEventSource.Log.ProcessMessageFailed(session.SessionId, request.Uid, lockList.TxId, retryCount, timer.ElapsedMilliseconds, rex.ToString());
                lockList.MarkForAbort();
                retryCount++;
            }
            catch (Exception ex)
            {
                RingMasterEventSource.Log.ProcessMessageFailed(session.SessionId, request.Uid, lockList.TxId, retryCount, timer.ElapsedMilliseconds, ex.ToString());
                lockList.MarkForAbort();

                RingMasterServerInstrumentation.Instance.OnUnexpectedException("RingMasterBackend.ProcessMessage", ex);

                Debug.Assert(false, string.Format("Unexpected exception {0}", ex));

                // no need to trace here. caller will.
                return new RequestResponse() { ResponsePath = request.Path, Content = null, Stat = null, ResultCode = (int)Code.Systemerror };
            }
            finally
            {
                session.IfNeededUnlockAllAndCloseChanges(lockList, out taskReplication);
            }

            return response;
        }

        /// <summary>
        /// Validates the request for the session and returns a response if the request is not valid.
        /// </summary>
        /// <param name="req">Backend request to validate</param>
        /// <param name="session">Client session</param>
        /// <returns>Response object if validation fails, or null if everything is good</returns>
        private RequestResponse ValidateRequest(IRingMasterBackendRequest req, ClientSession session)
        {
            if (req == null)
            {
                return this.BadApi(req, session);
            }

            if (req.RequestType == RingMasterRequestType.Init)
            {
                throw new InvalidOperationException("RequestInit can be issued only once in a session lifetime");
            }

            // shortcut this method if we know we are good
            if (this.WritesAllowed && session.WritesAllowed && session.ROInterfaceRequiresLocks)
            {
                return null;
            }

            bool isReadonly = false;
            bool isMulti = false;
            bool hasWatcher = false;

            bool considerCreateEphemeralAsReadOnly = this.IsInFullLockDown && session.Auth.IsSuperSession;

            // Only if we are in lockdown we may need to go in depth.
            bool allowDeepAnalysis = !this.WritesAllowed;

            isReadonly = this.IsReadOnlyRequest(req, considerCreateEphemeralAsReadOnly, allowDeepAnalysis, out isMulti, out hasWatcher);

            // root can go through and try commands even during lockdown
            if (!isReadonly && (!this.WritesAllowed || !session.WritesAllowed))
            {
                // if this is a single command, even if we are not supposed to do writes, let it through as a read-only operation
                if (this.RmCommands.IsCommand(req))
                {
                    isReadonly = true;
                }
                else
                {
                    return this.InLockDown(req, session);
                }
            }

            // for RW operations, we may want to disallow them
            if (!isReadonly)
            {
                if (!this.WritesAllowed)
                {
                    return this.BadApi(req, session);
                }

                if (!session.WritesAllowed)
                {
                    return this.BadAuth(req, session);
                }
            }

            // if the operation has a watcher and the session is lock-free, we don't want to allow it either.
            if (isReadonly && hasWatcher && !session.ROInterfaceRequiresLocks)
            {
                return this.BadApi(req, session);
            }

            return null;
        }

        private RequestResponse DispatchRequest(IRingMasterBackendRequest req, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            switch (req.RequestType)
            {
                case RingMasterRequestType.SetAuth:
                    return this.SetAuth((RequestSetAuth)req, session);

                case RingMasterRequestType.Create:
                    return this.Create((RequestCreate)req, session, lockList, null, hasAcquiredLocks);

                case RingMasterRequestType.Multi:
                    return this.Multi((RequestMulti)req, session, lockList, hasAcquiredLocks);

                case RingMasterRequestType.Batch:
                    return this.Batch((RequestBatch)req, session);

                case RingMasterRequestType.Delete:
                    return this.Delete((RequestDelete)req, session, lockList, hasAcquiredLocks);

                case RingMasterRequestType.Move:
                    return this.Move((RequestMove)req, session, lockList, hasAcquiredLocks);

                case RingMasterRequestType.Check:
                    return this.Check((RequestCheck)req, lockList, hasAcquiredLocks);

                case RingMasterRequestType.SetAcl:
                    return this.SetAcl((RequestSetAcl)req, session, lockList, hasAcquiredLocks);

                case RingMasterRequestType.SetData:
                    return this.SetData((RequestSetData)req, session, lockList, hasAcquiredLocks);

                case RingMasterRequestType.Exists:
                    return this.Exists((RequestExists)req, session, lockList, hasAcquiredLocks);

                case RingMasterRequestType.GetAcl:
                    return this.GetAcl((RequestGetAcl)req, lockList, hasAcquiredLocks);

                case RingMasterRequestType.GetChildren:
                    return this.GetChildren((RequestGetChildren)req, session, lockList, hasAcquiredLocks);

                case RingMasterRequestType.GetData:
                    return this.GetData((RequestGetData)req, session, lockList, hasAcquiredLocks);

                case RingMasterRequestType.Sync:
                    return this.Sync((RequestSync)req, lockList, hasAcquiredLocks);

                case RingMasterRequestType.InternalRun:
                    return this.InternalRun((RequestInternalRun)req, lockList);

                default:
                    break;
            }

            Trace.TraceWarning("Bad RequestType found: {0}", req.RequestType);
            return new RequestResponse() { ResultCode = (int)Code.Apierror, Stat = null, Content = null };
        }

        /// <summary>
        /// Executes within a transaction an internal action.
        /// </summary>
        /// <param name="req">The request modeling the internal action.</param>
        /// <param name="lockList">The lock list to use.</param>
        /// <returns>RequestResponse of the action.</returns>
        private RequestResponse InternalRun(RequestInternalRun req, ILockListTransaction lockList)
        {
            bool abort = true;

            try
            {
                RequestResponse resp = req.ActionToRun(req, lockList);
                abort = false;
                return resp;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Returns true if the request is read only for the tree. It also indicates some metadata.
        /// NOTE: Multi is considered read-write due to its potential.
        /// </summary>
        /// <param name="req">the request</param>
        /// <param name="isMulti">indicates if the request is multi</param>
        /// <param name="hasWatcher">indicates if the request has watchers</param>
        /// <returns>true if the request is read-only</returns>
        private bool IsReadOnlyRequest(IRingMasterBackendRequest req, out bool isMulti, out bool hasWatcher)
        {
            return this.IsReadOnlyRequest(req, false, false, out isMulti, out hasWatcher);
        }

        /// <summary>
        /// Returns true if the request is read only for the tree. It also indicates some metadata.
        /// Multi and Batch are explored in depth if goInDepth is true.
        /// </summary>
        /// <param name="req">the request</param>
        /// <param name="considerCreateEphemeralAsReadOnly">if true, create for ephemerals will be treated as readonly</param>
        /// <param name="goInDepth">if true, batch and multi are explored in depth</param>
        /// <param name="isMulti">indicates if the request is multi</param>
        /// <param name="hasWatcher">indicates if the request has watchers</param>
        /// <returns>true if the request is read-only</returns>
        private bool IsReadOnlyRequest(IRingMasterBackendRequest req, bool considerCreateEphemeralAsReadOnly, bool goInDepth, out bool isMulti, out bool hasWatcher)
        {
            hasWatcher = false;
            isMulti = false;

            switch (req.RequestType)
            {
                case RingMasterRequestType.Multi:
                case RingMasterRequestType.Batch:
                    {
                        isMulti = true;
                        bool result = true;

                        if (goInDepth)
                        {
                            IRingMasterBackendCompondRequest mreq = (IRingMasterBackendCompondRequest)req;

                            // go in depth
                            if (mreq.Requests != null)
                            {
                                foreach (IRingMasterBackendRequest r in mreq.Requests)
                                {
                                    bool auxMulti;
                                    bool auxWatcher;
                                    bool isro = this.IsReadOnlyRequest(r, considerCreateEphemeralAsReadOnly, goInDepth, out auxMulti, out auxWatcher);
                                    if (auxWatcher)
                                    {
                                        hasWatcher = true;
                                    }

                                    if (!isro)
                                    {
                                        result = false;
                                    }
                                }
                            }
                        }

                        return result;
                    }

                case RingMasterRequestType.Create:
                    if (considerCreateEphemeralAsReadOnly)
                    {
                        RequestCreate crreq = (RequestCreate)req;

                        if (crreq.CreateMode == CreateMode.Ephemeral || crreq.CreateMode == CreateMode.EphemeralSequential)
                        {
                            return true;
                        }
                    }

                    return false;
                case RingMasterRequestType.Delete:
                case RingMasterRequestType.SetAcl:
                case RingMasterRequestType.SetData:
                    return false;
                case RingMasterRequestType.Exists:
                    hasWatcher = ((RequestExists)req).Watcher != null;
                    return true;
                case RingMasterRequestType.GetData:
                    hasWatcher = ((RequestGetData)req).Watcher != null;
                    return true;
                case RingMasterRequestType.GetChildren:
                    hasWatcher = ((RequestGetChildren)req).Watcher != null;
                    return true;
                case RingMasterRequestType.SetAuth:
                // set auth is readonly for the tree
                case RingMasterRequestType.Check:
                // check is read only for the tree
                case RingMasterRequestType.GetAcl:
                // getacl is read only for the tree
                case RingMasterRequestType.Sync:
                // sync is read only for the tree
                case RingMasterRequestType.None:
                    // none is read only for the tree
                    return true;
            }

            return true;
        }

        /// <summary>
        /// sets the session identity to be the given one.
        /// </summary>
        /// <param name="req">Set auth request</param>
        /// <param name="session">Client session</param>
        /// <returns>the response to the query</returns>
        private RequestResponse SetAuth(RequestSetAuth req, ClientSession session)
        {
            session.SetClientDigest(req.ClientId);

            RingMasterEventSource.Log.SetAuth(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, session.Auth.ClientDigest);
            this.auditConsumer?.OnSetAuth(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, session.Auth.ClientDigest, session.Auth.IsSuperSession);

            return new RequestResponse()
            {
                ResultCode = (int)Code.Ok,
                Stat = null,
                Content = null,
            };
        }

        /// <summary>
        /// returns a bad api result.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse BadApi(IRingMasterBackendRequest req, ClientSession session)
        {
            Trace.TraceInformation("BadApi is returned for request {0} on session {1}", req == null ? "null" : req.RequestType.ToString(), session == null ? "null" : session.FriendlyName);
            return new RequestResponse() { ResultCode = (int)Code.Apierror, Stat = null, Content = null };
        }

        /// <summary>
        /// returns a InLockDown result.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse InLockDown(IRingMasterBackendRequest req, ClientSession session)
        {
            Trace.TraceInformation("InLockDown is returned for request {0} on session {1}", req == null ? "null" : req.RequestType.ToString(), session == null ? "null" : session.FriendlyName);
            return new RequestResponse() { ResultCode = (int)Code.InLockDown, Stat = null, Content = null };
        }

        /// <summary>
        /// Returns a response indicating that the operation was cancelled.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse built as operation cancelled</returns>
        private RequestResponse OperationCancelled(IRingMasterBackendRequest req, ClientSession session)
        {
            Trace.TraceInformation("OperationCancelled is returned for request {0} on session {1}", req == null ? "null" : req.RequestType.ToString(), session == null ? "null" : session.FriendlyName);
            return new RequestResponse() { ResultCode = (int)Code.OperationCancelled, Stat = null, Content = null };
        }

        /// <summary>
        /// returns a bad auth result.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse BadAuth(IRingMasterBackendRequest req, ClientSession session)
        {
            Trace.TraceInformation("BadAuth is returned for request {0} on session {1}", req == null ? "null" : req.RequestType.ToString(), session == null ? "null" : session.FriendlyName);
            return new RequestResponse() { ResultCode = (int)Code.Authfailed, Stat = null, Content = null };
        }

        /// <summary>
        /// Creates the data.
        /// </summary>
        /// <param name="factory">The factory.</param>
        /// <param name="lockList">the transaction context.</param>
        /// <param name="name">The name.</param>
        /// <param name="acl">The acl.</param>
        /// <param name="data">The data.</param>
        /// <param name="isMountPoint">Whether the node is a mount point</param>
        /// <returns>IPersistedData.</returns>
        private IPersistedData CreateData(IPersistedDataFactory<Node> factory, ILockListTransaction lockList, string name, IReadOnlyList<Acl> acl, byte[] data, bool isMountPoint)
        {
            long zxid = lockList.TxId;
            long now = lockList.TxTime;

            if (acl != null && acl.Count == 0)
            {
                acl = null;
            }

            IPersistedData persisted;

            persisted = factory.CreateNew();

            lockList.RunOnAbort(() =>
            {
                factory.Delete(persisted);
            });

            persisted.Name = name;

            if (!isMountPoint)
            {
                persisted.Data = data;

                persisted.Acl = acl;

                if (persisted.IsEphemeral)
                {
                    persisted.Stat = new MutableStat(zxid, zxid, now, now, 1, 1, 1, data == null ? 0 : data.Length, 0, zxid);
                }
                else
                {
                    persisted.Stat = new FirstStat(zxid, now, data == null ? 0 : data.Length);
                }
            }

            factory.RecordDataDelta(persisted.Stat.DataLength);

            return persisted;
        }

        private void ValidateEphemeralStats()
        {
            ((IUnsafeTreeAccess)this).LockRoot();
            try
            {
                ulong count = (ulong)this.ScanForEphemeral(this.Root).Count();
                if (count != this.EphemeralFactory.TotalNodes)
                {
                    Console.WriteLine("count={0};ephemeral.count={1}", count, this.EphemeralFactory.TotalNodes);
                    Debugger.Launch();
                    Debugger.Break();
                }
            }
            finally
            {
                ((IUnsafeTreeAccess)this).ReleaseRoot();
            }
        }

        private string ScanForEphemeral()
        {
            StringBuilder sb = new StringBuilder();
            foreach (Node n in this.ScanForEphemeral(this.Root))
            {
                sb.AppendLine(n.BuildPath());
            }

            return sb.ToString();
        }

        private IEnumerable<Node> ScanForEphemeral(Node root)
        {
            foreach (IPersistedData child in root.ChildrenMapping.Values)
            {
                if (child.IsEphemeral)
                {
                    yield return child.Node;
                }

                if (child.GetChildrenCount() > 0)
                {
                    foreach (Node n in this.ScanForEphemeral(child.Node))
                    {
                        yield return n;
                    }
                }
            }
        }

        private RequestResponse Mount(RequestInternalRun req, ILockListTransaction lockList, ClientSession ses, string filename, bool allowremount, bool mountroot)
        {
            // if mountroot is true, move the current root to prevoiusroot, and set as root what we get from the mount.
            // also make sure we move into readonly mode.
            if (!mountroot)
            {
                string nodepath = req.Path;
                Node child = null;
                Node parent;
                child = this.Root.GetNode(nodepath, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.WRITE, out parent);

                if (!allowremount && child != null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nodeexists,
                        Stat = null,
                        Content = null,
                    };
                }

                var hasAcquiredLocks = false;

                if (child != null)
                {
                    if (!child.Persisted.IsEphemeral)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Noauth,
                            Stat = null,
                            Content = null,
                        };
                    }

                    RequestResponse resp = this.Unmount(nodepath, lockList, ses);

                    if (resp.ResultCode != (int)Code.Ok)
                    {
                        return resp;
                    }
                    else
                    {
                        hasAcquiredLocks = true;
                    }

                    child = null;
                }

                // create child as ephemeral, providing factory
                RequestCreate cr = new RequestCreate(nodepath, null, null, null, CreateMode.Ephemeral, null);

                RequestResponse reso = this.Create(cr, ses, lockList, filename, hasAcquiredLocks);

                return reso;
            }
            else
            {
                // must allow remount
                if (!allowremount)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nodeexists,
                        Stat = null,
                        Content = null,
                    };
                }

                // must be the root path
                string nodepath = req.Path;
                if (!string.Equals("/", req.Path))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = null,
                    };
                }

                // plan B: if things fail, set things back to the current state.
                {
                    Node prevRoot = this.Root;
                    Node prev_prevRoot = this.previousRoot;

                    lockList.RunOnAbort(() =>
                    {
                        this.previousRoot = prev_prevRoot;
                        this.Root = prevRoot;
                    });
                }

                // if the filename is '<previous>' this is a 'go back to previous' operation
                if (string.Equals(filename, "<previous>"))
                {
                    if (this.previousRoot != null)
                    {
                        this.Root = this.previousRoot;
                        this.previousRoot = null;
                    }

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Ok,
                        Stat = null,
                        Content = null,
                    };
                }

                // else, try yo mount the file
                IPersistedDataFactory<Node> persFact = this.EphemeralMountPointFactory(filename);
                persFact.Activate(this, this);
                IPersistedData childData = this.CreateData(persFact, lockList, string.Empty, null, null, true);

                // we are done. return the node we have
                lockList.RunOnCommit(() =>
                {
                    // set the tree in lockdown
                    this.IsInFullLockDown = true;
                    this.previousRoot = this.Root;
                    this.Root = childData.Node;
                });

                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = null,
                    Content = null,
                };
            }
        }

        private RequestResponse BuildTreeFile(RequestInternalRun req, ILockListTransaction lockList, int version, string filename)
        {
            string nodepath = req.Path;
            Node child = null;
            Node parent;
            child = this.Root.GetNode(nodepath, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.WRITE, out parent);

            if (child == null)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Nonode,
                    Stat = null,
                    Content = null,
                };
            }

            // note we have acquired "child" in RW, so nothing under it can do writes now, but it is possible
            // that we have some ongoing transaction doing writes under it.
            // to be 100% consistent, this method should instead of taking a RW lock on child, take a RO lock on all nodes under it.
            IPersistedDataFactory<Node> factory = this.EphemeralMountPointFactory(null);

            bool cancelled = false;
            lockList.LockAll(ref cancelled);
            bool ok = factory.TakeCheckpoint(child.Persisted, filename, version);

            return new RequestResponse()
            {
                ResponsePath = nodepath,
                ResultCode = ok ? (int)Code.Ok : (int)Code.Unknown,
                Stat = null,
                Content = null,
            };
        }

        private RequestResponse Unmount(string nodepath, ILockListTransaction lockList, ClientSession ses)
        {
            Node child = null;
            Node parent;
            child = this.Root.GetNode(nodepath, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.WRITE, out parent);

            if (child == null)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Nonode,
                    Stat = null,
                    Content = null,
                };
            }

            IMountPointNode mp = child as IMountPointNode;
            if (mp == null)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Noauth,
                    Stat = null,
                    Content = null,
                };
            }

            lockList.RunOnCommit(() =>
            {
                mp.Close();
            });

            RequestDelete del = new RequestDelete(nodepath, null, -1, null);

            return this.Delete(del, ses, lockList, false);
        }

        /// <summary>
        /// Imports a checkpoint from the given location, and terminates this process.
        /// </summary>
        /// <param name="location">The location of the checkpoint file.</param>
        /// <returns><c>true</c> if import succeeded and failover will happen soon, <c>false</c> otherwise.</returns>
        private bool ImportCheckpoint(string location)
        {
            bool result = false;
            try
            {
                if (!File.Exists(location))
                {
                    throw new FileNotFoundException("location");
                }

                result = this.Factory.ImportCheckpoint(location);

                if (!result)
                {
                    Trace.TraceWarning("ImportCheckpoint failed: Factory returned false");
                }
            }
            catch (Exception e)
            {
                Trace.TraceWarning("ImportCheckpoint failed: {0}", e);
            }

            return result;
        }

        /// <summary>
        /// Downloads the URL into the given location.
        /// </summary>
        /// <param name="urlAndDestination">The URL and the destination, encoded in an 'arguments' string.</param>
        /// <returns>true if the download was successful</returns>
        private bool DownloadUrlIntoLocation(string urlAndDestination)
        {
            DownloadUrlIntoLocationFunctionDelegate download = DownloadUrlIntoLocationFunction;

            if (download == null)
            {
                return false;
            }

            Task.Run(() =>
            {
                return download(urlAndDestination);
            });

            return true;
        }

        /// <summary>
        /// Creates the specified req.
        /// </summary>
        /// <param name="request">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">The session's locklist.</param>
        /// <param name="useEphemeralMountPointFactory">For mount request specify a file name, otherwise keep it null</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Create(
            RequestCreate request,
            ClientSession session,
            ILockListTransaction lockList,
            string useEphemeralMountPointFactory,
            bool hasAcquiredLocks)
        {
            ////Trace.TraceInformation($"Thread-{Thread.CurrentThread.ManagedThreadId} Create: {request.Path} - {hasAcquiredLocks}");

            CreateMode createMode = request.CreateMode;
            bool mustAllowPathCreation = createMode.HasFlag(CreateMode.AllowPathCreationFlag);
            bool isEphemeral = createMode.HasFlag(CreateMode.Ephemeral);

            // CreateMode.AllowPathCreationFlag is not compatible with CreateMode.Ephemeral or CreateMode.EphemeralSequential
            // because intermediate nodes (if any) would have to be created as persistent nodes.
            if (isEphemeral && mustAllowPathCreation)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Badarguments,
                    Stat = null,
                    Content = null,
                };
            }

            if (this.RmCommands.IsCommand(request.Path))
            {
                RingMasterEventSource.Log.RequestCommand(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, request.Path);
                this.auditConsumer?.OnRequestCommand(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, request.Path);
                return this.RmCommands.RunCommand(request, session, lockList);
            }

            bool abort = true;
            try
            {
                Stopwatch timer = Stopwatch.StartNew();
                int parentlevel;
                string lastChildName;
                Node lastMatch;

                Node parent = this.Root.GetPathParent(request.Path, lockList, Node.WildCardBehavior.NotAllowed, out lastChildName, out lastMatch, out parentlevel);

                if (parent == null && mustAllowPathCreation)
                {
                    // create the whole path before the last one.
                    string[] pathpieces = request.Path.Split('/');

                    // we assume the path starts with a '/'
                    if (pathpieces.Length > 0 && string.Empty.Equals(pathpieces[0]))
                    {
                        // Intermediate parent nodes must be persistent (Ephemeral nodes can't have children and
                        // PersistentSequential does not make sense for parent nodes). Multiple requests under the
                        // same non-existing parent node may come at the same time and attempt to create the same
                        // parent. One of them will succeed, but others should not fail (which will cause the entire
                        // creation to fail).
                        RequestCreate req1 = new RequestCreate(string.Empty, null, null, null, CreateMode.Persistent | CreateMode.SuccessEvenIfNodeExistsFlag, null);

                        bool mustStop = false;
                        for (int i = 1; !mustStop && i < pathpieces.Length - 1; i++)
                        {
                            req1.Path = req1.Path + "/" + pathpieces[i];
                            Node pathNode = this.Root.GetNode(req1.Path, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.READ, out parent);
                            if (pathNode == null)
                            {
                                if (parentlevel == -1)
                                {
                                    parent = this.Root.GetPathParent(req1.Path, lockList, Node.WildCardBehavior.NotAllowed, out lastChildName, out lastMatch, out parentlevel);
                                }
                                else
                                {
                                    parentlevel++;
                                }

                                RequestResponse resp = this.CreateSingleNode(parent, pathpieces[i], session, req1, useEphemeralMountPointFactory, parentlevel, lockList, hasAcquiredLocks, timer, out abort);

                                // The parent node exists but child doesn't, after the call the lock should have been acquired.
                                hasAcquiredLocks = true;

                                if (resp.ResultCode != (int)Code.Ok)
                                {
                                    mustStop = true;
                                }
                            }
                        }

                        parent = this.Root.GetPathParent(request.Path, lockList, Node.WildCardBehavior.NotAllowed, out lastChildName, out lastMatch, out parentlevel);
                    }
                }

                return this.CreateSingleNode(parent, lastChildName, session, request, useEphemeralMountPointFactory, parentlevel, lockList, hasAcquiredLocks, timer, out abort);
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestCreateFailed(session.SessionId, request.Uid, request.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        private RequestResponse CreateSingleNode(
            Node parent,
            string childName,
            ClientSession session,
            RequestCreate request,
            string useEphemeralMountPointFactory,
            int parentlevel,
            ILockListTransaction lockList,
            bool hasAcquiredLocks,
            Stopwatch timer,
            out bool abort)
        {
            abort = true;
            CreateMode createMode = request.CreateMode;
            bool mustSucceedEvenIfNodeExists = createMode.HasFlag(CreateMode.SuccessEvenIfNodeExistsFlag);
            bool isEphemeral = createMode.HasFlag(CreateMode.Ephemeral);
            bool isSequential = createMode.HasFlag(CreateMode.Sequential);

            if (parent == null)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Nonode,
                    Stat = null,
                    Content = null,
                };
            }

            if (string.IsNullOrEmpty(childName))
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Nonode,
                    Stat = null,
                    Content = null,
                };
            }

            if (parent.Persisted.IsEphemeral)
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Nochildrenforephemerals,
                    Stat = null,
                    Content = null,
                };
            }

            if (this.limits.MaxNodeNameLength > 0 && childName.Length > this.limits.MaxNodeNameLength && !SessionIsLimitExempt(session))
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Badarguments,
                    Stat = null,
                    Content = string.Format("Node name exceeds maximum node name length of {0}", this.limits.MaxNodeNameLength),
                };
            }

            if (request.Path != null && this.limits.MaxNodePathLength > 0 && request.Path.Length > this.limits.MaxNodePathLength && !SessionIsLimitExempt(session))
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Badarguments,
                    Stat = null,
                    Content = string.Format("Node path length exceeds maximum of {0} characters", this.limits.MaxNodePathLength),
                };
            }

            if (request.Data != null && this.limits.MaxNodeDataSize > 0 && request.Data.Length > this.limits.MaxNodeDataSize && !SessionIsLimitExempt(session))
            {
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Badarguments,
                    Stat = null,
                    Content = string.Format("Data size exceeds maximum of {0} bytes", this.limits.MaxNodeDataSize),
                };
            }

            if (request.Acl != null)
            {
                string aclValidationErrorMessage;
                if (!this.ValidateAclLimits(request.Acl, session, out aclValidationErrorMessage))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = aclValidationErrorMessage,
                    };
                }
            }

            // req.Path is not / and lastChildName.Length > 0 at this point.
            string parentpath = request.Path.Substring(0, request.Path.Length - childName.Length - 1);
            if (string.IsNullOrEmpty(parentpath))
            {
                parentpath = "/";
            }

            IPersistedDataFactory<Node> persFact;

            if (!isEphemeral)
            {
                persFact = this.Factory;
            }
            else
            {
                if (useEphemeralMountPointFactory != null)
                {
                    persFact = this.EphemeralMountPointFactory(useEphemeralMountPointFactory);
                    persFact.Activate(this, this);
                }
                else
                {
                    persFact = this.EphemeralFactory;
                }
            }

            // At this point we know the parent node exists, and the child nodes does not. We just need to know
            // if the request is from recursion (i.e. path creation) or other request.
            // Top-level writer lock on this path, no more lock is needed
            lockList.AddLockRw(parent, Perm.CREATE, parentlevel, isEphemeral);
            if (!hasAcquiredLocks)
            {
                var cancelledd = false;
                lockList.LockAll(ref cancelledd);
                hasAcquiredLocks = true;
            }

            if (isSequential)
            {
                childName += parent.Persisted.Stat.Cversion.ToString("D10");
            }

            Node child = parent.TryGetChild(childName, false);

            if (child != null)
            {
                if (!isSequential && mustSucceedEvenIfNodeExists)
                {
                    abort = false;

                    var reqCallback = request.Callback == null
                            ? (StatCallbackDelegate)null
                            : (int rc, string path, object ctx, IStat stat) => { request.Callback(rc, path, ctx, null); };

                    // this is truly a setdata operation, since the node already exists and it is allowed from createmode.
                    RequestSetData setdatarequest = new RequestSetData(
                        path: request.Path,
                        context: request.Context,
                        data: request.Data,
                        version: child.Persisted.Stat.Version,
                        callback: reqCallback,
                        dataCommand: false);

                    // We should have acquired writer lock on the parent node. No need to acquire any lock in the new request.
                    RequestResponse resp = this.SetData(setdatarequest, session, lockList, hasAcquiredLocks);

                    if (resp.ResultCode == (int)Code.Ok)
                    {
                        // content will be null, indicating the creation was not needed, and this was a setdata operation
                        resp.Content = null;
                    }

                    return resp;
                }
                else
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nodeexists,
                        Stat = child.NodeStat,
                        Content = child.Name,
                    };
                }
            }

            IReadOnlyList<Acl> newAcl = null;
            if (request.Acl != null && request.Acl.Count > 0)
            {
                newAcl = request.Acl;
            }

            IPersistedData childData = this.CreateData(persFact, lockList, childName, newAcl, request.Data, useEphemeralMountPointFactory != null);

            ((IUnsafeTreeAccess)this).UnsafeCreate(childData, lockList.TxTime, request.Path, lockList.TxId, lockList);

            child = childData.Node;

            // This is to verify ACL of the child node
            lockList.AddLockRw(child, Perm.WRITE, parentlevel + 1);

            IMutableStat prevStat = lockList.SnapStatIfNeeded(parent.Persisted);

            ((IUnsafeTreeAccess)this).UnsafeAddChild(parent.Persisted, child.Persisted, lockList.TxTime, parentpath, lockList.TxId, lockList);

            lockList.AppendCreate(persFact, childData, lockList.TxTime);
            lockList.AppendAddChild(parent.Persisted, childData, lockList.TxTime, prevStat);

            lockList.RunOnCommit(() =>
            {
                if (child.Persisted.IsEphemeral)
                {
                    RingMasterServerInstrumentation.Instance.UpdateEphemeralNodeCounts(this.EphemeralFactory.TotalData, this.EphemeralFactory.TotalNodes);
                }
                else
                {
                    RingMasterServerInstrumentation.Instance.UpdatePersistentNodeCounts(this.Factory.TotalData, this.Factory.TotalNodes);
                }

                // if the child is ephemeral, we need to get rid of it when the session ends.
                if (childData.IsEphemeral)
                {
                    // make sure the path is right. Specially if this is sequential
                    string path = request.Path;

                    if (createMode.HasFlag(CreateMode.Sequential))
                    {
                        path = path.Substring(0, path.LastIndexOf('/')) + "/" + childData.Name;
                    }

                    session.AddOnTerminateAction("oid-" + child.GlobalUniqueId, (terminating) =>
                    {
                        Trace.TraceInformation("cleaning up ephemeral oid-{0} @ {1}", childData.Id, path);
                        Stopwatch sw = Stopwatch.StartNew();
                        int count = 0;

                        // This task is useless for ephemeral nodes, don't await it.
                        Task taskReplication;

                        while (this.BareProcessMessage(new RequestDelete(path, null, -1, null), session, ref sw, ref count, out taskReplication) == null)
                        {
                            if (sw.ElapsedMilliseconds > MaxRetryOperationMillis)
                            {
                                Trace.TraceError("We couldn't cleanup the ephemeral oid-{0} @ {1} on time", childData.Id, path);
                                Debugger.Launch();
                                break;
                            }
                        }
                    });
                }
            });

            abort = false;

            RingMasterEventSource.Log.RequestCreateSucceeded(session.SessionId, request.Uid, request.Path, timer.ElapsedMilliseconds);
            return new RequestResponse()
            {
                ResultCode = (int)Code.Ok,
                Stat = child.NodeStat,
                Content = child.Name,
            };
        }

        /// <summary>
        /// Completes the change.
        /// </summary>
        /// <param name="pd">the persisted data object to update</param>
        /// <param name="zxid">The zxid.</param>
        /// <param name="txtime">The tx_time.</param>
        /// <param name="chg">The CHG.</param>
        /// <param name="delta">Delta of the data size</param>
        private void UpdateStat(IPersistedData pd, long zxid, long txtime, ChangeKind chg, int delta = 0)
        {
            if (pd == null)
            {
                throw new ArgumentNullException(nameof(pd));
            }

            IMutableStat stat = pd.Stat;

            if (chg != ChangeKind.NodeCreated)
            {
                stat = CompleteNode.EnsureCompleteStat(pd);
                stat.Mtime = txtime;
                stat.Mzxid = zxid;
            }

            switch (chg)
            {
                case ChangeKind.ChildrenAdded:
                    stat.NumChildren++;
                    stat.Cversion++;
                    stat.Pzxid = zxid;
                    break;
                case ChangeKind.ChildrenRemoved:
                    stat.NumChildren--;
                    stat.Cversion++;
                    stat.Pzxid = zxid;
                    break;
                case ChangeKind.DataChanged:
                    stat.Version++;
                    stat.DataLength += delta;
                    RmAssert.IsTrue(pd.Stat.DataLength >= 0);
                    break;
                case ChangeKind.AclChanged:
                    stat.Aversion++;
                    break;
                case ChangeKind.NodeDeleted:
                    stat.Version++;
                    break;
                case ChangeKind.NodeCreated:
                case ChangeKind.None:
                    break;
            }

            pd.Stat = stat;
        }

        /// <summary>
        /// Executes the specified req.
        /// </summary>
        /// <param name="request">The req.</param>
        /// <param name="session">the session</param>
        /// <param name="lockList">The session's lockList.</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Multi(RequestMulti request, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            RingMasterEventSource.Log.Multi(request.Uid, request.Requests.Count, request.CompleteSynchronously);

            // For multi the request can set synchronous commit.
            // Note that if we have nested multis we must complete synchronously if any of the multis
            // have the synchronous flag set so we never flip synchronous to asynchronous.
            if (!lockList.FinishSynchronous)
            {
                lockList.FinishSynchronous = request.CompleteSynchronously;
            }

            if (request.ScheduledName != null)
            {
                return this.ScheduleMulti(request, session, lockList, hasAcquiredLocks);
            }

            List<OpResult> results = new List<OpResult>();

            Timer timer = null;
            try
            {
                var cancelled = false;
                timer = new Timer(obj => { cancelled = true; }, null, this.limits.MaxMultiExecutionMilliseconds, Timeout.Infinite);

                // No need to do the "lock round" if RO interface does not require locks.
                // However still need "lock round" for read operations for RW interface because we may
                // take read lock on /y while another thread takes write lock on /x. We then try to
                // read lock /x and the other thread write lock /y and we have deadlock.
                if (!hasAcquiredLocks && session.ROInterfaceRequiresLocks)
                {
                    // lock IN ORDER the accessed paths
                    this.LockMultiPathsInOrder(request, lockList, ref cancelled);
                    if (cancelled)
                    {
                        lockList.MarkForAbort();
                        return new RequestResponse
                        {
                            ResultCode = (int)Code.ServerOperationTimeout,
                            Stat = default(Stat),
                        };
                    }
                }

                // now execute the operations as specified in the request.
                // Note: more locking may happen if op1 is create 'some/path' and op2 is create 'some/path/later'
                foreach (var innerRequest in request.Requests)
                {
                    RequestResponse response = this.ValidateRequest(innerRequest, session);

                    if (response == null)
                    {
                        // Indicates that the all locks have been acquired.
                        response = this.DispatchRequest(innerRequest, session, lockList, true);
                    }

                    OpResult opr = OpResult.GetOpResult(innerRequest.RequestType, response);

                    results.Add(opr);

                    if (opr.ErrCode != Code.Ok || lockList.IsMarkedForAbort())
                    {
                        lockList.MarkForAbort();
                        break;
                    }
                }

                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = default(Stat),
                    Content = results,
                };
            }
            catch (TaskCanceledException)
            {
                lockList.MarkForAbort();
                RingMasterEventSource.Log.MultiTimeout(request.Uid, request.Requests.Count, results.Count, MaxRetryOperationMillis);

                throw;
            }
            finally
            {
                timer?.Dispose();
            }
        }

        /// <summary>
        /// Schedules the multi.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">The lock list.</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse ScheduleMulti(RequestMulti req, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            string scheduledName = req.ScheduledName;
            req.ScheduledName = null;

            Stopwatch timer = Stopwatch.StartNew();
            IRingMasterBackendRequest[] reqs = new IRingMasterBackendRequest[1];
            reqs[0] = new RequestCreate(ScheduledCommand.GetCommandPath(scheduledName), null, ScheduledCommand.GetBytes(req, new MarshallerChannel(null)), null, CreateMode.Persistent, null);
            RequestResponse response = this.Multi(new RequestMulti(reqs, context: null, callback: (OpsResultCallbackDelegate)null, completeSynchronously: req.CompleteSynchronously, scheduledName: null), session, lockList, hasAcquiredLocks);

            RingMasterEventSource.Log.ScheduleMultiCompleted(session.SessionId, req.Uid, scheduledName, timer.ElapsedMilliseconds);
            return response;
        }

        /// <summary>
        /// Executes the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">the session</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Batch(RequestBatch req, ClientSession session)
        {
            RingMasterEventSource.Log.Batch(req.Uid, req.Requests.Count, req.CompleteSynchronously);

            bool needsSync = req.CompleteSynchronously;

            List<OpResult> results = new List<OpResult>(req.Requests.Count);

            Stopwatch timer = Stopwatch.StartNew();

            // If the request is associated with the transaction manager execution queue, then the request
            // came from the transaction manager.
            bool isFromTransactionManager = (req.ExecutionQueueId == TransactionManagerExecutionQueueId) || (req.Auth?.ClientIdentity == "TransactionManager");
            ulong batchId = req.Uid;
            ulong timeStreamId = req.TimeStreamId;
            ulong minTransactionId = ulong.MaxValue;
            ulong maxTransactionId = ulong.MinValue;
            ulong transactionId = ulong.MinValue;
            TimeStreamInfo timeStream = null;

            // If the request came from the transaction manager, verify that
            // the request's batch id is strictly one more than the last applied batch id
            // This will ensure that batches are applied in the order that they are supposed to be
            // applied and the same batch is not applied twice.
            if (isFromTransactionManager)
            {
                lock (this.timeStreamInfo)
                {
                    if (!this.timeStreamInfo.TryGetValue(timeStreamId, out timeStream))
                    {
                        timeStream = new TimeStreamInfo();
                        this.timeStreamInfo.Add(timeStreamId, timeStream);
                    }
                }

                if ((timeStream.LastAppliedBatchId != ulong.MaxValue) && (batchId != timeStream.LastAppliedBatchId + 1))
                {
                    RingMasterEventSource.Log.ApplyBatch_BatchIdNotInSequence(timeStreamId, batchId, timeStream.LastAppliedBatchId);
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Apierror,
                    };
                }
            }

            // now execute the operations as specified in the request.
            for (int i = 0; i < req.Requests.Count; i++)
            {
                IRingMasterBackendRequest req_i = req.Requests[i];

                OpResult opr;

                RequestResponse res = this.ValidateRequest(req_i, session);

                if (res == null)
                {
                    bool previousValueForRequestSynchronous = false;

                    bool isLast = i == req.Requests.Count - 1;

                    this.OverrideRequestSynchronization(req_i, isLast, ref previousValueForRequestSynchronous, ref needsSync);

                    // If the batch came from the transaction manager, Verify that each request in the batch is in
                    // strictly increasing order of transaction ids and the first transaction id in the batch is exactly
                    // one more than the last transaction that was applied.
                    if (isFromTransactionManager && (req_i.Overrides != null))
                    {
                        transactionId = req_i.Overrides.TxId;

                        minTransactionId = Math.Min(minTransactionId, transactionId);
                        maxTransactionId = Math.Max(maxTransactionId, transactionId);

                        if (timeStream.LastSeenTransactionId != ulong.MaxValue)
                        {
                            // We are applying a batch where each request in the batch has a transaction id.  The requests in the batch
                            // are applied one after the other.  Each request's transaction id must be strictly one more than the transaction id
                            // of the previous request seen for this time stream.  The transaction Id of the last *successful* request is recorded in a node in this RM. When the
                            // TM retries a batch, it reads the last successful transaction id from RM and issues the retry.  In that case, the transaction id
                            // in the batch may be less than what we expect.  When that happens, we increment a counter.
                            if (transactionId != timeStream.LastSeenTransactionId + 1)
                            {
                                RingMasterEventSource.Log.ApplyBatch_ExternalTransactionIdNotInSequence(timeStreamId, batchId, transactionId, timeStream.LastSeenTransactionId);
                                RingMasterServerInstrumentation.Instance.OnIncorrectExternalTransactionId(transactionId, timeStream.LastSeenTransactionId + 1);
                            }
                        }

                        timeStream.LastSeenTransactionId = transactionId;
                    }

                    // If the individual request within the batch does not have its own auth,
                    // set the auth from the batch request.
                    if (req_i.Auth == null)
                    {
                        req_i.Auth = req.Auth;
                    }

                    res = this.ProcessMessage(req_i, session);

                    this.RestoreRequestSynchronization(req_i, previousValueForRequestSynchronous);
                }

                opr = OpResult.GetOpResult(req_i.RequestType, res);

                // If the first request in the batch has succeeded then mark this batch id as the last
                // applied batch id.
                if ((i == 0) && isFromTransactionManager && (opr.ErrCode == Code.Ok))
                {
                    RmAssert.IsTrue(opr.ResultType == OpCode.SetData);
                    timeStream.LastAppliedBatchId = batchId;
                }

                results.Add(opr);

                if (timer.ElapsedMilliseconds > this.limits.MaxBatchExecutionMilliseconds)
                {
                    RingMasterEventSource.Log.BatchTimeout(batchId, req.Requests.Count, i, timer.ElapsedMilliseconds);
                    break;
                }

                // If the result of the request came back as OperationCancelled, that means the server is shutting down and
                // we need to stop processing. We'll return whatever results we have accumulated so far, but the client
                // cannot necessarily rely on them because we don't actually honor synchronous commit until the end
                if (res.ResultCode == (int)Code.OperationCancelled)
                {
                    if (isFromTransactionManager)
                    {
                        RingMasterEventSource.Log.ApplyBatchAborted(timeStreamId, batchId, minTransactionId, maxTransactionId, transactionId, timer.ElapsedMilliseconds);
                    }

                    return new RequestResponse
                    {
                        ResultCode = (int)Code.OperationCancelled,
                        Stat = default(Stat),
                        Content = results,
                    };
                }
            }

            if (needsSync)
            {
                RequestSetData multi = new RequestSetData("/$metadata/synchronization/$syncpoint", null, null, -1, null);
                this.ProcessMessage(new RequestMulti(new IRingMasterBackendRequest[] { multi }, null, null, true), session);
            }

            if (isFromTransactionManager)
            {
                RingMasterServerInstrumentation.Instance.OnTransactionManagerBatchApplied(batchId, maxTransactionId);
                RingMasterEventSource.Log.ApplyBatchSucceeded(timeStreamId, batchId, minTransactionId, maxTransactionId, timer.ElapsedMilliseconds);
            }

            return new RequestResponse()
            {
                ResultCode = (int)Code.Ok,
                Stat = default(Stat),
                Content = results,
            };
        }

        /// <summary>
        /// changes the synchroniozation requirements on the request based on wether this is the last request in a series,
        /// wether the current request requires or not synchronization, and if the series requires final synchronization.
        /// The table is as follows:
        ///   isLast    needsSync   r.CompleteSynchronously || r.CompleteSynchronously'    needsSync'
        /// ------------------------------------------------||-----------------------------------------
        ///     0          0               0                ||           0                     0
        ///     0          0               1                ||           0                     1
        ///     0          1               0                ||           0                     1
        ///     0          1               1                ||           0                     1
        ///     1          0               0                ||           0                     0
        ///     1          0               1                ||           1                     0
        ///     1          1               0                ||           1                     1
        ///     1          1               1                ||           1                     0
        /// The goal is for a series of operations, have at most ONE synchronization, and at the very end of the series,
        /// and if possible, not adding any additional artificial synchronization.
        /// </summary>
        /// <param name="r">Backend reqeust</param>
        /// <param name="isLast">Whether the request is the last one</param>
        /// <param name="previousValueForRequestSynchronous">Previous value for request synchronous</param>
        /// <param name="needsSync">needs sync</param>
        private void OverrideRequestSynchronization(IRingMasterBackendRequest r, bool isLast, ref bool previousValueForRequestSynchronous, ref bool needsSync)
        {
            // by default, request not multi or batch are async
            previousValueForRequestSynchronous = false;

            if (r.RequestType == RingMasterRequestType.Multi || r.RequestType == RingMasterRequestType.Batch)
            {
                IRingMasterBackendCompondRequest m = (IRingMasterBackendCompondRequest)r;

                previousValueForRequestSynchronous = m.CompleteSynchronously;

                m.CompleteSynchronously = isLast && (needsSync || previousValueForRequestSynchronous);

                if (previousValueForRequestSynchronous != m.CompleteSynchronously)
                {
                    this.PushDeepCompleteSynchronously(m);
                }
            }

            needsSync = (!isLast && (needsSync || previousValueForRequestSynchronous)) ||
                        (isLast && needsSync && !previousValueForRequestSynchronous);
        }

        private void PushDeepCompleteSynchronously(IRingMasterBackendCompondRequest m)
        {
            Debug.Assert(m != null, "m cannot be null");

            foreach (IRingMasterBackendRequest r in m.Requests)
            {
                if (r == null)
                {
                    continue;
                }

                if (r.RequestType == RingMasterRequestType.Multi || r.RequestType == RingMasterRequestType.Batch)
                {
                    IRingMasterBackendCompondRequest n = (IRingMasterBackendCompondRequest)r;

                    n.CompleteSynchronously = m.CompleteSynchronously;
                    this.PushDeepCompleteSynchronously(n);
                }
            }
        }

        /// <summary>
        /// restores a previously stored synchronization requirement for a request
        /// </summary>
        /// <param name="r">Backend request</param>
        /// <param name="previousValueForRequestSynchronous">Previous value for request synchronous</param>
        private void RestoreRequestSynchronization(IRingMasterBackendRequest r, bool previousValueForRequestSynchronous)
        {
            Debug.Assert(r != null, "r cannot be null");

            if (r.RequestType == RingMasterRequestType.Multi || r.RequestType == RingMasterRequestType.Batch)
            {
                ((IRingMasterBackendCompondRequest)r).CompleteSynchronously = previousValueForRequestSynchronous;
            }
        }

        /// <summary>
        /// locks the proper paths for a multi request, including nested multis if needed, and considering RO vs RW locks,
        /// and normalizing the path order.
        /// </summary>
        /// <param name="req">multi request</param>
        /// <param name="lockList">locklist giving context to this call</param>
        /// <param name="cancelled">If the operation is cancelled</param>
        private void LockMultiPathsInOrder(RequestMulti req, ILockListTransaction lockList, ref bool cancelled)
        {
            var pending = new Stack<RequestMulti>(req.Requests.Count);
            pending.Push(req);

            while (pending.Count > 0)
            {
                RequestMulti top = pending.Pop();
                foreach (var r in top.Requests)
                {
                    bool isMulti;
                    bool hasWatcher;
                    bool isReadOnly = this.IsReadOnlyRequest(r, out isMulti, out hasWatcher);

                    if (isMulti)
                    {
                        pending.Push((RequestMulti)r);
                    }
                    else
                    {
                        // skip empty paths
                        if (string.IsNullOrEmpty(r.Path))
                        {
                            continue;
                        }

                        Node parent;
                        Perm perm = isReadOnly ? Perm.READ : Perm.WRITE;

                        // Note: Need perm for both node and parent to ensure write lock is taken on both. If we are doing
                        // create or delete both the child and parent need to be write locked. At some point we may choose to
                        // optimize this by not obtaining parent write lock for SetData/SetAcl/etc. but that will require
                        // improving the sorting to put create/delete first to ensure we always take write lock before read lock
                        // because upgrade to write lock puts you at the end of the writer queue.
                        if (r.RequestType == RingMasterRequestType.Create)
                        {
                            // Be conservative and acquire writer lock the parent code (or the first one can be found in the path).
                            string childName; // not in use
                            Node match; // not in use
                            int resultLevel;
                            parent = this.Root.GetPathParent(r.Path, lockList, Node.WildCardBehavior.NotAllowed, out childName, out match, out resultLevel, true);
                            lockList.AddLockRw(parent, Perm.CREATE, resultLevel);
                        }
                        else
                        {
                            this.Root.GetNode(r.Path, lockList, Node.WildCardBehavior.AllowAnywhere, perm, perm, out parent);
                        }
                    }
                }
            }

            // Now acquire all locks
            lockList.LockAll(ref cancelled);
        }

        /// <summary>
        /// Move the specified node.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">the sessions locklist</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Move(RequestMove req, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;
            try
            {
                Node parentSrc;
                Node child;
                {
                    int childlevel;

                    // no no no, you cannot move commands
                    if (this.RmCommands.IsCommand(req.Path))
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badarguments,
                            Stat = null,
                            Content = null,
                        };
                    }

                    child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.NotAllowed, Perm.WRITE, Perm.DELETE, out parentSrc, out childlevel);

                    if (child == null)
                    {
                        // not found
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nonode,
                            Stat = null,
                            Content = null,
                        };
                    }

                    if (req.Version != -1)
                    {
                        // if the user cares about the version check it
                        if (!child.IsVersion(req.Version))
                        {
                            // grong version
                            return new RequestResponse()
                            {
                                ResultCode = (int)Code.Badversion,
                                Stat = null,
                                Content = null,
                            };
                        }
                    }

                    // no no no no... you cannot move the root!
                    if (parentSrc == null)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badarguments,
                            Stat = null,
                            Content = $"Can't move a node whose parent is null. Node level: {childlevel}, Node name: {child.Name}.",
                        };
                    }

                    if (!child.IsEmpty())
                    {
                        if ((req.MoveMode & MoveMode.OnlyIfSourcePathIsEmpty) == MoveMode.OnlyIfSourcePathIsEmpty)
                        {
                            return new RequestResponse()
                            {
                                ResultCode = (int)Code.Notempty,
                                Stat = null,
                                Content = null,
                            };
                        }
                    }
                }

                // source node is ready.
                // now get the destination node.
                Node parentDst = null;
                int parentDstlevel = 0;
                {
                    Node ignore;

                    parentDst = this.Root.GetNode(req.PathDst, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.CREATE, out ignore, out parentDstlevel);

                    if (parentDst == null && ((req.MoveMode & MoveMode.AllowPathCreationFlag) == MoveMode.AllowPathCreationFlag))
                    {
                        RequestCreate req1 = new RequestCreate(req.PathDst, null, null, null, CreateMode.PersistentAllowPathCreation, null);

                        RequestResponse resp = this.DispatchRequest(req1, session, lockList, hasAcquiredLocks);

                        if (resp.ResultCode != (int)Code.Ok)
                        {
                            return resp;
                        }
                        else
                        {
                            hasAcquiredLocks = true;
                        }

                        parentDst = this.Root.GetNode(req.PathDst, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.CREATE, out ignore, out parentDstlevel);
                    }

                    if (parentDst == null)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nonode,
                            Stat = null,
                            Content = null,
                        };
                    }

                    if (parentDst.Persisted.IsEphemeral)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nochildrenforephemerals,
                            Stat = null,
                            Content = null,
                        };
                    }
                }

                // now we are ready for deletion
                {
                    // the destination path for the creation has the name of the moved child
                    string finalDstName = req.PathDst + (req.PathDst == "/" ? string.Empty : "/") + child.Name;

                    // 1. Check child name doesn't exist in destination path
                    Node childDst = parentDst.TryGetChild(child.Name, false);

                    if (childDst != null)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Nodeexists,
                            Stat = null,
                            Content = null,
                        };
                    }

                    // 2. lock the parent at destination for writes
                    if (!hasAcquiredLocks)
                    {
                        lockList.AddLockRw(parentDst, Perm.CREATE, parentDstlevel, child.Persisted.IsEphemeral);
                        var cancelledd = false;
                        lockList.LockAll(ref cancelledd);
                    }

                    // 3. save old stats
                    IMutableStat prevStatParentSrc = lockList.SnapStatIfNeeded(parentSrc.Persisted);
                    IMutableStat prevStatParentDst = lockList.SnapStatIfNeeded(parentDst.Persisted);
                    IMutableStat prevChildStat = lockList.SnapStatIfNeeded(child.Persisted);

                    // 4. move the node
                    string parentSrcpath = req.Path.Substring(0, req.Path.Length - child.Name.Length);
                    string parentDstpath = req.PathDst;

                    ((IUnsafeTreeAccess)this).UnsafeRemoveChild(parentSrc.Persisted, child.Persisted, lockList.TxTime, parentSrcpath, lockList.TxId, lockList);

                    ((IUnsafeTreeAccess)this).UnsafeAddChild(parentDst.Persisted, child.Persisted, lockList.TxTime, parentDstpath, lockList.TxId, lockList);

                    lockList.AppendMove(parentSrc.Persisted, parentDst.Persisted, child.Persisted, lockList.TxTime, prevChildStat, prevStatParentSrc, prevStatParentDst);

                    abort = false;

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Ok,
                        Stat = child.NodeStat,
                        Content = finalDstName,
                    };
                }
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Deletes the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">the sessions locklist</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Delete(RequestDelete req, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;
            try
            {
                Node parent;

                int childlevel;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.NotAllowed, Perm.WRITE, Perm.DELETE, out parent, out childlevel);

                if (child == null)
                {
                    if ((req.DeleteMode & DeleteMode.SuccessEvenIfNodeDoesntExist) == DeleteMode.SuccessEvenIfNodeDoesntExist)
                    {
                        abort = false;

                        // note stat will be null indicating the delete was not needed
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Ok,
                            Stat = null,
                            Content = null,
                        };
                    }

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                    };
                }

                if (!child.IsVersion(req.Version))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = child.NodeStat,
                        Content = null,
                    };
                }

                // no no no no... you cannot delete the root!
                if (parent == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = child.NodeStat,
                        Content = $"Can't remove a node whose parent is null. Node level: {childlevel}, Node name: {child.Name}.",
                    };
                }

                if (!hasAcquiredLocks)
                {
                    lockList.AddLockRw(parent, Perm.DELETE, parent.GetLevel());
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                if (!child.IsEmpty())
                {
                    if (!req.IsCascade)
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Notempty,
                            Stat = child.NodeStat,
                            Content = null,
                        };
                    }

                    if (!req.DeleteMode.HasFlag(DeleteMode.FastDelete) || DeleteTask.RequiresIndividualDeletes(this))
                    {
                        // Slow delete
                        this.UnsafeDeleteChildren(lockList, session, req.Path.Substring(0, req.Path.LastIndexOf('/')), child, childlevel);
                        this.DeleteEmptyNode(lockList, session, parent, req.Path, child);
                    }
                    else
                    {
                        // Fast delete
                        this.DoFastDelete(lockList, session, parent, req.Path, child);
                    }
                }
                else
                {
                    this.DeleteEmptyNode(lockList, session, parent, req.Path, child);
                }

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = null,
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestDeleteFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        private void DoFastDelete(ILockListTransaction lockList, ClientSession session, Node parent, string childpath, Node child)
        {
            IMutableStat prevChildStat = lockList.SnapStatIfNeeded(child.Persisted);
            IMutableStat prevParentStat = lockList.SnapStatIfNeeded(parent.Persisted);

            DeleteTask cnt = new DeleteTask(lockList, session, this, child);
            cnt.DeleteNodesRecursively();
            ((IUnsafeTreeAccess)this).UnsafeRemove(parent.Persisted, child.Persisted, lockList.TxTime, childpath, lockList.TxId, lockList);
        }

        private void DeleteEmptyNode(ILockListTransaction lockList, ClientSession session, Node parent, string childpath, Node child)
        {
            IMutableStat prevChildStat = lockList.SnapStatIfNeeded(child.Persisted);
            IMutableStat prevParentStat = lockList.SnapStatIfNeeded(parent.Persisted);

            ((IUnsafeTreeAccess)this).UnsafeRemove(parent.Persisted, child.Persisted, lockList.TxTime, childpath, lockList.TxId, lockList);

            lockList.AppendRemove(
                parent.Persisted,
                child.Persisted,
                lockList.TxTime,
                prevChildStat,
                prevParentStat,
                () =>
                {
                    if (child.Persisted.IsEphemeral)
                    {
                        this.EphemeralFactory.RecordNodeUndelete(child.Persisted);
                    }
                    else
                    {
                        this.Factory.RecordNodeUndelete(child.Persisted);
                    }
                });

            lockList.RunOnCommit(() =>
            {
                if (child.Persisted.IsEphemeral)
                {
                    RingMasterServerInstrumentation.Instance.UpdateEphemeralNodeCounts(this.EphemeralFactory.TotalData, this.EphemeralFactory.TotalNodes);
                }
                else
                {
                    RingMasterServerInstrumentation.Instance.UpdatePersistentNodeCounts(this.Factory.TotalData, this.Factory.TotalNodes);
                }

                session.RemoveOnTerminateAction("oid-" + child.GlobalUniqueId);
            });
        }

        private void UnsafeDeleteChildren(ILockListTransaction lockList, ClientSession session, string parentpath, Node node, int childLevel)
        {
            string childpath = parentpath + "/" + node.Name;

            var completeNode = node as CompleteNode;
            if (completeNode != null)
            {
                var childrenPersistedData = completeNode.ChildrenNodes.ToList();
                foreach (var pd in childrenPersistedData)
                {
                    if (pd.GetChildrenCount() != 0)
                    {
                        this.UnsafeDeleteChildren(lockList, session, childpath, pd.Node, childLevel + 1);
                    }

                    this.DeleteEmptyNode(lockList, session, node, childpath + "/" + pd.Name, pd.Node);
                }
            }
        }

        /// <summary>
        /// Checks the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="lockList">Lock list to keep the locks on the request path</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Check(RequestCheck req, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;
            try
            {
                Node parent;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.AllowInBranch, Perm.READ, Perm.READ, out parent);
                if (!hasAcquiredLocks)
                {
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                    };
                }

                if (!child.IsVersion(req.Version, req.UniqueIncarnationId, req.UniqueIncarnationIdKind))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = child.NodeStat,
                        Content = null,
                    };
                }

                if (!child.IsChildVersion(req.CVersion))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = child.NodeStat,
                        Content = null,
                    };
                }

                if (!child.IsAclVersion(req.AVersion))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = child.NodeStat,
                        Content = null,
                    };
                }

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = null,
                };
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Existses the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">The session's locklist</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Exists(RequestExists req, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;
            try
            {
                Node parent;

                bool bulkWatcherSpecifierWasPresent = false;
                string path = BulkOperation.RemoveBulkWatcherSpecifier(req.Path, out bulkWatcherSpecifierWasPresent);

                Node child = this.Root.GetNode(path, lockList, Node.WildCardBehavior.AllowInBranch, Perm.READ, Perm.READ, out parent);

                if (!hasAcquiredLocks)
                {
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                    };
                }

                RegisterWatcherOnNode(req.Watcher, session, lockList, req.Path, child);

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Content = child.NodeStat,
                    Stat = null,
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestExistsFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Gets the acl.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="lockList">the session's locklist</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse GetAcl(RequestGetAcl req, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;
            try
            {
                Node parent;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.READ, Perm.READ, out parent);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                    };
                }

                if (!hasAcquiredLocks)
                {
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                // We shouldnt be checking version for this API since there is no way to specify one correctly if you want the latest one.
                // So we make Stat Optional here. If specified we strictly check versions. If not specified, we give you back the latest we have
                if (req.Stat != null)
                {
                    if (!child.IsAclVersion(req.Stat.Aversion) ||
                        !child.IsVersion(req.Stat.Version) ||
                        !child.IsChildVersion(req.Stat.Cversion))
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badversion,
                            Stat = null,
                            Content = null,
                        };
                    }
                }

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = child.Acl,
                };
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Gets the children.
        /// </summary>
        /// <param name="request">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">the sessions locklist</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse GetChildren(RequestGetChildren request, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;
            try
            {
                Stopwatch timer = Stopwatch.StartNew();
                Node parent;
                Node child = this.Root.GetNode(request.Path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.READ, Perm.READ, out parent);

                if (child == null)
                {
                    // this is a metanode, that returns the list of watchers for the parent node
                    if (parent != null && request.Path.EndsWith("$watchers") && request.Watcher == null)
                    {
                        string[] watchers = parent.GetWatcherList();

                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Ok,
                            Stat = parent.NodeStat,
                            Content = watchers,
                        };
                    }

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                    };
                }

                if (!hasAcquiredLocks)
                {
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                if ((child.ChildrenCount > this.limits.MaxGetChildrenEnumerationCount) && string.IsNullOrEmpty(request.RetrievalCondition))
                {
                    RingMasterEventSource.Log.RequestGetChildrenEnumerationLimitExceeded(
                        session.SessionId,
                        request.Uid,
                        request.Path,
                        child.ChildrenCount,
                        this.limits.MaxGetChildrenEnumerationCount);

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.TooManyChildren,
                        Stat = null,
                        Content = null,
                    };
                }

                RegisterWatcherOnNode(request.Watcher, session, lockList, request.Path, child);

                IList<string> children;

                try
                {
                    children = child.RetrieveChildren(request.RetrievalCondition, this.limits.MaxGetChildrenEnumerationCount).ToList();
                }
                catch (ArgumentException exception)
                {
                    RingMasterEventSource.Log.RequestGetChildrenRetrieveChildrenFailed(session.SessionId, request.Uid, request.Path, child.ChildrenCount, request.RetrievalCondition, exception.ToString());
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = null,
                    };
                }

                abort = false;

                timer.Stop();
                RingMasterEventSource.Log.RequestGetChildrenSucceeded(
                    session.SessionId,
                    request.Uid,
                    request.Path,
                    request.RetrievalCondition,
                    children.Count,
                    timer.ElapsedMilliseconds);

                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = children,
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestGetChildrenFailed(session.SessionId, request.Uid, request.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Gets the data.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The session.</param>
        /// <param name="lockList">The session's Locklist</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse GetData(RequestGetData req, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;

            try
            {
                Node parent;

                bool isBulk = false;
                bool withStat;

                if (PathDecoration.IsFullContentPath(req.Path, out withStat))
                {
                    req.Path = PathDecoration.GetBasePathForFullContentPath(req.Path);
                    isBulk = true;
                }

                Node.WildCardBehavior wildcard = Node.WildCardBehavior.AllowAnywhere;

                if (req.NoWildcardsForPath)
                {
                    wildcard = Node.WildCardBehavior.NotAllowed;
                }

                Node child = this.Root.GetNode(req.Path, lockList, wildcard, Perm.READ, Perm.READ, out parent, out int childlevel, req.FaultbackOnParentData, req.OptionArgument);
                if (isBulk)
                {
                    // this is to avoid a race condition that while this thread is trying to get full subtree, another thread might be trying to update the tree.
                    lockList.AddLockRw(child, Perm.READ, childlevel);
                }

                string responsePath = null;

                if (child == null)
                {
                    string parentPath = null;

                    if (req.FaultbackOnParentData && parent != null)
                    {
                        parentPath = Node.BuildPath(parent.Persisted);
                    }

                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                        ResponsePath = parentPath,
                    };
                }

                if (!hasAcquiredLocks)
                {
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                // if the child returning the data is not the one queried, return the real path.
                responsePath = req.Path;

                if (req.FaultbackOnParentData)
                {
                    responsePath = Node.BuildPath(child.Persisted);
                }

                if (isBulk)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Ok,
                        Stat = req.NoStatRequired ? null : child.NodeStat,
                        Content = BulkOperation.SerializeAllData(child, withStat),
                        ResponsePath = responsePath,
                    };
                }

                RegisterWatcherOnNode(req.Watcher, session, lockList, req.Path, child);

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = req.NoStatRequired ? null : child.NodeStat,
                    Content = child.Data,
                    ResponsePath = responsePath,
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestGetDataFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Synchronizes the specified req.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="lockList">The session's LockList</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse Sync(RequestSync req, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;
            Node child = null;

            try
            {
                Node parent;
                child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.NotAllowed, Perm.READ, Perm.READ, out parent);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                    };
                }

                if (!hasAcquiredLocks)
                {
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                RequestResponse resp = null;

                if (child != null)
                {
                    lockList.RunOnCommit(() =>
                    {
                        child.Sync();

                        // we need to modify the returned stat after the sync completes.
                        resp.Stat = child.NodeStat;
                    });
                }

                abort = false;

                resp = new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = null,
                    Content = null,
                };

                return resp;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Generates a change that will produce a poison pill on the given path
        /// </summary>
        /// <param name="path">the path to poison</param>
        /// <param name="spec">the poison pill specification</param>
        /// <param name="session">the session that generated the pill</param>
        /// <param name="lockList">the locklist for the invocation</param>
        private void SetPoisonPillPath(string path, string spec, IClientSession session, ILockListTransaction lockList)
        {
            if (session == null)
            {
                throw new ArgumentNullException(nameof(session));
            }

            if (lockList == null)
            {
                throw new ArgumentNullException(nameof(lockList));
            }

            Node parent;
            Node child = this.Root.GetNode(path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.ADMIN, Perm.READ, out parent);

            if (child == null)
            {
                throw new KeyNotFoundException(path);
            }

            lockList.AppendPoison(child.Persisted, spec, lockList.TxTime);
        }

        /// <summary>
        /// Sets the acl.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The client session</param>
        /// <param name="lockList">the sessions locklist</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse SetAcl(RequestSetAcl req, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;

            try
            {
                if (req.Acl != null)
                {
                    string aclValidationErrorMessage;
                    if (!this.ValidateAclLimits(req.Acl, session, out aclValidationErrorMessage))
                    {
                        return new RequestResponse()
                        {
                            ResultCode = (int)Code.Badarguments,
                            Stat = null,
                            Content = aclValidationErrorMessage,
                        };
                    }
                }

                Node parent;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.ADMIN, Perm.READ, out parent);

                if (!hasAcquiredLocks)
                {
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                    };
                }

                if (!child.IsAclVersion(req.Version))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = null,
                        Content = null,
                    };
                }

                ////child.LockWrite(lockList, Perm.ADMIN);
                IMutableStat prevStat = lockList.SnapStatIfNeeded(child.Persisted);
                IReadOnlyList<Acl> prevAcl = child.Persisted.Acl;

                IReadOnlyList<Acl> newAcl = null;

                if (req.Acl != null && req.Acl.Count > 0)
                {
                    newAcl = req.Acl;
                }

                ((IUnsafeTreeAccess)this).UnsafeSetAcl(child.Persisted, newAcl, lockList.TxTime, req.Path, lockList.TxId, lockList);

                lockList.AppendSetAcl(child.Persisted, lockList.TxTime, prevAcl, prevStat);

                abort = false;
                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = null,
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestSetAclFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// Sets the data.
        /// </summary>
        /// <param name="req">The req.</param>
        /// <param name="session">The client session</param>
        /// <param name="lockList">the sesisons locklist</param>
        /// <param name="hasAcquiredLocks">If all locks have been acquired and no more lock is needed</param>
        /// <returns>RequestResponse.</returns>
        private RequestResponse SetData(RequestSetData req, ClientSession session, ILockListTransaction lockList, bool hasAcquiredLocks)
        {
            bool abort = true;

            try
            {
                if (req.Data != null && this.limits.MaxNodeDataSize > 0 && req.Data.Length > this.limits.MaxNodeDataSize && !SessionIsLimitExempt(session))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badarguments,
                        Stat = null,
                        Content = string.Format("Data size exceeds maximum of {0} bytes", this.limits.MaxNodeDataSize),
                    };
                }

                Node parent;
                int childlevel;
                Node child = this.Root.GetNode(req.Path, lockList, Node.WildCardBehavior.AllowAnywhere, Perm.WRITE, Perm.READ, out parent, out childlevel);

                if (child == null)
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Nonode,
                        Stat = null,
                        Content = null,
                    };
                }

                if (!child.IsVersion(req.Version))
                {
                    return new RequestResponse()
                    {
                        ResultCode = (int)Code.Badversion,
                        Stat = null,
                        Content = null,
                    };
                }

                if (!hasAcquiredLocks)
                {
                    var cancelledd = false;
                    lockList.LockAll(ref cancelledd);
                }

                byte[] prevData = child.Persisted.Data;

                IMutableStat prevStat = lockList.SnapStatIfNeeded(child.Persisted);

                byte[] data = req.Data;
                if (req.IsDataCommand)
                {
                    SetDataOperations op = SetDataOperations.TryCreate(child.Persisted, req);
                    if (op != null)
                    {
                        data = op.GetRequestData();
                    }
                }

                IPersistedData node = child.Persisted;

                // It is possible for this setData to be a command for a replica.
                if (session != null && req.Path.StartsWith(this.ReplicaCommandPathPrefix))
                {
                    RingMasterEventSource.Log.RequestCommand(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, req.Path);
                    this.auditConsumer?.OnRequestCommand(session.SessionId, session.Auth.ClientIP, session.Auth.ClientIdentity, req.Path);
                }

                ((IUnsafeTreeAccess)this).UnsafeSetData(node, data, lockList.TxTime, req.Path, lockList.TxId, lockList);

                lockList.AppendSetData(child.Persisted, lockList.TxTime, prevData, prevStat);

                lockList.RunOnCommit(() =>
                {
                    if (child.Persisted.IsEphemeral)
                    {
                        RingMasterServerInstrumentation.Instance.UpdateEphemeralNodeCounts(this.EphemeralFactory.TotalData, this.EphemeralFactory.TotalNodes);
                    }
                    else
                    {
                        RingMasterServerInstrumentation.Instance.UpdatePersistentNodeCounts(this.Factory.TotalData, this.Factory.TotalNodes);
                    }
                });

                abort = false;

                return new RequestResponse()
                {
                    ResultCode = (int)Code.Ok,
                    Stat = child.NodeStat,
                    Content = null,
                };
            }
            catch (Exception ex)
            {
                if (!IsUserError(ex))
                {
                    RingMasterEventSource.Log.RequestSetDataFailed(session.SessionId, req.Uid, req.Path, ex.ToString());
                }

                throw;
            }
            finally
            {
                if (abort)
                {
                    lockList.MarkForAbort();
                }
            }
        }

        /// <summary>
        /// returns the path to the parent of the given node
        /// </summary>
        /// <param name="path">the path to the child</param>
        /// <returns>the path to the parent</returns>
        private string GetParentPath(string path)
        {
            if (path == null)
            {
                return null;
            }

            int idx = path.LastIndexOf('/');
            if (idx <= 0)
            {
                return "/";
            }

            return path.Substring(0, idx);
        }

        private bool ValidateAclLimits(IReadOnlyList<Acl> acls, ClientSession session, out string errorMessage)
        {
            errorMessage = null;

            if (acls == null)
            {
                return true;
            }

            if (this.limits.MaxAclsPerNode > 0 && acls.Count > this.limits.MaxAclsPerNode && !SessionIsLimitExempt(session))
            {
                errorMessage = string.Format("Number of ACLs exceeds maximum allowed of {0}", this.limits.MaxAclsPerNode);
                return false;
            }

            if (acls.Any(a => a == null || a.Id == null || (this.limits.MaxAclIdentiferLength > 0 && ((a.Id.Scheme.Length > this.limits.MaxAclIdentiferLength) || (a.Id.Identifier != null && a.Id.Identifier.Length > this.limits.MaxAclIdentiferLength)) && !SessionIsLimitExempt(session))))
            {
                errorMessage = string.Format("Invalid ACL specified. ACLs must not be null, have a scheme, and must have scheme/identifer length of no more than {0} characters", this.limits.MaxAclIdentiferLength);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Class RequestInternalRun.
        /// </summary>
        public class RequestInternalRun : BackendRequestWithContext<RequestDefinitions.RequestInternalRun, NoType>
        {
            private readonly VoidCallbackDelegate callback;

            /// <summary>
            /// Initializes a new instance of the <see cref="RequestInternalRun"/> class.
            /// </summary>
            /// <param name="path">The Path</param>
            /// <param name="ctx">Context</param>
            /// <param name="actionToRun">Action to run</param>
            /// <param name="cb">Callback delegate</param>
            /// <param name="uid">Unique ID</param>
            public RequestInternalRun(string path, object ctx, Func<RequestInternalRun, ILockListTransaction, RequestResponse> actionToRun, VoidCallbackDelegate cb, ulong uid = 0)
                : base(new RequestDefinitions.RequestInternalRun(path, uid), ctx)
            {
                this.ActionToRun = actionToRun;
                this.callback = cb;
            }

            /// <summary>
            /// Gets the action to run
            /// </summary>
            public Func<RequestInternalRun, ILockListTransaction, RequestResponse> ActionToRun
            {
                get; private set;
            }

            /// <inheritdoc />
            protected override void NotifyComplete(int resultCode, NoType ignore, IStat stat)
            {
                if (this.callback == null)
                {
                    return;
                }

                this.callback(resultCode, this.Path, this.Context);
            }
        }

        private class DeleteTask
        {
            private readonly ILockListTransaction lockList;
            private readonly ClientSession session;
            private readonly bool anyBulkWatcher;
            private readonly RingMasterBackendCore backend;
            private readonly Node topNode;
            private Node node;
            private int numPersistent;
            private int dataPersistent;

            public DeleteTask(ILockListTransaction lockList, ClientSession session, RingMasterBackendCore backend, Node child)
            {
                if (RequiresIndividualDeletes(backend))
                {
                    throw new InvalidOperationException("fast delete is only for factories not requiring individual deletes");
                }

                this.backend = backend;
                this.lockList = lockList;
                this.session = session;
                this.anyBulkWatcher = ClientSession.AnyBulkWatcher(child.BuildPath());
                this.topNode = this.node = child;
                this.numPersistent = 0;
                this.dataPersistent = 0;
            }

            public static bool RequiresIndividualDeletes(RingMasterBackendCore backend)
            {
                return backend.EphemeralFactory.RequiresCallsForEachDelete || backend.Factory.RequiresCallsForEachDelete;
            }

            public void DeleteNodesRecursively()
            {
                this.InternalDeleteNodesRecursively();

                this.lockList.AppendRemoveNodeAndAllChildren(this.topNode.Persisted, this.lockList.TxTime, null);

                this.lockList.RunOnCommit(() =>
                {
                    // we didn't remove the stats as we browsed the tree,
                    // so during "commit", we need to correct the stats
                    this.backend.Factory.RecordStatsDelta(-this.numPersistent, -this.dataPersistent);

                    RingMasterServerInstrumentation.Instance.UpdateEphemeralNodeCounts(this.backend.EphemeralFactory.TotalData, this.backend.EphemeralFactory.TotalNodes);
                    RingMasterServerInstrumentation.Instance.UpdatePersistentNodeCounts(this.backend.Factory.TotalData, this.backend.Factory.TotalNodes);
                });
            }

            private void InternalDeleteNodesRecursively()
            {
                IPersistedData pd = this.node.Persisted;

                if (pd.IsEphemeral)
                {
                    this.lockList.RunOnCommit(() =>
                    {
                        this.session.RemoveOnTerminateAction("oid-" + this.node.GlobalUniqueId);
                    });
                }
                else
                {
                    if (this.topNode != this.node)
                    {
                        this.numPersistent++;
                        this.dataPersistent += pd.Stat.DataLength;
                    }
                }

                if (this.anyBulkWatcher || this.node.HasWatchers())
                {
                    // note we will call BuildPath for every node with watcher. That is a good choice if there is not that many nodes with watchers.
                    this.node.ScheduleTriggerWatchers(ChangeKind.NodeDeleted, this.node.BuildPath(), this.lockList);
                }

                if (!this.node.IsEmpty())
                {
                    // note this.node will change as per the recursion from this point on, so we should not make assumptions about its value anymore
                    // and use only pd.Node
                    foreach (IPersistedData child in ((CompleteNode)pd.Node).ChildrenNodes)
                    {
                        this.node = child.Node;
                        this.InternalDeleteNodesRecursively();
                    }
                }
            }
        }

        /// <summary>
        /// Defines RingMaster Limits
        /// </summary>
        private sealed class RingMasterLimits
        {
            /// <summary>
            /// Gets or sets the maximum number of characters allowed in a single node name
            /// </summary>
            public uint MaxNodeNameLength { get; set; }

            /// <summary>
            /// Gets or sets the total maximum number of characters allowed in a full node path (including /)
            /// </summary>
            public uint MaxNodePathLength { get; set; }

            /// <summary>
            /// Gets or sets the maximum data size of a node in bytes
            /// </summary>
            public uint MaxNodeDataSize { get; set; }

            /// <summary>
            /// Gets or sets the maximum number of ACLs allowed per node
            /// </summary>
            public uint MaxAclsPerNode { get; set; }

            /// <summary>
            /// Gets or sets the maximum length of an ACL identifer
            /// </summary>
            public uint MaxAclIdentiferLength { get; set; }

            /// <summary>
            /// Gets or sets the maximum number of children that can be retrieved by a
            /// single GetChildren request.
            /// </summary>
            public int MaxGetChildrenEnumerationCount { get; set; }

            /// <summary>
            /// Gets or sets threshold of number of child nodes for a node below which a sorted dictionary will not be used.
            /// </summary>
            public int MinSortedDictionaryThreshold { get; set; }

            /// <summary>
            /// Gets or sets threshold of number of child nodes for a node above which a sorted dictionary will be used.
            /// </summary>
            public int MaxSortedDictionaryThreshold { get; set; }

            /// <summary>
            /// Gets or sets the limit in ms for batch request execution.
            /// </summary>
            public int MaxBatchExecutionMilliseconds { get; set; }

            /// <summary>
            /// Gets or sets the limit in ms for multi request execution.
            /// </summary>
            public int MaxMultiExecutionMilliseconds { get; set; }
        }

        /// <summary>
        /// Data structure to keep track of time stream progress.
        /// </summary>
        private sealed class TimeStreamInfo
        {
            public ulong LastSeenTransactionId { get; set; } = ulong.MaxValue;

            public ulong LastAppliedBatchId { get; set; } = ulong.MaxValue;
        }
    }
}
